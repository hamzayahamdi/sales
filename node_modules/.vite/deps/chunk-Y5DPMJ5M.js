import {
  ArrowDropDownIcon,
  DAY_MARGIN,
  DEFAULT_DESKTOP_MODE_MEDIA_QUERY,
  DayCalendar,
  PickersArrowSwitcher,
  PickersDay,
  PickersLayout,
  PickersModalDialog,
  PickersProvider,
  PickersTextField,
  PickersToolbar,
  PickersToolbarButton,
  VIEW_HEIGHT,
  applyDefaultDate,
  composeClasses,
  convertFieldResponseIntoMuiTextFieldProps,
  extractValidationProps,
  generateUtilityClass,
  generateUtilityClasses,
  isEndOfRange,
  isRangeValid,
  isStartOfRange,
  isWithinRange,
  mergeDateAndTime,
  onSpaceOrEnter,
  ponyfillGlobal_default,
  rangeValueManager,
  refType_default,
  singleItemFieldValueManager,
  singleItemValueManager,
  useCalendarState,
  useClearableField,
  useControlled,
  useControlledValueWithTimezone,
  useDefaultDates,
  useDefaultReduceAnimations,
  useDefaultizedDateField,
  useEventCallback_default,
  useField,
  useId,
  useNextMonthDisabled,
  useNow,
  usePicker,
  usePickersTranslations,
  usePreviousMonthDisabled,
  useSplitFieldProps,
  useUtils,
  useValidation,
  useViews,
  validateDate,
  validateDateRange,
  warnOnce
} from "./chunk-VUQEWH3E.js";
import {
  resolveComponentProps_default,
  useForkRef,
  useSlotProps_default
} from "./chunk-EDV6QM7B.js";
import {
  Stack_default
} from "./chunk-WACTC3ZX.js";
import {
  IconButton_default,
  TextField_default,
  Typography_default
} from "./chunk-AP5WQ4HC.js";
import {
  Fade_default
} from "./chunk-AIMWWQ6F.js";
import {
  TransitionGroup_default
} from "./chunk-L4WDKTQM.js";
import {
  useTheme
} from "./chunk-WVV7IMY3.js";
import {
  alpha,
  useMediaQuery
} from "./chunk-MOXAFMSH.js";
import {
  useThemeProps
} from "./chunk-OSQTWLP3.js";
import {
  styled_default
} from "./chunk-COWLL2I3.js";
import {
  require_prop_types
} from "./chunk-OQF6RW5S.js";
import {
  _objectWithoutPropertiesLoose
} from "./chunk-SRCT3FTM.js";
import {
  _extends,
  init_extends
} from "./chunk-KDDRG47R.js";
import {
  clsx_default
} from "./chunk-UVUMECS7.js";
import {
  require_jsx_runtime
} from "./chunk-UIAEJQAT.js";
import {
  require_react
} from "./chunk-RA4EGHW6.js";
import {
  __toESM
} from "./chunk-2LSFTFF7.js";

// node_modules/@mui/x-date-pickers-pro/MobileDateRangePicker/MobileDateRangePicker.js
init_extends();
var React19 = __toESM(require_react());
var import_prop_types8 = __toESM(require_prop_types());

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/shared.js
init_extends();
var React2 = __toESM(require_react());

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/DateRangePickerToolbar.js
init_extends();
var React = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/dateRangePickerToolbarClasses.js
function getDateRangePickerToolbarUtilityClass(slot) {
  return generateUtilityClass("MuiDateRangePickerToolbar", slot);
}
var dateRangePickerToolbarClasses = generateUtilityClasses("MuiDateRangePickerToolbar", ["root", "container"]);

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/DateRangePickerToolbar.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var _excluded = ["value", "rangePosition", "onRangePositionChange", "toolbarFormat", "className", "onViewChange", "view", "views"];
var useUtilityClasses = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    container: ["container"]
  };
  return composeClasses(slots, getDateRangePickerToolbarUtilityClass, classes);
};
var DateRangePickerToolbarRoot = styled_default(PickersToolbar, {
  name: "MuiDateRangePickerToolbar",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})({});
var DateRangePickerToolbarContainer = styled_default("div", {
  name: "MuiDateRangePickerToolbar",
  slot: "Container",
  overridesResolver: (_, styles) => styles.container
})({
  display: "flex"
});
var DateRangePickerToolbar = React.forwardRef(function DateRangePickerToolbar2(inProps, ref) {
  const utils = useUtils();
  const props = useThemeProps({
    props: inProps,
    name: "MuiDateRangePickerToolbar"
  });
  const {
    value: [start, end],
    rangePosition,
    onRangePositionChange,
    toolbarFormat,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
  const translations = usePickersTranslations();
  const startDateValue = start ? utils.formatByString(start, toolbarFormat || utils.formats.shortDate) : translations.start;
  const endDateValue = end ? utils.formatByString(end, toolbarFormat || utils.formats.shortDate) : translations.end;
  const ownerState = props;
  const classes = useUtilityClasses(ownerState);
  return (0, import_jsx_runtime.jsx)(DateRangePickerToolbarRoot, _extends({}, other, {
    toolbarTitle: translations.dateRangePickerToolbarTitle,
    isLandscape: false,
    className: clsx_default(classes.root, className),
    ownerState,
    ref,
    children: (0, import_jsx_runtime.jsxs)(DateRangePickerToolbarContainer, {
      className: classes.container,
      children: [(0, import_jsx_runtime.jsx)(PickersToolbarButton, {
        variant: start !== null ? "h5" : "h6",
        value: startDateValue,
        selected: rangePosition === "start",
        onClick: () => onRangePositionChange("start")
      }), (0, import_jsx_runtime.jsxs)(Typography_default, {
        variant: "h5",
        children: [" ", "–", " "]
      }), (0, import_jsx_runtime.jsx)(PickersToolbarButton, {
        variant: end !== null ? "h5" : "h6",
        value: endDateValue,
        selected: rangePosition === "end",
        onClick: () => onRangePositionChange("end")
      })]
    })
  }));
});
true ? DateRangePickerToolbar.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types.default.object,
  className: import_prop_types.default.string,
  disabled: import_prop_types.default.bool,
  /**
   * If `true`, show the toolbar even in desktop mode.
   * @default `true` for Desktop, `false` for Mobile.
   */
  hidden: import_prop_types.default.bool,
  onRangePositionChange: import_prop_types.default.func.isRequired,
  /**
   * Callback called when a toolbar is clicked
   * @template TView
   * @param {TView} view The view to open
   */
  onViewChange: import_prop_types.default.func.isRequired,
  rangePosition: import_prop_types.default.oneOf(["end", "start"]).isRequired,
  readOnly: import_prop_types.default.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
  titleId: import_prop_types.default.string,
  /**
   * Toolbar date format.
   */
  toolbarFormat: import_prop_types.default.string,
  /**
   * Toolbar value placeholder—it is displayed when the value is empty.
   * @default "––"
   */
  toolbarPlaceholder: import_prop_types.default.node,
  value: import_prop_types.default.arrayOf(import_prop_types.default.object).isRequired,
  /**
   * Currently visible picker view.
   */
  view: import_prop_types.default.oneOf(["day"]).isRequired,
  /**
   * Available views.
   */
  views: import_prop_types.default.arrayOf(import_prop_types.default.oneOf(["day"])).isRequired
} : void 0;

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/shared.js
function useDateRangePickerDefaultizedProps(props, name) {
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const themeProps = useThemeProps({
    props,
    name
  });
  const localeText = React2.useMemo(() => {
    var _a;
    if (((_a = themeProps.localeText) == null ? void 0 : _a.toolbarTitle) == null) {
      return themeProps.localeText;
    }
    return _extends({}, themeProps.localeText, {
      dateRangePickerToolbarTitle: themeProps.localeText.toolbarTitle
    });
  }, [themeProps.localeText]);
  return _extends({}, themeProps, {
    localeText,
    disableFuture: themeProps.disableFuture ?? false,
    disablePast: themeProps.disablePast ?? false,
    minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate),
    slots: _extends({
      toolbar: DateRangePickerToolbar
    }, themeProps.slots)
  });
}

// node_modules/@mui/x-date-pickers-pro/dateRangeViewRenderers/dateRangeViewRenderers.js
var React13 = __toESM(require_react());

// node_modules/@mui/x-date-pickers-pro/DateRangeCalendar/DateRangeCalendar.js
init_extends();
var React12 = __toESM(require_react());
var import_prop_types5 = __toESM(require_prop_types());

// node_modules/@mui/x-license/encoding/md5.js
var k = [];
var i = 0;
for (; i < 64; ) {
  k[i] = 0 | Math.sin(++i % Math.PI) * 4294967296;
}
function md5(s) {
  const words = [];
  let b, c, d, j = unescape(encodeURI(s)) + "", a = j.length;
  const h = [b = 1732584193, c = 4023233417, ~b, ~c];
  s = --a / 4 + 2 | 15;
  words[--s] = a * 8;
  for (; ~a; ) {
    words[a >> 2] |= j.charCodeAt(a) << 8 * a--;
  }
  for (i = j = 0; i < s; i += 16) {
    a = h;
    for (; j < 64; a = [d = a[3], b + ((d = a[0] + [b & c | ~b & d, d & b | ~d & c, b ^ c ^ d, c ^ (b | ~d)][a = j >> 4] + k[j] + ~~words[i | [j, 5 * j + 1, 3 * j + 5, 7 * j][a] & 15]) << (a = [7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21][4 * a + j++ % 4]) | d >>> -a), b, c]) {
      b = a[1] | 0;
      c = a[2];
    }
    for (j = 4; j; )
      h[--j] += a[j];
  }
  for (s = ""; j < 32; ) {
    s += (h[j >> 3] >> (1 ^ j++) * 4 & 15).toString(16);
  }
  return s;
}

// node_modules/@mui/x-license/encoding/base64.js
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var base64Decode = (input) => {
  let output = "";
  let chr1, chr2, chr3;
  let enc1, enc2, enc3, enc4;
  let i2 = 0;
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  while (i2 < input.length) {
    enc1 = _keyStr.indexOf(input.charAt(i2++));
    enc2 = _keyStr.indexOf(input.charAt(i2++));
    enc3 = _keyStr.indexOf(input.charAt(i2++));
    enc4 = _keyStr.indexOf(input.charAt(i2++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    output = output + String.fromCharCode(chr1);
    if (enc3 != 64) {
      output = output + String.fromCharCode(chr2);
    }
    if (enc4 != 64) {
      output = output + String.fromCharCode(chr3);
    }
  }
  return output;
};

// node_modules/@mui/x-license/utils/plan.js
var PLAN_SCOPES = ["pro", "premium"];

// node_modules/@mui/x-license/utils/licenseModel.js
var LICENSE_MODELS = [
  /**
   * A license is outdated if the current version of the software was released after the expiry date of the license.
   * But the license can be used indefinitely with an older version of the software.
   */
  "perpetual",
  /**
   * On development, a license is outdated if the expiry date has been reached
   * On production, a license is outdated if the current version of the software was released after the expiry date of the license (see "perpetual")
   */
  "annual",
  /**
   * Legacy. The previous name for 'annual'.
   * Can be removed once old license keys generated with 'subscription' are no longer supported.
   * To support for a while. We need more years of backward support and we sell multi year licenses.
   */
  "subscription"
];

// node_modules/@mui/x-license/utils/licenseErrorMessageUtils.js
function showError(message) {
  console.error(["*************************************************************", "", ...message, "", "*************************************************************"].join("\n"));
}
function showInvalidLicenseKeyError() {
  showError(["MUI X: Invalid license key.", "", "Your MUI X license key format isn't valid. It could be because the license key is missing a character or has a typo.", "", "To solve the issue, you need to double check that `setLicenseKey()` is called with the right argument", "Please check the license key installation https://mui.com/r/x-license-key-installation."]);
}
function showLicenseKeyPlanMismatchError() {
  showError(["MUI X: License key plan mismatch.", "", "Your use of MUI X is not compatible with the plan of your license key. The feature you are trying to use is not included in the plan of your license key. This happens if you try to use Data Grid Premium with a license key for the Pro plan.", "", "To solve the issue, you can upgrade your plan from Pro to Premium at https://mui.com/r/x-get-license?scope=premium.", "Of if you didn't intend to use Premium features, you can replace the import of `@mui/x-data-grid-premium` with `@mui/x-data-grid-pro`."]);
}
function showNotAvailableInInitialProPlanError() {
  showError(["MUI X: Component not included in your license.", "", "The component you are trying to use is not included in the Pro Plan you purchased.", "", "Your license is from an old version of the Pro Plan that is only compatible with the `@mui/x-data-grid-pro` and `@mui/x-date-pickers-pro` commercial packages.", "", "To start using another Pro package, please consider reaching to our sales team to upgrade your license or visit https://mui.com/r/x-get-license to get a new license key."]);
}
function showMissingLicenseKeyError({
  plan,
  packageName
}) {
  showError(["MUI X: Missing license key.", "", `The license key is missing. You might not be allowed to use \`${packageName}\` which is part of MUI X ${plan}.`, "", "To solve the issue, you can check the free trial conditions: https://mui.com/r/x-license-trial.", "If you are eligible no actions are required. If you are not eligible to the free trial, you need to purchase a license https://mui.com/r/x-get-license or stop using the software immediately."]);
}
function showExpiredPackageVersionError({
  packageName
}) {
  showError(["MUI X: Expired package version.", "", `You have installed a version of \`${packageName}\` that is outside of the maintenance plan of your license key. By default, commercial licenses provide access to new versions released during the first year after the purchase.`, "", "To solve the issue, you can renew your license https://mui.com/r/x-get-license or install an older version of the npm package that is compatible with your license key."]);
}
function showExpiredAnnualGraceLicenseKeyError({
  plan,
  licenseKey,
  expiryTimestamp
}) {
  showError(["MUI X: Expired license key.", "", `Your annual license key to use MUI X ${plan} in non-production environments has expired. If you are seeing this development console message, you might be close to breach the license terms by making direct or indirect changes to the frontend of an app that render a MUI X ${plan} component (more details in https://mui.com/r/x-license-annual).`, "", "To solve the problem you can either:", "", "- Renew your license https://mui.com/r/x-get-license and use the new key", `- Stop making changes to code depending directly or indirectly on MUI X ${plan}'s APIs`, "", "Note that your license is perpetual in production environments with any version released before your license term ends.", "", `- License key expiry timestamp: ${new Date(expiryTimestamp)}`, `- Installed license key: ${licenseKey}`, ""]);
}
function showExpiredAnnualLicenseKeyError({
  plan,
  licenseKey,
  expiryTimestamp
}) {
  throw new Error(["MUI X: Expired license key.", "", `Your annual license key to use MUI X ${plan} in non-production environments has expired. If you are seeing this development console message, you might be close to breach the license terms by making direct or indirect changes to the frontend of an app that render a MUI X ${plan} component (more details in https://mui.com/r/x-license-annual).`, "", "To solve the problem you can either:", "", "- Renew your license https://mui.com/r/x-get-license and use the new key", `- Stop making changes to code depending directly or indirectly on MUI X ${plan}'s APIs`, "", "Note that your license is perpetual in production environments with any version released before your license term ends.", "", `- License key expiry timestamp: ${new Date(expiryTimestamp)}`, `- Installed license key: ${licenseKey}`, ""].join("\n"));
}

// node_modules/@mui/x-license/utils/licenseInfo.js
ponyfillGlobal_default.__MUI_LICENSE_INFO__ = ponyfillGlobal_default.__MUI_LICENSE_INFO__ || {
  key: void 0
};
var LicenseInfo = class _LicenseInfo {
  static getLicenseInfo() {
    return ponyfillGlobal_default.__MUI_LICENSE_INFO__;
  }
  static getLicenseKey() {
    return _LicenseInfo.getLicenseInfo().key;
  }
  static setLicenseKey(key) {
    const licenseInfo = _LicenseInfo.getLicenseInfo();
    licenseInfo.key = key;
  }
};

// node_modules/@mui/x-license/utils/licenseStatus.js
var LICENSE_STATUS = function(LICENSE_STATUS2) {
  LICENSE_STATUS2["NotFound"] = "NotFound";
  LICENSE_STATUS2["Invalid"] = "Invalid";
  LICENSE_STATUS2["ExpiredAnnual"] = "ExpiredAnnual";
  LICENSE_STATUS2["ExpiredAnnualGrace"] = "ExpiredAnnualGrace";
  LICENSE_STATUS2["ExpiredVersion"] = "ExpiredVersion";
  LICENSE_STATUS2["Valid"] = "Valid";
  LICENSE_STATUS2["OutOfScope"] = "OutOfScope";
  LICENSE_STATUS2["NotAvailableInInitialProPlan"] = "NotAvailableInInitialProPlan";
  return LICENSE_STATUS2;
}({});

// node_modules/@mui/x-license/verifyLicense/verifyLicense.js
function isPlanScopeSufficient(packageName, planScope) {
  let acceptedScopes;
  if (packageName.includes("-pro")) {
    acceptedScopes = ["pro", "premium"];
  } else if (packageName.includes("-premium")) {
    acceptedScopes = ["premium"];
  } else {
    acceptedScopes = [];
  }
  return acceptedScopes.includes(planScope);
}
var expiryReg = /^.*EXPIRY=([0-9]+),.*$/;
var PRO_PACKAGES_AVAILABLE_IN_INITIAL_PRO_PLAN = ["x-data-grid-pro", "x-date-pickers-pro"];
var decodeLicenseVersion1 = (license) => {
  let expiryTimestamp;
  try {
    expiryTimestamp = parseInt(license.match(expiryReg)[1], 10);
    if (!expiryTimestamp || Number.isNaN(expiryTimestamp)) {
      expiryTimestamp = null;
    }
  } catch (err) {
    expiryTimestamp = null;
  }
  return {
    planScope: "pro",
    licenseModel: "perpetual",
    expiryTimestamp,
    planVersion: "initial"
  };
};
var decodeLicenseVersion2 = (license) => {
  const licenseInfo = {
    planScope: null,
    licenseModel: null,
    expiryTimestamp: null,
    planVersion: "initial"
  };
  license.split(",").map((token) => token.split("=")).filter((el) => el.length === 2).forEach(([key, value]) => {
    if (key === "S") {
      licenseInfo.planScope = value;
    }
    if (key === "LM") {
      licenseInfo.licenseModel = value;
    }
    if (key === "E") {
      const expiryTimestamp = parseInt(value, 10);
      if (expiryTimestamp && !Number.isNaN(expiryTimestamp)) {
        licenseInfo.expiryTimestamp = expiryTimestamp;
      }
    }
    if (key === "PV") {
      licenseInfo.planVersion = value;
    }
  });
  return licenseInfo;
};
var decodeLicense = (encodedLicense) => {
  const license = base64Decode(encodedLicense);
  if (license.includes("KEYVERSION=1")) {
    return decodeLicenseVersion1(license);
  }
  if (license.includes("KV=2")) {
    return decodeLicenseVersion2(license);
  }
  return null;
};
function verifyLicense({
  releaseInfo: releaseInfo4,
  licenseKey,
  packageName
}) {
  if (!releaseInfo4) {
    throw new Error("MUI X: The release information is missing. Not able to validate license.");
  }
  if (!licenseKey) {
    return {
      status: LICENSE_STATUS.NotFound
    };
  }
  const hash = licenseKey.substr(0, 32);
  const encoded = licenseKey.substr(32);
  if (hash !== md5(encoded)) {
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  const license = decodeLicense(encoded);
  if (license == null) {
    console.error("MUI X: Error checking license. Key version not found!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (license.licenseModel == null || !LICENSE_MODELS.includes(license.licenseModel)) {
    console.error("MUI X: Error checking license. Licensing model not found or invalid!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (license.expiryTimestamp == null) {
    console.error("MUI X: Error checking license. Expiry timestamp not found or invalid!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (license.licenseModel === "perpetual" || false) {
    const pkgTimestamp = parseInt(base64Decode(releaseInfo4), 10);
    if (Number.isNaN(pkgTimestamp)) {
      throw new Error("MUI X: The release information is invalid. Not able to validate license.");
    }
    if (license.expiryTimestamp < pkgTimestamp) {
      return {
        status: LICENSE_STATUS.ExpiredVersion
      };
    }
  } else if (license.licenseModel === "subscription" || license.licenseModel === "annual") {
    if ((/* @__PURE__ */ new Date()).getTime() > license.expiryTimestamp) {
      if (
        // 30 days grace
        (/* @__PURE__ */ new Date()).getTime() < license.expiryTimestamp + 1e3 * 3600 * 24 * 30 || false
      ) {
        return {
          status: LICENSE_STATUS.ExpiredAnnualGrace,
          meta: {
            expiryTimestamp: license.expiryTimestamp,
            licenseKey
          }
        };
      }
      return {
        status: LICENSE_STATUS.ExpiredAnnual,
        meta: {
          expiryTimestamp: license.expiryTimestamp,
          licenseKey
        }
      };
    }
  }
  if (license.planScope == null || !PLAN_SCOPES.includes(license.planScope)) {
    console.error("MUI X: Error checking license. planScope not found or invalid!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (!isPlanScopeSufficient(packageName, license.planScope)) {
    return {
      status: LICENSE_STATUS.OutOfScope
    };
  }
  if (license.planVersion === "initial" && license.planScope === "pro" && !PRO_PACKAGES_AVAILABLE_IN_INITIAL_PRO_PLAN.includes(packageName)) {
    return {
      status: LICENSE_STATUS.NotAvailableInInitialProPlan
    };
  }
  return {
    status: LICENSE_STATUS.Valid
  };
}

// node_modules/@mui/x-license/useLicenseVerifier/useLicenseVerifier.js
init_extends();
var React4 = __toESM(require_react());

// node_modules/@mui/x-license/Unstable_LicenseInfoProvider/MuiLicenseInfoContext.js
var React3 = __toESM(require_react());
var MuiLicenseInfoContext = React3.createContext({
  key: void 0
});
if (true) {
  MuiLicenseInfoContext.displayName = "MuiLicenseInfoContext";
}
var MuiLicenseInfoContext_default = MuiLicenseInfoContext;

// node_modules/@mui/x-license/useLicenseVerifier/useLicenseVerifier.js
var sharedLicenseStatuses = {};
function useLicenseVerifier(packageName, releaseInfo4) {
  const {
    key: contextKey
  } = React4.useContext(MuiLicenseInfoContext_default);
  return React4.useMemo(() => {
    const licenseKey = contextKey ?? LicenseInfo.getLicenseKey();
    if (sharedLicenseStatuses[packageName] && sharedLicenseStatuses[packageName].key === licenseKey) {
      return sharedLicenseStatuses[packageName].licenseVerifier;
    }
    const plan = packageName.includes("premium") ? "Premium" : "Pro";
    const licenseStatus = verifyLicense({
      releaseInfo: releaseInfo4,
      licenseKey,
      packageName
    });
    const fullPackageName = `@mui/${packageName}`;
    if (licenseStatus.status === LICENSE_STATUS.Valid) {
    } else if (licenseStatus.status === LICENSE_STATUS.Invalid) {
      showInvalidLicenseKeyError();
    } else if (licenseStatus.status === LICENSE_STATUS.NotAvailableInInitialProPlan) {
      showNotAvailableInInitialProPlanError();
    } else if (licenseStatus.status === LICENSE_STATUS.OutOfScope) {
      showLicenseKeyPlanMismatchError();
    } else if (licenseStatus.status === LICENSE_STATUS.NotFound) {
      showMissingLicenseKeyError({
        plan,
        packageName: fullPackageName
      });
    } else if (licenseStatus.status === LICENSE_STATUS.ExpiredAnnualGrace) {
      showExpiredAnnualGraceLicenseKeyError(_extends({
        plan
      }, licenseStatus.meta));
    } else if (licenseStatus.status === LICENSE_STATUS.ExpiredAnnual) {
      showExpiredAnnualLicenseKeyError(_extends({
        plan
      }, licenseStatus.meta));
    } else if (licenseStatus.status === LICENSE_STATUS.ExpiredVersion) {
      showExpiredPackageVersionError({
        packageName: fullPackageName
      });
    } else if (true) {
      throw new Error("missing status handler");
    }
    sharedLicenseStatuses[packageName] = {
      key: licenseKey,
      licenseVerifier: licenseStatus
    };
    return licenseStatus;
  }, [packageName, releaseInfo4, contextKey]);
}

// node_modules/@mui/x-license/Watermark/Watermark.js
var React5 = __toESM(require_react());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
function getLicenseErrorMessage(licenseStatus) {
  switch (licenseStatus) {
    case LICENSE_STATUS.ExpiredAnnualGrace:
    case LICENSE_STATUS.ExpiredAnnual:
      return "MUI X Expired license key";
    case LICENSE_STATUS.ExpiredVersion:
      return "MUI X Expired package version";
    case LICENSE_STATUS.Invalid:
      return "MUI X Invalid license key";
    case LICENSE_STATUS.OutOfScope:
      return "MUI X License key plan mismatch";
    case LICENSE_STATUS.NotAvailableInInitialProPlan:
      return "MUI X Product not covered by plan";
    case LICENSE_STATUS.NotFound:
      return "MUI X Missing license key";
    default:
      throw new Error("Unhandled MUI X license status.");
  }
}
function Watermark(props) {
  const {
    packageName,
    releaseInfo: releaseInfo4
  } = props;
  const licenseStatus = useLicenseVerifier(packageName, releaseInfo4);
  if (licenseStatus.status === LICENSE_STATUS.Valid) {
    return null;
  }
  return (0, import_jsx_runtime2.jsx)("div", {
    style: {
      position: "absolute",
      pointerEvents: "none",
      color: "#8282829e",
      zIndex: 1e5,
      width: "100%",
      textAlign: "center",
      bottom: "50%",
      right: 0,
      letterSpacing: 5,
      fontSize: 24
    },
    children: getLicenseErrorMessage(licenseStatus.status)
  });
}

// node_modules/@mui/x-license/Unstable_LicenseInfoProvider/LicenseInfoProvider.js
var React6 = __toESM(require_react());
var import_jsx_runtime3 = __toESM(require_jsx_runtime());

// node_modules/@mui/x-date-pickers-pro/internals/utils/releaseInfo.js
var getReleaseInfo = () => {
  const releaseInfo4 = "MTcyOTc5NjQwMDAwMA==";
  if (true) {
    if (releaseInfo4 === "__RELEASE_INFO__") {
      return ponyfillGlobal_default.__MUI_RELEASE_INFO__;
    }
  }
  return releaseInfo4;
};

// node_modules/@mui/x-date-pickers-pro/DateRangeCalendar/dateRangeCalendarClasses.js
var getDateRangeCalendarUtilityClass = (slot) => generateUtilityClass("MuiDateRangeCalendar", slot);
var dateRangeCalendarClasses = generateUtilityClasses("MuiDateRangeCalendar", ["root", "monthContainer", "dayDragging"]);

// node_modules/@mui/x-date-pickers-pro/internals/utils/date-range-manager.js
function calculateRangeChange({
  utils,
  range,
  newDate: selectedDate,
  rangePosition,
  allowRangeFlip = false,
  shouldMergeDateAndTime = false
}) {
  const [start, end] = range;
  if (shouldMergeDateAndTime && selectedDate) {
    if (start && rangePosition === "start") {
      selectedDate = mergeDateAndTime(utils, selectedDate, start);
    }
    if (end && rangePosition === "end") {
      selectedDate = mergeDateAndTime(utils, selectedDate, end);
    }
  }
  if (rangePosition === "start") {
    const truthyResult2 = allowRangeFlip ? {
      nextSelection: "start",
      newRange: [end, selectedDate]
    } : {
      nextSelection: "end",
      newRange: [selectedDate, null]
    };
    return Boolean(end) && utils.isAfter(selectedDate, end) ? truthyResult2 : {
      nextSelection: "end",
      newRange: [selectedDate, end]
    };
  }
  const truthyResult = allowRangeFlip ? {
    nextSelection: "end",
    newRange: [selectedDate, start]
  } : {
    nextSelection: "end",
    newRange: [selectedDate, null]
  };
  return Boolean(start) && utils.isBeforeDay(selectedDate, start) ? truthyResult : {
    nextSelection: "start",
    newRange: [start, selectedDate]
  };
}
function calculateRangePreview(options) {
  if (options.newDate == null) {
    return [null, null];
  }
  const [start, end] = options.range;
  const {
    newRange
  } = calculateRangeChange(options);
  if (!start || !end) {
    return newRange;
  }
  const [previewStart, previewEnd] = newRange;
  return options.rangePosition === "end" ? [end, previewEnd] : [previewStart, start];
}

// node_modules/@mui/x-date-pickers-pro/DateRangePickerDay/DateRangePickerDay.js
init_extends();
var React7 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());

// node_modules/@mui/x-date-pickers-pro/DateRangePickerDay/dateRangePickerDayClasses.js
function getDateRangePickerDayUtilityClass(slot) {
  return generateUtilityClass("MuiDateRangePickerDay", slot);
}
var dateRangePickerDayClasses = generateUtilityClasses("MuiDateRangePickerDay", ["root", "rangeIntervalDayHighlight", "rangeIntervalDayHighlightStart", "rangeIntervalDayHighlightEnd", "rangeIntervalPreview", "rangeIntervalDayPreview", "rangeIntervalDayPreviewStart", "rangeIntervalDayPreviewEnd", "outsideCurrentMonth", "startOfMonth", "endOfMonth", "firstVisibleCell", "lastVisibleCell", "hiddenDayFiller", "day", "dayOutsideRangeInterval", "dayInsideRangeInterval", "notSelectedDate"]);

// node_modules/@mui/x-date-pickers-pro/DateRangePickerDay/DateRangePickerDay.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var _excluded2 = ["className", "day", "outsideCurrentMonth", "isEndOfHighlighting", "isEndOfPreviewing", "isHighlighting", "isPreviewing", "isStartOfHighlighting", "isStartOfPreviewing", "selected", "isVisuallySelected", "sx", "draggable", "isFirstVisibleCell", "isLastVisibleCell"];
var releaseInfo = getReleaseInfo();
var useUtilityClasses2 = (ownerState) => {
  const {
    isHighlighting,
    outsideCurrentMonth,
    isStartOfHighlighting,
    isStartOfMonth,
    isEndOfHighlighting,
    isEndOfMonth,
    isPreviewing,
    isStartOfPreviewing,
    isEndOfPreviewing,
    isFirstVisibleCell,
    isLastVisibleCell,
    isHiddenDayFiller,
    selected,
    classes
  } = ownerState;
  const slots = {
    root: ["root", isHighlighting && "rangeIntervalDayHighlight", isStartOfHighlighting && "rangeIntervalDayHighlightStart", isEndOfHighlighting && "rangeIntervalDayHighlightEnd", outsideCurrentMonth && "outsideCurrentMonth", isStartOfMonth && "startOfMonth", isEndOfMonth && "endOfMonth", isFirstVisibleCell && "firstVisibleCell", isLastVisibleCell && "lastVisibleCell", isHiddenDayFiller && "hiddenDayFiller"],
    rangeIntervalPreview: ["rangeIntervalPreview", isPreviewing && "rangeIntervalDayPreview", (isStartOfPreviewing || isStartOfMonth) && "rangeIntervalDayPreviewStart", (isEndOfPreviewing || isEndOfMonth) && "rangeIntervalDayPreviewEnd"],
    day: ["day", !selected && "notSelectedDate", !isHighlighting && "dayOutsideRangeInterval", !selected && isHighlighting && "dayInsideRangeInterval"]
  };
  return composeClasses(slots, getDateRangePickerDayUtilityClass, classes);
};
var endBorderStyle = {
  borderTopRightRadius: "50%",
  borderBottomRightRadius: "50%"
};
var startBorderStyle = {
  borderTopLeftRadius: "50%",
  borderBottomLeftRadius: "50%"
};
var DateRangePickerDayRoot = styled_default("div", {
  name: "MuiDateRangePickerDay",
  slot: "Root",
  overridesResolver: (_, styles) => [{
    [`&.${dateRangePickerDayClasses.rangeIntervalDayHighlight}`]: styles.rangeIntervalDayHighlight
  }, {
    [`&.${dateRangePickerDayClasses.rangeIntervalDayHighlightStart}`]: styles.rangeIntervalDayHighlightStart
  }, {
    [`&.${dateRangePickerDayClasses.rangeIntervalDayHighlightEnd}`]: styles.rangeIntervalDayHighlightEnd
  }, {
    [`&.${dateRangePickerDayClasses.firstVisibleCell}`]: styles.firstVisibleCell
  }, {
    [`&.${dateRangePickerDayClasses.lastVisibleCell}`]: styles.lastVisibleCell
  }, {
    [`&.${dateRangePickerDayClasses.startOfMonth}`]: styles.startOfMonth
  }, {
    [`&.${dateRangePickerDayClasses.endOfMonth}`]: styles.endOfMonth
  }, {
    [`&.${dateRangePickerDayClasses.outsideCurrentMonth}`]: styles.outsideCurrentMonth
  }, {
    [`&.${dateRangePickerDayClasses.hiddenDayFiller}`]: styles.hiddenDayFiller
  }, styles.root]
})(({
  theme
}) => ({
  variants: [{
    props: {
      isHiddenDayFiller: false
    },
    style: {
      [`&:first-of-type .${dateRangePickerDayClasses.rangeIntervalDayPreview}`]: _extends({}, startBorderStyle, {
        borderLeftColor: (theme.vars || theme).palette.divider
      }),
      [`&:last-of-type .${dateRangePickerDayClasses.rangeIntervalDayPreview}`]: _extends({}, endBorderStyle, {
        borderRightColor: (theme.vars || theme).palette.divider
      })
    }
  }, {
    props: {
      isHiddenDayFiller: false,
      isHighlighting: true
    },
    style: {
      borderRadius: 0,
      color: (theme.vars || theme).palette.primary.contrastText,
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.focusOpacity),
      "&:first-of-type": startBorderStyle,
      "&:last-of-type": endBorderStyle
    }
  }, {
    props: ({
      ownerState: {
        isHiddenDayFiller,
        isStartOfHighlighting,
        isFirstVisibleCell
      }
    }) => !isHiddenDayFiller && (isStartOfHighlighting || isFirstVisibleCell),
    style: _extends({}, startBorderStyle, {
      paddingLeft: 0
    })
  }, {
    props: ({
      ownerState: {
        isHiddenDayFiller,
        isEndOfHighlighting,
        isLastVisibleCell
      }
    }) => !isHiddenDayFiller && (isEndOfHighlighting || isLastVisibleCell),
    style: _extends({}, endBorderStyle, {
      paddingRight: 0
    })
  }]
}));
var DateRangePickerDayRangeIntervalPreview = styled_default("div", {
  name: "MuiDateRangePickerDay",
  slot: "RangeIntervalPreview",
  overridesResolver: (_, styles) => [{
    [`&.${dateRangePickerDayClasses.rangeIntervalDayPreview}`]: styles.rangeIntervalDayPreview
  }, {
    [`&.${dateRangePickerDayClasses.rangeIntervalDayPreviewStart}`]: styles.rangeIntervalDayPreviewStart
  }, {
    [`&.${dateRangePickerDayClasses.rangeIntervalDayPreviewEnd}`]: styles.rangeIntervalDayPreviewEnd
  }, styles.rangeIntervalPreview]
})(({
  theme
}) => ({
  // replace default day component margin with transparent border to avoid jumping on preview
  border: "2px solid transparent",
  variants: [{
    props: {
      isPreviewing: true,
      isHiddenDayFiller: false
    },
    style: {
      borderRadius: 0,
      border: `2px dashed ${(theme.vars || theme).palette.divider}`,
      borderLeftColor: "transparent",
      borderRightColor: "transparent"
    }
  }, {
    props: ({
      ownerState: {
        isPreviewing,
        isHiddenDayFiller,
        isStartOfPreviewing,
        isFirstVisibleCell
      }
    }) => isPreviewing && !isHiddenDayFiller && (isStartOfPreviewing || isFirstVisibleCell),
    style: _extends({
      borderLeftColor: (theme.vars || theme).palette.divider
    }, startBorderStyle)
  }, {
    props: ({
      ownerState: {
        isPreviewing,
        isHiddenDayFiller,
        isEndOfPreviewing,
        isLastVisibleCell
      }
    }) => isPreviewing && !isHiddenDayFiller && (isEndOfPreviewing || isLastVisibleCell),
    style: _extends({
      borderRightColor: (theme.vars || theme).palette.divider
    }, endBorderStyle)
  }]
}));
var DateRangePickerDayDay = styled_default(PickersDay, {
  name: "MuiDateRangePickerDay",
  slot: "Day",
  overridesResolver: (_, styles) => [{
    [`&.${dateRangePickerDayClasses.dayInsideRangeInterval}`]: styles.dayInsideRangeInterval
  }, {
    [`&.${dateRangePickerDayClasses.dayOutsideRangeInterval}`]: styles.dayOutsideRangeInterval
  }, {
    [`&.${dateRangePickerDayClasses.notSelectedDate}`]: styles.notSelectedDate
  }, styles.day]
})({
  // Required to overlap preview border
  transform: "scale(1.1)",
  "& > *": {
    transform: "scale(0.9)"
  },
  variants: [{
    props: {
      draggable: true
    },
    style: {
      cursor: "grab",
      touchAction: "none"
    }
  }]
});
var DateRangePickerDayRaw = React7.forwardRef(function DateRangePickerDay(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDateRangePickerDay"
  });
  const {
    className,
    day,
    outsideCurrentMonth,
    isHighlighting,
    isPreviewing,
    selected = false,
    isVisuallySelected,
    sx,
    draggable,
    isFirstVisibleCell,
    isLastVisibleCell
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
  useLicenseVerifier("x-date-pickers-pro", releaseInfo);
  const utils = useUtils();
  const isEndOfMonth = utils.isSameDay(day, utils.endOfMonth(day));
  const isStartOfMonth = utils.isSameDay(day, utils.startOfMonth(day));
  const shouldRenderHighlight = isHighlighting && !outsideCurrentMonth;
  const shouldRenderPreview = isPreviewing && !outsideCurrentMonth;
  const ownerState = _extends({}, props, {
    selected,
    isStartOfMonth,
    isEndOfMonth,
    draggable,
    isFirstVisibleCell,
    isLastVisibleCell,
    isHiddenDayFiller: outsideCurrentMonth && !other.showDaysOutsideCurrentMonth
  });
  const classes = useUtilityClasses2(ownerState);
  return (0, import_jsx_runtime4.jsx)(DateRangePickerDayRoot, {
    className: clsx_default(classes.root, className),
    ownerState,
    sx,
    children: (0, import_jsx_runtime4.jsx)(DateRangePickerDayRangeIntervalPreview, {
      className: classes.rangeIntervalPreview,
      ownerState,
      children: (0, import_jsx_runtime4.jsx)(DateRangePickerDayDay, _extends({}, other, {
        ref,
        disableMargin: true,
        day,
        selected: isVisuallySelected,
        outsideCurrentMonth,
        className: classes.day,
        ownerState,
        draggable,
        isFirstVisibleCell,
        isLastVisibleCell
      }))
    })
  });
});
true ? DateRangePickerDayRaw.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * A ref for imperative actions.
   * It currently only supports `focusVisible()` action.
   */
  action: import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.shape({
    current: import_prop_types2.default.shape({
      focusVisible: import_prop_types2.default.func.isRequired
    })
  })]),
  /**
   * If `true`, the ripples are centered.
   * They won't start at the cursor interaction position.
   * @default false
   */
  centerRipple: import_prop_types2.default.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types2.default.object,
  className: import_prop_types2.default.string,
  component: import_prop_types2.default.elementType,
  /**
   * The date to show.
   */
  day: import_prop_types2.default.object.isRequired,
  /**
   * If `true`, renders as disabled.
   * @default false
   */
  disabled: import_prop_types2.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types2.default.bool,
  /**
   * If `true`, days are rendering without margin. Useful for displaying linked range of days.
   * @default false
   */
  disableMargin: import_prop_types2.default.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: import_prop_types2.default.bool,
  /**
   * If `true`, the touch ripple effect is disabled.
   * @default false
   */
  disableTouchRipple: import_prop_types2.default.bool,
  /**
   * If `true`, the day can be dragged to change the current date range.
   * @default false
   */
  draggable: import_prop_types2.default.bool,
  /**
   * If `true`, the base button will have a keyboard focus ripple.
   * @default false
   */
  focusRipple: import_prop_types2.default.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: import_prop_types2.default.string,
  isAnimating: import_prop_types2.default.bool,
  /**
   * Set to `true` if the `day` is the end of a highlighted date range.
   */
  isEndOfHighlighting: import_prop_types2.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is the end of a previewing date range.
   */
  isEndOfPreviewing: import_prop_types2.default.bool.isRequired,
  /**
   * If `true`, day is the first visible cell of the month.
   * Either the first day of the month or the first day of the week depending on `showDaysOutsideCurrentMonth`.
   */
  isFirstVisibleCell: import_prop_types2.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is in a highlighted date range.
   */
  isHighlighting: import_prop_types2.default.bool.isRequired,
  /**
   * If `true`, day is the last visible cell of the month.
   * Either the last day of the month or the last day of the week depending on `showDaysOutsideCurrentMonth`.
   */
  isLastVisibleCell: import_prop_types2.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is in a preview date range.
   */
  isPreviewing: import_prop_types2.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is the start of a highlighted date range.
   */
  isStartOfHighlighting: import_prop_types2.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is the start of a previewing date range.
   */
  isStartOfPreviewing: import_prop_types2.default.bool.isRequired,
  /**
   * Indicates if the day should be visually selected.
   */
  isVisuallySelected: import_prop_types2.default.bool,
  onDaySelect: import_prop_types2.default.func.isRequired,
  /**
   * Callback fired when the component is focused with a keyboard.
   * We trigger a `onFocus` callback too.
   */
  onFocusVisible: import_prop_types2.default.func,
  onMouseEnter: import_prop_types2.default.func,
  /**
   * If `true`, day is outside of month and will be hidden.
   */
  outsideCurrentMonth: import_prop_types2.default.bool.isRequired,
  /**
   * If `true`, renders as selected.
   * @default false
   */
  selected: import_prop_types2.default.bool,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types2.default.bool,
  style: import_prop_types2.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types2.default.oneOfType([import_prop_types2.default.arrayOf(import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.object, import_prop_types2.default.bool])), import_prop_types2.default.func, import_prop_types2.default.object]),
  /**
   * @default 0
   */
  tabIndex: import_prop_types2.default.number,
  /**
   * If `true`, renders as today date.
   * @default false
   */
  today: import_prop_types2.default.bool,
  /**
   * Props applied to the `TouchRipple` element.
   */
  TouchRippleProps: import_prop_types2.default.object,
  /**
   * A ref that points to the `TouchRipple` element.
   */
  touchRippleRef: import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.shape({
    current: import_prop_types2.default.shape({
      pulsate: import_prop_types2.default.func.isRequired,
      start: import_prop_types2.default.func.isRequired,
      stop: import_prop_types2.default.func.isRequired
    })
  })])
} : void 0;
var DateRangePickerDay2 = React7.memo(DateRangePickerDayRaw);

// node_modules/@mui/x-date-pickers-pro/DateRangeCalendar/useDragRange.js
init_extends();
var React8 = __toESM(require_react());
var resolveDateFromTarget = (target, utils, timezone) => {
  const timestampString = target.dataset.timestamp;
  if (!timestampString) {
    return null;
  }
  const timestamp = +timestampString;
  return utils.date(new Date(timestamp).toISOString(), timezone);
};
var isSameAsDraggingDate = (event) => {
  const timestampString = event.target.dataset.timestamp;
  return timestampString === event.dataTransfer.getData("draggingDate");
};
var resolveButtonElement = (element) => {
  if (element) {
    if (element instanceof HTMLButtonElement && !element.disabled) {
      return element;
    }
    if (element.children.length) {
      return resolveButtonElement(element.children[0]);
    }
    return null;
  }
  return element;
};
var resolveElementFromTouch = (event, ignoreTouchTarget) => {
  var _a;
  if (((_a = event.changedTouches) == null ? void 0 : _a.length) === 1 && event.touches.length <= 1) {
    const element = document.elementFromPoint(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
    const buttonElement = resolveButtonElement(element);
    if (ignoreTouchTarget && buttonElement === event.changedTouches[0].target) {
      return null;
    }
    return buttonElement;
  }
  return null;
};
var useDragRangeEvents = ({
  utils,
  setRangeDragDay,
  setIsDragging,
  isDragging,
  onDatePositionChange,
  onDrop,
  disableDragEditing,
  dateRange,
  timezone
}) => {
  const emptyDragImgRef = React8.useRef(null);
  React8.useEffect(() => {
    emptyDragImgRef.current = document.createElement("img");
    emptyDragImgRef.current.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
  }, []);
  const isElementDraggable = (day) => {
    if (day == null) {
      return false;
    }
    const shouldInitDragging = !disableDragEditing && !!dateRange[0] && !!dateRange[1];
    const isSelectedStartDate = isStartOfRange(utils, day, dateRange);
    const isSelectedEndDate = isEndOfRange(utils, day, dateRange);
    return shouldInitDragging && (isSelectedStartDate || isSelectedEndDate);
  };
  const handleDragStart = useEventCallback_default((event) => {
    const newDate = resolveDateFromTarget(event.target, utils, timezone);
    if (!isElementDraggable(newDate)) {
      return;
    }
    event.stopPropagation();
    if (emptyDragImgRef.current) {
      event.dataTransfer.setDragImage(emptyDragImgRef.current, 0, 0);
    }
    setRangeDragDay(newDate);
    event.dataTransfer.effectAllowed = "move";
    setIsDragging(true);
    const buttonDataset = event.target.dataset;
    if (buttonDataset.timestamp) {
      event.dataTransfer.setData("draggingDate", buttonDataset.timestamp);
    }
    if (buttonDataset.position) {
      onDatePositionChange(buttonDataset.position);
    }
  });
  const handleTouchStart = useEventCallback_default((event) => {
    const target = resolveElementFromTouch(event);
    if (!target) {
      return;
    }
    const newDate = resolveDateFromTarget(target, utils, timezone);
    if (!isElementDraggable(newDate)) {
      return;
    }
    setRangeDragDay(newDate);
  });
  const handleDragEnter = useEventCallback_default((event) => {
    if (!isDragging) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    event.dataTransfer.dropEffect = "move";
    setRangeDragDay(resolveDateFromTarget(event.target, utils, timezone));
  });
  const handleTouchMove = useEventCallback_default((event) => {
    const target = resolveElementFromTouch(event);
    if (!target) {
      return;
    }
    const newDate = resolveDateFromTarget(target, utils, timezone);
    if (newDate) {
      setRangeDragDay(newDate);
    }
    const targetsAreIdentical = target === event.changedTouches[0].target;
    if (!targetsAreIdentical || !isElementDraggable(newDate)) {
      return;
    }
    setIsDragging(true);
    const button = event.target;
    const buttonDataset = button.dataset;
    if (buttonDataset.position) {
      onDatePositionChange(buttonDataset.position);
    }
  });
  const handleDragLeave = useEventCallback_default((event) => {
    if (!isDragging) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
  });
  const handleDragOver = useEventCallback_default((event) => {
    if (!isDragging) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    event.dataTransfer.dropEffect = "move";
  });
  const handleTouchEnd = useEventCallback_default((event) => {
    if (!isDragging) {
      return;
    }
    setRangeDragDay(null);
    setIsDragging(false);
    const target = resolveElementFromTouch(event, true);
    if (!target) {
      return;
    }
    target.focus();
    const newDate = resolveDateFromTarget(target, utils, timezone);
    if (newDate) {
      onDrop(newDate);
    }
  });
  const handleDragEnd = useEventCallback_default((event) => {
    if (!isDragging) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    setIsDragging(false);
    setRangeDragDay(null);
  });
  const handleDrop = useEventCallback_default((event) => {
    if (!isDragging) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    setIsDragging(false);
    setRangeDragDay(null);
    event.currentTarget.focus();
    if (isSameAsDraggingDate(event)) {
      return;
    }
    const newDate = resolveDateFromTarget(event.target, utils, timezone);
    if (newDate) {
      onDrop(newDate);
    }
  });
  return {
    onDragStart: handleDragStart,
    onDragEnter: handleDragEnter,
    onDragLeave: handleDragLeave,
    onDragOver: handleDragOver,
    onDragEnd: handleDragEnd,
    onDrop: handleDrop,
    onTouchStart: handleTouchStart,
    onTouchMove: handleTouchMove,
    onTouchEnd: handleTouchEnd
  };
};
var useDragRange = ({
  disableDragEditing,
  utils,
  onDatePositionChange,
  onDrop,
  dateRange,
  timezone
}) => {
  const [isDragging, setIsDragging] = React8.useState(false);
  const [rangeDragDay, setRangeDragDay] = React8.useState(null);
  const handleRangeDragDayChange = useEventCallback_default((val) => {
    if (!utils.isEqual(val, rangeDragDay)) {
      setRangeDragDay(val);
    }
  });
  const draggingDatePosition = React8.useMemo(() => {
    const [start, end] = dateRange;
    if (rangeDragDay) {
      if (start && utils.isBefore(rangeDragDay, start)) {
        return "start";
      }
      if (end && utils.isAfter(rangeDragDay, end)) {
        return "end";
      }
    }
    return null;
  }, [dateRange, rangeDragDay, utils]);
  const dragRangeEvents = useDragRangeEvents({
    utils,
    onDatePositionChange,
    onDrop,
    setIsDragging,
    isDragging,
    setRangeDragDay: handleRangeDragDayChange,
    disableDragEditing,
    dateRange,
    timezone
  });
  return React8.useMemo(() => _extends({
    isDragging,
    rangeDragDay,
    draggingDatePosition
  }, !disableDragEditing ? dragRangeEvents : {}), [isDragging, rangeDragDay, draggingDatePosition, disableDragEditing, dragRangeEvents]);
};

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useRangePosition.js
var useRangePosition = (props, singleInputFieldRef) => {
  const [rangePosition, setRangePosition] = useControlled({
    name: "useRangePosition",
    state: "rangePosition",
    controlled: props.rangePosition,
    default: props.defaultRangePosition ?? "start"
  });
  const syncRangePositionWithSingleInputField = (newRangePosition) => {
    if ((singleInputFieldRef == null ? void 0 : singleInputFieldRef.current) == null) {
      return;
    }
    const sections = singleInputFieldRef.current.getSections();
    const targetActiveSectionIndex = newRangePosition === "start" ? 0 : sections.length / 2;
    singleInputFieldRef.current.setSelectedSections(targetActiveSectionIndex);
  };
  const handleRangePositionChange = useEventCallback_default((newRangePosition) => {
    var _a;
    setRangePosition(newRangePosition);
    (_a = props.onRangePositionChange) == null ? void 0 : _a.call(props, newRangePosition);
    syncRangePositionWithSingleInputField(newRangePosition);
  });
  return {
    rangePosition,
    onRangePositionChange: handleRangePositionChange
  };
};

// node_modules/@mui/x-date-pickers-pro/internals/constants/dimensions.js
var DAY_RANGE_SIZE = 40;
var RANGE_VIEW_HEIGHT = VIEW_HEIGHT + 6 * 2 * DAY_MARGIN;

// node_modules/@mui/x-date-pickers-pro/PickersRangeCalendarHeader/PickersRangeCalendarHeader.js
init_extends();
var React11 = __toESM(require_react());
var import_prop_types4 = __toESM(require_prop_types());

// node_modules/@mui/x-date-pickers-pro/node_modules/@mui/x-date-pickers/PickersCalendarHeader/pickersCalendarHeaderClasses.js
var getPickersCalendarHeaderUtilityClass = (slot) => generateUtilityClass("MuiPickersCalendarHeader", slot);
var pickersCalendarHeaderClasses = generateUtilityClasses("MuiPickersCalendarHeader", ["root", "labelContainer", "label", "switchViewButton", "switchViewIcon"]);

// node_modules/@mui/x-date-pickers-pro/node_modules/@mui/x-date-pickers/PickersCalendarHeader/PickersCalendarHeader.js
init_extends();
var React10 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());

// node_modules/@mui/x-date-pickers-pro/node_modules/@mui/x-date-pickers/DateCalendar/PickersFadeTransitionGroup.js
var React9 = __toESM(require_react());

// node_modules/@mui/x-date-pickers-pro/node_modules/@mui/x-date-pickers/DateCalendar/pickersFadeTransitionGroupClasses.js
var getPickersFadeTransitionGroupUtilityClass = (slot) => generateUtilityClass("MuiPickersFadeTransitionGroup", slot);
var pickersFadeTransitionGroupClasses = generateUtilityClasses("MuiPickersFadeTransitionGroup", ["root"]);

// node_modules/@mui/x-date-pickers-pro/node_modules/@mui/x-date-pickers/DateCalendar/PickersFadeTransitionGroup.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var useUtilityClasses3 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getPickersFadeTransitionGroupUtilityClass, classes);
};
var PickersFadeTransitionGroupRoot = styled_default(TransitionGroup_default, {
  name: "MuiPickersFadeTransitionGroup",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})({
  display: "block",
  position: "relative"
});
function PickersFadeTransitionGroup(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersFadeTransitionGroup"
  });
  const {
    children,
    className,
    reduceAnimations,
    transKey
  } = props;
  const classes = useUtilityClasses3(props);
  const theme = useTheme();
  if (reduceAnimations) {
    return children;
  }
  return (0, import_jsx_runtime5.jsx)(PickersFadeTransitionGroupRoot, {
    className: clsx_default(classes.root, className),
    children: (0, import_jsx_runtime5.jsx)(Fade_default, {
      appear: false,
      mountOnEnter: true,
      unmountOnExit: true,
      timeout: {
        appear: theme.transitions.duration.enteringScreen,
        enter: theme.transitions.duration.enteringScreen,
        exit: 0
      },
      children
    }, transKey)
  });
}

// node_modules/@mui/x-date-pickers-pro/node_modules/@mui/x-date-pickers/PickersCalendarHeader/PickersCalendarHeader.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var _excluded3 = ["slots", "slotProps", "currentMonth", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onMonthChange", "onViewChange", "view", "reduceAnimations", "views", "labelId", "className", "timezone", "format"];
var _excluded22 = ["ownerState"];
var useUtilityClasses4 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    labelContainer: ["labelContainer"],
    label: ["label"],
    switchViewButton: ["switchViewButton"],
    switchViewIcon: ["switchViewIcon"]
  };
  return composeClasses(slots, getPickersCalendarHeaderUtilityClass, classes);
};
var PickersCalendarHeaderRoot = styled_default("div", {
  name: "MuiPickersCalendarHeader",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})({
  display: "flex",
  alignItems: "center",
  marginTop: 12,
  marginBottom: 4,
  paddingLeft: 24,
  paddingRight: 12,
  // prevent jumping in safari
  maxHeight: 40,
  minHeight: 40
});
var PickersCalendarHeaderLabelContainer = styled_default("div", {
  name: "MuiPickersCalendarHeader",
  slot: "LabelContainer",
  overridesResolver: (_, styles) => styles.labelContainer
})(({
  theme
}) => _extends({
  display: "flex",
  overflow: "hidden",
  alignItems: "center",
  cursor: "pointer",
  marginRight: "auto"
}, theme.typography.body1, {
  fontWeight: theme.typography.fontWeightMedium
}));
var PickersCalendarHeaderLabel = styled_default("div", {
  name: "MuiPickersCalendarHeader",
  slot: "Label",
  overridesResolver: (_, styles) => styles.label
})({
  marginRight: 6
});
var PickersCalendarHeaderSwitchViewButton = styled_default(IconButton_default, {
  name: "MuiPickersCalendarHeader",
  slot: "SwitchViewButton",
  overridesResolver: (_, styles) => styles.switchViewButton
})({
  marginRight: "auto",
  variants: [{
    props: {
      view: "year"
    },
    style: {
      [`.${pickersCalendarHeaderClasses.switchViewIcon}`]: {
        transform: "rotate(180deg)"
      }
    }
  }]
});
var PickersCalendarHeaderSwitchViewIcon = styled_default(ArrowDropDownIcon, {
  name: "MuiPickersCalendarHeader",
  slot: "SwitchViewIcon",
  overridesResolver: (_, styles) => styles.switchViewIcon
})(({
  theme
}) => ({
  willChange: "transform",
  transition: theme.transitions.create("transform"),
  transform: "rotate(0deg)"
}));
var PickersCalendarHeader = React10.forwardRef(function PickersCalendarHeader2(inProps, ref) {
  const translations = usePickersTranslations();
  const utils = useUtils();
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersCalendarHeader"
  });
  const {
    slots,
    slotProps,
    currentMonth: month,
    disabled,
    disableFuture,
    disablePast,
    maxDate,
    minDate,
    onMonthChange,
    onViewChange,
    view,
    reduceAnimations,
    views,
    labelId,
    className,
    timezone,
    format = `${utils.formats.month} ${utils.formats.year}`
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded3);
  const ownerState = props;
  const classes = useUtilityClasses4(props);
  const SwitchViewButton = (slots == null ? void 0 : slots.switchViewButton) ?? PickersCalendarHeaderSwitchViewButton;
  const switchViewButtonProps = useSlotProps_default({
    elementType: SwitchViewButton,
    externalSlotProps: slotProps == null ? void 0 : slotProps.switchViewButton,
    additionalProps: {
      size: "small",
      "aria-label": translations.calendarViewSwitchingButtonAriaLabel(view)
    },
    ownerState,
    className: classes.switchViewButton
  });
  const SwitchViewIcon = (slots == null ? void 0 : slots.switchViewIcon) ?? PickersCalendarHeaderSwitchViewIcon;
  const _useSlotProps = useSlotProps_default({
    elementType: SwitchViewIcon,
    externalSlotProps: slotProps == null ? void 0 : slotProps.switchViewIcon,
    ownerState,
    className: classes.switchViewIcon
  }), switchViewIconProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded22);
  const selectNextMonth = () => onMonthChange(utils.addMonths(month, 1), "left");
  const selectPreviousMonth = () => onMonthChange(utils.addMonths(month, -1), "right");
  const isNextMonthDisabled = useNextMonthDisabled(month, {
    disableFuture,
    maxDate,
    timezone
  });
  const isPreviousMonthDisabled = usePreviousMonthDisabled(month, {
    disablePast,
    minDate,
    timezone
  });
  const handleToggleView = () => {
    if (views.length === 1 || !onViewChange || disabled) {
      return;
    }
    if (views.length === 2) {
      onViewChange(views.find((el) => el !== view) || views[0]);
    } else {
      const nextIndexToOpen = views.indexOf(view) !== 0 ? 0 : 1;
      onViewChange(views[nextIndexToOpen]);
    }
  };
  if (views.length === 1 && views[0] === "year") {
    return null;
  }
  const label = utils.formatByString(month, format);
  return (0, import_jsx_runtime6.jsxs)(PickersCalendarHeaderRoot, _extends({}, other, {
    ownerState,
    className: clsx_default(classes.root, className),
    ref,
    children: [(0, import_jsx_runtime6.jsxs)(PickersCalendarHeaderLabelContainer, {
      role: "presentation",
      onClick: handleToggleView,
      ownerState,
      "aria-live": "polite",
      className: classes.labelContainer,
      children: [(0, import_jsx_runtime6.jsx)(PickersFadeTransitionGroup, {
        reduceAnimations,
        transKey: label,
        children: (0, import_jsx_runtime6.jsx)(PickersCalendarHeaderLabel, {
          id: labelId,
          ownerState,
          className: classes.label,
          children: label
        })
      }), views.length > 1 && !disabled && (0, import_jsx_runtime6.jsx)(SwitchViewButton, _extends({}, switchViewButtonProps, {
        children: (0, import_jsx_runtime6.jsx)(SwitchViewIcon, _extends({}, switchViewIconProps))
      }))]
    }), (0, import_jsx_runtime6.jsx)(Fade_default, {
      in: view === "day",
      children: (0, import_jsx_runtime6.jsx)(PickersArrowSwitcher, {
        slots,
        slotProps,
        onGoToPrevious: selectPreviousMonth,
        isPreviousDisabled: isPreviousMonthDisabled,
        previousLabel: translations.previousMonth,
        onGoToNext: selectNextMonth,
        isNextDisabled: isNextMonthDisabled,
        nextLabel: translations.nextMonth
      })
    })]
  }));
});
true ? PickersCalendarHeader.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types3.default.object,
  className: import_prop_types3.default.string,
  currentMonth: import_prop_types3.default.object.isRequired,
  disabled: import_prop_types3.default.bool,
  disableFuture: import_prop_types3.default.bool,
  disablePast: import_prop_types3.default.bool,
  /**
   * Format used to display the date.
   * @default `${adapter.formats.month} ${adapter.formats.year}`
   */
  format: import_prop_types3.default.string,
  /**
   * Id of the calendar text element.
   * It is used to establish an `aria-labelledby` relationship with the calendar `grid` element.
   */
  labelId: import_prop_types3.default.string,
  maxDate: import_prop_types3.default.object.isRequired,
  minDate: import_prop_types3.default.object.isRequired,
  onMonthChange: import_prop_types3.default.func.isRequired,
  onViewChange: import_prop_types3.default.func,
  reduceAnimations: import_prop_types3.default.bool.isRequired,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types3.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types3.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types3.default.oneOfType([import_prop_types3.default.arrayOf(import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object, import_prop_types3.default.bool])), import_prop_types3.default.func, import_prop_types3.default.object]),
  timezone: import_prop_types3.default.string.isRequired,
  view: import_prop_types3.default.oneOf(["day", "month", "year"]).isRequired,
  views: import_prop_types3.default.arrayOf(import_prop_types3.default.oneOf(["day", "month", "year"]).isRequired).isRequired
} : void 0;

// node_modules/@mui/x-date-pickers-pro/PickersRangeCalendarHeader/PickersRangeCalendarHeader.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var _excluded4 = ["calendars", "month", "monthIndex", "labelId"];
var _excluded23 = ["format", "slots", "slotProps", "currentMonth", "onMonthChange", "disableFuture", "disablePast", "minDate", "maxDate", "timezone", "reduceAnimations", "views", "view"];
var PickersRangeCalendarHeaderContentMultipleCalendars = styled_default(PickersArrowSwitcher)({
  padding: "12px 16px 4px 16px",
  display: "flex",
  alignItems: "center",
  justifyContent: "space-between"
});
var PickersRangeCalendarHeader = React11.forwardRef(function PickersRangeCalendarHeader2(props, ref) {
  const utils = useUtils();
  const translations = usePickersTranslations();
  const {
    calendars,
    month,
    monthIndex,
    labelId
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded4);
  const {
    format,
    slots,
    slotProps,
    currentMonth,
    onMonthChange,
    disableFuture,
    disablePast,
    minDate,
    maxDate,
    timezone
    // omit props that are not used in the PickersArrowSwitcher
  } = other, otherRangeProps = _objectWithoutPropertiesLoose(other, _excluded23);
  const isNextMonthDisabled = useNextMonthDisabled(currentMonth, {
    disableFuture,
    maxDate,
    timezone
  });
  const isPreviousMonthDisabled = usePreviousMonthDisabled(currentMonth, {
    disablePast,
    minDate,
    timezone
  });
  if (calendars === 1) {
    return (0, import_jsx_runtime7.jsx)(PickersCalendarHeader, _extends({}, other, {
      labelId,
      ref
    }));
  }
  const selectNextMonth = () => onMonthChange(utils.addMonths(currentMonth, 1), "left");
  const selectPreviousMonth = () => onMonthChange(utils.addMonths(currentMonth, -1), "right");
  return (0, import_jsx_runtime7.jsx)(PickersRangeCalendarHeaderContentMultipleCalendars, _extends({}, otherRangeProps, {
    ref,
    onGoToPrevious: selectPreviousMonth,
    onGoToNext: selectNextMonth,
    isPreviousHidden: monthIndex !== 0,
    isPreviousDisabled: isPreviousMonthDisabled,
    previousLabel: translations.previousMonth,
    isNextHidden: monthIndex !== calendars - 1,
    isNextDisabled: isNextMonthDisabled,
    nextLabel: translations.nextMonth,
    slots,
    slotProps,
    labelId,
    children: utils.formatByString(month, format ?? `${utils.formats.month} ${utils.formats.year}`)
  }));
});
true ? PickersRangeCalendarHeader.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The number of calendars rendered.
   */
  calendars: import_prop_types4.default.oneOf([1, 2, 3]).isRequired,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types4.default.object,
  className: import_prop_types4.default.string,
  currentMonth: import_prop_types4.default.object.isRequired,
  disabled: import_prop_types4.default.bool,
  disableFuture: import_prop_types4.default.bool,
  disablePast: import_prop_types4.default.bool,
  /**
   * Format used to display the date.
   * @default `${adapter.formats.month} ${adapter.formats.year}`
   */
  format: import_prop_types4.default.string,
  /**
   * Id of the calendar text element.
   * It is used to establish an `aria-labelledby` relationship with the calendar `grid` element.
   */
  labelId: import_prop_types4.default.string,
  maxDate: import_prop_types4.default.object.isRequired,
  minDate: import_prop_types4.default.object.isRequired,
  /**
   * Month used for this header.
   */
  month: import_prop_types4.default.object.isRequired,
  /**
   * Index of the month used for this header.
   */
  monthIndex: import_prop_types4.default.number.isRequired,
  onMonthChange: import_prop_types4.default.func.isRequired,
  onViewChange: import_prop_types4.default.func,
  reduceAnimations: import_prop_types4.default.bool.isRequired,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types4.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types4.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types4.default.oneOfType([import_prop_types4.default.arrayOf(import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object, import_prop_types4.default.bool])), import_prop_types4.default.func, import_prop_types4.default.object]),
  timezone: import_prop_types4.default.string.isRequired,
  view: import_prop_types4.default.oneOf(["day", "month", "year"]).isRequired,
  views: import_prop_types4.default.arrayOf(import_prop_types4.default.oneOf(["day", "month", "year"]).isRequired).isRequired
} : void 0;

// node_modules/@mui/x-date-pickers-pro/DateRangeCalendar/DateRangeCalendar.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var _excluded5 = ["value", "defaultValue", "referenceDate", "onChange", "className", "disableFuture", "disablePast", "minDate", "maxDate", "shouldDisableDate", "reduceAnimations", "onMonthChange", "rangePosition", "defaultRangePosition", "onRangePositionChange", "calendars", "currentMonthCalendarPosition", "slots", "slotProps", "loading", "renderLoading", "disableHighlightToday", "readOnly", "disabled", "showDaysOutsideCurrentMonth", "dayOfWeekFormatter", "disableAutoMonthSwitching", "autoFocus", "fixedWeekNumber", "disableDragEditing", "displayWeekNumber", "timezone", "availableRangePositions", "views", "view", "openTo", "onViewChange"];
var _excluded24 = ["isDragging", "rangeDragDay", "draggingDatePosition"];
var releaseInfo2 = getReleaseInfo();
var DateRangeCalendarRoot = styled_default("div", {
  name: "MuiDateRangeCalendar",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})({
  display: "flex",
  flexDirection: "row"
});
var DateRangeCalendarMonthContainer = styled_default("div", {
  name: "MuiDateRangeCalendar",
  slot: "Container",
  overridesResolver: (_, styles) => styles.monthContainer
})(({
  theme
}) => ({
  "&:not(:last-of-type)": {
    borderRight: `1px solid ${(theme.vars || theme).palette.divider}`
  }
}));
var weeksContainerHeight = (DAY_RANGE_SIZE + DAY_MARGIN * 2) * 6;
var InnerDayCalendarForRange = styled_default(DayCalendar)(({
  theme
}) => ({
  minWidth: 312,
  minHeight: weeksContainerHeight,
  [`&.${dateRangeCalendarClasses.dayDragging}`]: {
    [`& .${dateRangePickerDayClasses.day}`]: {
      cursor: "grabbing"
    },
    [`& .${dateRangePickerDayClasses.root}:not(.${dateRangePickerDayClasses.rangeIntervalDayHighlightStart}):not(.${dateRangePickerDayClasses.rangeIntervalDayHighlightEnd}) .${dateRangePickerDayClasses.day}:not(.${dateRangePickerDayClasses.notSelectedDate})`]: {
      // we can't override `PickersDay` background color here, because it's styles take precedence
      opacity: 0.6
    }
  },
  [`&:not(.${dateRangeCalendarClasses.dayDragging}) .${dateRangePickerDayClasses.dayOutsideRangeInterval}`]: {
    "@media (pointer: fine)": {
      "&:hover": {
        border: `1px solid ${(theme.vars || theme).palette.grey[500]}`
      }
    }
  }
}));
var DayCalendarForRange = InnerDayCalendarForRange;
function useDateRangeCalendarDefaultizedProps(props, name) {
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const defaultReduceAnimations = useDefaultReduceAnimations();
  const themeProps = useThemeProps({
    props,
    name
  });
  return _extends({}, themeProps, {
    renderLoading: themeProps.renderLoading ?? (() => (0, import_jsx_runtime8.jsx)("span", {
      children: "..."
    })),
    reduceAnimations: themeProps.reduceAnimations ?? defaultReduceAnimations,
    loading: props.loading ?? false,
    disablePast: props.disablePast ?? false,
    disableFuture: props.disableFuture ?? false,
    openTo: themeProps.openTo ?? "day",
    views: themeProps.views ?? ["day"],
    minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate),
    calendars: themeProps.calendars ?? 2,
    disableDragEditing: themeProps.disableDragEditing ?? false,
    availableRangePositions: themeProps.availableRangePositions ?? ["start", "end"]
  });
}
var useUtilityClasses5 = (ownerState) => {
  const {
    classes,
    isDragging
  } = ownerState;
  const slots = {
    root: ["root"],
    monthContainer: ["monthContainer"],
    dayCalendar: [isDragging && "dayDragging"]
  };
  return composeClasses(slots, getDateRangeCalendarUtilityClass, classes);
};
var DateRangeCalendar = React12.forwardRef(function DateRangeCalendar2(inProps, ref) {
  const props = useDateRangeCalendarDefaultizedProps(inProps, "MuiDateRangeCalendar");
  const shouldHavePreview = useMediaQuery(DEFAULT_DESKTOP_MODE_MEDIA_QUERY, {
    defaultMatches: false
  });
  const {
    value: valueProp,
    defaultValue,
    referenceDate,
    onChange,
    className,
    disableFuture,
    disablePast,
    minDate,
    maxDate,
    shouldDisableDate,
    reduceAnimations,
    onMonthChange,
    rangePosition: rangePositionProp,
    defaultRangePosition: inDefaultRangePosition,
    onRangePositionChange: inOnRangePositionChange,
    calendars,
    currentMonthCalendarPosition = 1,
    slots,
    slotProps,
    loading,
    renderLoading,
    disableHighlightToday,
    readOnly,
    disabled,
    showDaysOutsideCurrentMonth,
    dayOfWeekFormatter,
    disableAutoMonthSwitching,
    autoFocus,
    fixedWeekNumber,
    disableDragEditing,
    displayWeekNumber,
    timezone: timezoneProp,
    availableRangePositions,
    views,
    view: inView,
    openTo,
    onViewChange
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded5);
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "DateRangeCalendar",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: rangeValueManager
  });
  const {
    setValueAndGoToNextView,
    view
  } = useViews({
    view: inView,
    views,
    openTo,
    onChange: handleValueChange,
    onViewChange,
    autoFocus
  });
  const utils = useUtils();
  const now = useNow(timezone);
  const id = useId();
  const {
    rangePosition,
    onRangePositionChange
  } = useRangePosition({
    rangePosition: rangePositionProp,
    defaultRangePosition: inDefaultRangePosition,
    onRangePositionChange: inOnRangePositionChange
  });
  const handleDatePositionChange = useEventCallback_default((position) => {
    if (rangePosition !== position) {
      onRangePositionChange(position);
    }
  });
  const handleSelectedDayChange = useEventCallback_default((newDate, selectionState, allowRangeFlip = false) => {
    const {
      nextSelection,
      newRange
    } = calculateRangeChange({
      newDate,
      utils,
      range: value,
      rangePosition,
      allowRangeFlip,
      shouldMergeDateAndTime: true
    });
    const isNextSectionAvailable = availableRangePositions.includes(nextSelection);
    if (isNextSectionAvailable) {
      onRangePositionChange(nextSelection);
    }
    const isFullRangeSelected = rangePosition === "end" && isRangeValid(utils, newRange);
    setValueAndGoToNextView(newRange, isFullRangeSelected || !isNextSectionAvailable ? "finish" : "partial", view);
  });
  const handleDrop = useEventCallback_default((newDate) => {
    handleSelectedDayChange(newDate, void 0, true);
  });
  const shouldDisableDragEditing = disableDragEditing || disabled || readOnly;
  const valueDayRange = React12.useMemo(() => [value[0] == null || !utils.isValid(value[0]) ? value[0] : utils.startOfDay(value[0]), value[1] == null || !utils.isValid(value[1]) ? value[1] : utils.endOfDay(value[1])], [value, utils]);
  const _useDragRange = useDragRange({
    disableDragEditing: shouldDisableDragEditing,
    onDrop: handleDrop,
    onDatePositionChange: handleDatePositionChange,
    utils,
    dateRange: valueDayRange,
    timezone
  }), {
    isDragging,
    rangeDragDay,
    draggingDatePosition
  } = _useDragRange, dragEventHandlers = _objectWithoutPropertiesLoose(_useDragRange, _excluded24);
  const ownerState = _extends({}, props, {
    isDragging
  });
  const classes = useUtilityClasses5(ownerState);
  const draggingRange = React12.useMemo(() => {
    if (!valueDayRange[0] || !valueDayRange[1] || !rangeDragDay) {
      return [null, null];
    }
    const newRange = calculateRangeChange({
      utils,
      range: valueDayRange,
      newDate: rangeDragDay,
      rangePosition,
      allowRangeFlip: true
    }).newRange;
    return newRange[0] !== null && newRange[1] !== null ? [utils.startOfDay(newRange[0]), utils.endOfDay(newRange[1])] : newRange;
  }, [rangePosition, rangeDragDay, utils, valueDayRange]);
  const wrappedShouldDisableDate = React12.useMemo(() => {
    if (!shouldDisableDate) {
      return void 0;
    }
    return (dayToTest) => shouldDisableDate(dayToTest, draggingDatePosition || rangePosition);
  }, [shouldDisableDate, rangePosition, draggingDatePosition]);
  const {
    calendarState,
    changeFocusedDay,
    changeMonth,
    handleChangeMonth,
    onMonthSwitchingAnimationEnd
  } = useCalendarState({
    value: value[0] || value[1],
    referenceDate,
    disableFuture,
    disablePast,
    disableSwitchToMonthOnDayFocus: true,
    maxDate,
    minDate,
    onMonthChange,
    reduceAnimations,
    shouldDisableDate: wrappedShouldDisableDate,
    timezone
  });
  const CalendarHeader = (slots == null ? void 0 : slots.calendarHeader) ?? PickersRangeCalendarHeader;
  const calendarHeaderProps = useSlotProps_default({
    elementType: CalendarHeader,
    externalSlotProps: slotProps == null ? void 0 : slotProps.calendarHeader,
    additionalProps: {
      calendars,
      views: ["day"],
      view: "day",
      currentMonth: calendarState.currentMonth,
      onMonthChange: (newMonth, direction) => handleChangeMonth({
        newMonth,
        direction
      }),
      minDate,
      maxDate,
      disabled,
      disablePast,
      disableFuture,
      reduceAnimations,
      timezone,
      slots,
      slotProps
    },
    ownerState: props
  });
  const prevValue = React12.useRef(null);
  React12.useEffect(() => {
    var _a, _b;
    const date = rangePosition === "start" ? value[0] : value[1];
    if (!date || !utils.isValid(date)) {
      return;
    }
    const prevDate = rangePosition === "start" ? (_a = prevValue.current) == null ? void 0 : _a[0] : (_b = prevValue.current) == null ? void 0 : _b[1];
    prevValue.current = value;
    if (disableAutoMonthSwitching && prevDate && utils.isEqual(prevDate, date)) {
      return;
    }
    const displayingMonthRange = calendars - currentMonthCalendarPosition;
    const currentMonthNumber = utils.getMonth(calendarState.currentMonth);
    const requestedMonthNumber = utils.getMonth(date);
    if (!utils.isSameYear(calendarState.currentMonth, date) || requestedMonthNumber < currentMonthNumber || requestedMonthNumber > currentMonthNumber + displayingMonthRange) {
      const newMonth = rangePosition === "start" ? date : (
        // If need to focus end, scroll to the state when "end" is displaying in the last calendar
        utils.addMonths(date, -displayingMonthRange)
      );
      changeMonth(newMonth);
    }
  }, [rangePosition, value]);
  const baseDateValidationProps = {
    disablePast,
    disableFuture,
    maxDate,
    minDate
  };
  const commonViewProps = {
    disableHighlightToday,
    readOnly,
    disabled
  };
  const [rangePreviewDay, setRangePreviewDay] = React12.useState(null);
  const CalendarTransitionProps = React12.useMemo(() => ({
    onMouseLeave: () => setRangePreviewDay(null)
  }), []);
  const previewingRange = calculateRangePreview({
    utils,
    range: valueDayRange,
    newDate: rangePreviewDay,
    rangePosition
  });
  const handleDayMouseEnter = useEventCallback_default((event, newPreviewRequest) => {
    if (!isWithinRange(utils, newPreviewRequest, valueDayRange)) {
      setRangePreviewDay(newPreviewRequest);
    } else {
      setRangePreviewDay(null);
    }
  });
  const slotsForDayCalendar = _extends({
    day: DateRangePickerDay2
  }, slots);
  const slotPropsForDayCalendar = _extends({}, slotProps, {
    day: (dayOwnerState) => {
      const {
        day
      } = dayOwnerState;
      const isSelectedStartDate = isStartOfRange(utils, day, valueDayRange);
      const isSelectedEndDate = isEndOfRange(utils, day, valueDayRange);
      const shouldInitDragging = !shouldDisableDragEditing && valueDayRange[0] && valueDayRange[1];
      const isElementDraggable = shouldInitDragging && (isSelectedStartDate || isSelectedEndDate);
      let datePosition;
      if (isSelectedStartDate) {
        datePosition = "start";
      } else if (isSelectedEndDate) {
        datePosition = "end";
      }
      const isStartOfHighlighting = isDragging ? isStartOfRange(utils, day, draggingRange) : isSelectedStartDate;
      const isEndOfHighlighting = isDragging ? isEndOfRange(utils, day, draggingRange) : isSelectedEndDate;
      return _extends({
        isPreviewing: shouldHavePreview ? isWithinRange(utils, day, previewingRange) : false,
        isStartOfPreviewing: shouldHavePreview ? isStartOfRange(utils, day, previewingRange) : false,
        isEndOfPreviewing: shouldHavePreview ? isEndOfRange(utils, day, previewingRange) : false,
        isHighlighting: isWithinRange(utils, day, isDragging ? draggingRange : valueDayRange),
        isStartOfHighlighting,
        isEndOfHighlighting: isDragging ? isEndOfRange(utils, day, draggingRange) : isSelectedEndDate,
        onMouseEnter: shouldHavePreview ? handleDayMouseEnter : void 0,
        // apply selected styling to the dragging start or end day
        isVisuallySelected: dayOwnerState.selected || isDragging && (isStartOfHighlighting || isEndOfHighlighting),
        "data-position": datePosition
      }, dragEventHandlers, {
        draggable: isElementDraggable ? true : void 0
      }, resolveComponentProps_default(slotProps == null ? void 0 : slotProps.day, dayOwnerState) ?? {});
    }
  });
  const calendarMonths = React12.useMemo(() => Array.from({
    length: calendars
  }).map((_, index) => index), [calendars]);
  const visibleMonths = React12.useMemo(() => {
    if (true) {
      if (currentMonthCalendarPosition > calendars || currentMonthCalendarPosition < 1) {
        warnOnce(["MUI X: The `currentMonthCalendarPosition` prop must be an integer between `1` and the amount of calendars rendered.", "For example if you have 2 calendars rendered, it should be equal to either 1 or 2."]);
      }
    }
    const firstMonth = utils.addMonths(calendarState.currentMonth, 1 - currentMonthCalendarPosition);
    return Array.from({
      length: calendars
    }).map((_, index) => utils.addMonths(firstMonth, index));
  }, [utils, calendarState.currentMonth, calendars, currentMonthCalendarPosition]);
  const focusedMonth = React12.useMemo(() => {
    if (!autoFocus) {
      return null;
    }
    if (value[0] != null) {
      return visibleMonths.find((month) => utils.isSameMonth(month, value[0]));
    }
    if (value[1] != null) {
      return visibleMonths.find((month) => utils.isSameMonth(month, value[1]));
    }
    return visibleMonths.find((month) => utils.isSameMonth(month, now)) ?? visibleMonths[0];
  }, [utils, value, visibleMonths, autoFocus, now]);
  return (0, import_jsx_runtime8.jsxs)(DateRangeCalendarRoot, _extends({
    ref,
    className: clsx_default(classes.root, className),
    ownerState
  }, other, {
    children: [(0, import_jsx_runtime8.jsx)(Watermark, {
      packageName: "x-date-pickers-pro",
      releaseInfo: releaseInfo2
    }), calendarMonths.map((monthIndex) => {
      const month = visibleMonths[monthIndex];
      const labelId = `${id}-grid-${monthIndex}-label`;
      return (0, import_jsx_runtime8.jsxs)(DateRangeCalendarMonthContainer, {
        className: classes.monthContainer,
        children: [(0, import_jsx_runtime8.jsx)(CalendarHeader, _extends({}, calendarHeaderProps, {
          month,
          monthIndex,
          labelId
        })), (0, import_jsx_runtime8.jsx)(DayCalendarForRange, _extends({
          className: classes.dayCalendar
        }, calendarState, baseDateValidationProps, commonViewProps, {
          onMonthSwitchingAnimationEnd,
          onFocusedDayChange: changeFocusedDay,
          reduceAnimations,
          selectedDays: value,
          onSelectedDaysChange: handleSelectedDayChange,
          currentMonth: month,
          TransitionProps: CalendarTransitionProps,
          shouldDisableDate: wrappedShouldDisableDate,
          showDaysOutsideCurrentMonth: calendars === 1 && showDaysOutsideCurrentMonth,
          dayOfWeekFormatter,
          loading,
          renderLoading,
          slots: slotsForDayCalendar,
          slotProps: slotPropsForDayCalendar,
          autoFocus: month === focusedMonth,
          fixedWeekNumber,
          displayWeekNumber,
          timezone,
          gridLabelId: labelId
        }))]
      }, monthIndex);
    })]
  }));
});
true ? DateRangeCalendar.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types5.default.bool,
  /**
   * Range positions available for selection.
   * This list is checked against when checking if a next range position can be selected.
   *
   * Used on Date Time Range pickers with current `rangePosition` to force a `finish` selection after just one range position selection.
   * @default ['start', 'end']
   */
  availableRangePositions: import_prop_types5.default.arrayOf(import_prop_types5.default.oneOf(["end", "start"]).isRequired),
  /**
   * The number of calendars to render.
   * @default 2
   */
  calendars: import_prop_types5.default.oneOf([1, 2, 3]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types5.default.object,
  className: import_prop_types5.default.string,
  /**
   * Position the current month is rendered in.
   * @default 1
   */
  currentMonthCalendarPosition: import_prop_types5.default.oneOf([1, 2, 3]),
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: import_prop_types5.default.func,
  /**
   * The initial position in the edited date range.
   * Used when the component is not controlled.
   * @default 'start'
   */
  defaultRangePosition: import_prop_types5.default.oneOf(["end", "start"]),
  /**
   * The default selected value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types5.default.arrayOf(import_prop_types5.default.object),
  /**
   * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
   * @default false
   */
  disableAutoMonthSwitching: import_prop_types5.default.bool,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types5.default.bool,
  /**
   * If `true`, editing dates by dragging is disabled.
   * @default false
   */
  disableDragEditing: import_prop_types5.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types5.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types5.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types5.default.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: import_prop_types5.default.bool,
  /**
   * The day view will show as many weeks as needed after the end of the current month to match this value.
   * Put it to 6 to have a fixed number of weeks in Gregorian calendars
   */
  fixedWeekNumber: import_prop_types5.default.number,
  /**
   * Controlled focused view.
   */
  focusedView: import_prop_types5.default.oneOf(["day"]),
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: import_prop_types5.default.bool,
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: import_prop_types5.default.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: import_prop_types5.default.object,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TView The view type. Will be one of date or time views.
   * @param {TValue} value The new value.
   * @param {PickerSelectionState | undefined} selectionState Indicates if the date selection is complete.
   * @param {TView | undefined} selectedView Indicates the view in which the selection has been made.
   */
  onChange: import_prop_types5.default.func,
  /**
   * Callback fired on focused view change.
   * @template TView
   * @param {TView} view The new view to focus or not.
   * @param {boolean} hasFocus `true` if the view should be focused.
   */
  onFocusedViewChange: import_prop_types5.default.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: import_prop_types5.default.func,
  /**
   * Callback fired when the range position changes.
   * @param {RangePosition} rangePosition The new range position.
   */
  onRangePositionChange: import_prop_types5.default.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: import_prop_types5.default.func,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: import_prop_types5.default.oneOf(["day"]),
  /**
   * The position in the currently edited date range.
   * Used when the component position is controlled.
   */
  rangePosition: import_prop_types5.default.oneOf(["end", "start"]),
  /**
   * Make picker read only.
   * @default false
   */
  readOnly: import_prop_types5.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types5.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date using the validation props, except callbacks such as `shouldDisableDate`.
   */
  referenceDate: import_prop_types5.default.object,
  /**
   * Component rendered on the "day" view when `props.loading` is true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => "..."
   */
  renderLoading: import_prop_types5.default.func,
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types5.default.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types5.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types5.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types5.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types5.default.oneOfType([import_prop_types5.default.arrayOf(import_prop_types5.default.oneOfType([import_prop_types5.default.func, import_prop_types5.default.object, import_prop_types5.default.bool])), import_prop_types5.default.func, import_prop_types5.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types5.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types5.default.arrayOf(import_prop_types5.default.object),
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: import_prop_types5.default.oneOf(["day"]),
  /**
   * Available views.
   */
  views: import_prop_types5.default.arrayOf(import_prop_types5.default.oneOf(["day"]))
} : void 0;

// node_modules/@mui/x-date-pickers-pro/dateRangeViewRenderers/dateRangeViewRenderers.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var renderDateRangeViewCalendar = ({
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minDate,
  maxDate,
  shouldDisableDate,
  reduceAnimations,
  onMonthChange,
  rangePosition,
  defaultRangePosition,
  onRangePositionChange,
  calendars,
  currentMonthCalendarPosition,
  slots,
  slotProps,
  loading,
  renderLoading,
  disableHighlightToday,
  readOnly,
  disabled,
  showDaysOutsideCurrentMonth,
  dayOfWeekFormatter,
  disableAutoMonthSwitching,
  sx,
  autoFocus,
  fixedWeekNumber,
  disableDragEditing,
  displayWeekNumber,
  timezone,
  availableRangePositions,
  views,
  view,
  onViewChange
}) => (0, import_jsx_runtime9.jsx)(DateRangeCalendar, {
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minDate,
  maxDate,
  shouldDisableDate,
  reduceAnimations,
  onMonthChange,
  rangePosition,
  defaultRangePosition,
  onRangePositionChange,
  calendars,
  currentMonthCalendarPosition,
  slots,
  slotProps,
  loading,
  renderLoading,
  disableHighlightToday,
  readOnly,
  disabled,
  showDaysOutsideCurrentMonth,
  dayOfWeekFormatter,
  disableAutoMonthSwitching,
  sx,
  autoFocus,
  fixedWeekNumber,
  disableDragEditing,
  displayWeekNumber,
  timezone,
  availableRangePositions,
  view,
  views,
  onViewChange
});

// node_modules/@mui/x-date-pickers-pro/MultiInputDateRangeField/MultiInputDateRangeField.js
init_extends();
var React16 = __toESM(require_react());
var import_prop_types7 = __toESM(require_prop_types());

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMultiInputRangeField/useMultiInputDateRangeField.js
init_extends();

// node_modules/@mui/x-date-pickers-pro/node_modules/@mui/x-date-pickers/DateField/DateField.js
init_extends();
var React14 = __toESM(require_react());
var import_prop_types6 = __toESM(require_prop_types());

// node_modules/@mui/x-date-pickers-pro/node_modules/@mui/x-date-pickers/DateField/useDateField.js
var useDateField = (inProps) => {
  const props = useDefaultizedDateField(inProps);
  const {
    forwardedProps,
    internalProps
  } = useSplitFieldProps(props, "date");
  return useField({
    forwardedProps,
    internalProps,
    valueManager: singleItemValueManager,
    fieldValueManager: singleItemFieldValueManager,
    validator: validateDate,
    valueType: "date"
  });
};

// node_modules/@mui/x-date-pickers-pro/node_modules/@mui/x-date-pickers/DateField/DateField.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var _excluded6 = ["slots", "slotProps", "InputProps", "inputProps"];
var DateField = React14.forwardRef(function DateField2(inProps, inRef) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiDateField"
  });
  const {
    slots,
    slotProps,
    InputProps,
    inputProps
  } = themeProps, other = _objectWithoutPropertiesLoose(themeProps, _excluded6);
  const ownerState = themeProps;
  const TextField = (slots == null ? void 0 : slots.textField) ?? (inProps.enableAccessibleFieldDOMStructure ? PickersTextField : TextField_default);
  const textFieldProps = useSlotProps_default({
    elementType: TextField,
    externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
    externalForwardedProps: other,
    additionalProps: {
      ref: inRef
    },
    ownerState
  });
  textFieldProps.inputProps = _extends({}, inputProps, textFieldProps.inputProps);
  textFieldProps.InputProps = _extends({}, InputProps, textFieldProps.InputProps);
  const fieldResponse = useDateField(textFieldProps);
  const convertedFieldResponse = convertFieldResponseIntoMuiTextFieldProps(fieldResponse);
  const processedFieldProps = useClearableField(_extends({}, convertedFieldResponse, {
    slots,
    slotProps
  }));
  return (0, import_jsx_runtime10.jsx)(TextField, _extends({}, processedFieldProps));
});
true ? DateField.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the `input` element is focused during the first mount.
   * @default false
   */
  autoFocus: import_prop_types6.default.bool,
  className: import_prop_types6.default.string,
  /**
   * If `true`, a clear button will be shown in the field allowing value clearing.
   * @default false
   */
  clearable: import_prop_types6.default.bool,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'primary'
   */
  color: import_prop_types6.default.oneOf(["error", "info", "primary", "secondary", "success", "warning"]),
  component: import_prop_types6.default.elementType,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: import_prop_types6.default.object,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: import_prop_types6.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types6.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types6.default.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: import_prop_types6.default.bool,
  /**
   * If `true`, the component is displayed in focused state.
   */
  focused: import_prop_types6.default.bool,
  /**
   * Format of the date when rendered in the input(s).
   */
  format: import_prop_types6.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types6.default.oneOf(["dense", "spacious"]),
  /**
   * Props applied to the [`FormHelperText`](/material-ui/api/form-helper-text/) element.
   */
  FormHelperTextProps: import_prop_types6.default.object,
  /**
   * If `true`, the input will take up the full width of its container.
   * @default false
   */
  fullWidth: import_prop_types6.default.bool,
  /**
   * The helper text content.
   */
  helperText: import_prop_types6.default.node,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: import_prop_types6.default.bool,
  /**
   * The id of the `input` element.
   * Use this prop to make `label` and `helperText` accessible for screen readers.
   */
  id: import_prop_types6.default.string,
  /**
   * Props applied to the [`InputLabel`](/material-ui/api/input-label/) element.
   * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
   */
  InputLabelProps: import_prop_types6.default.object,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: import_prop_types6.default.object,
  /**
   * Props applied to the Input element.
   * It will be a [`FilledInput`](/material-ui/api/filled-input/),
   * [`OutlinedInput`](/material-ui/api/outlined-input/) or [`Input`](/material-ui/api/input/)
   * component depending on the `variant` prop value.
   */
  InputProps: import_prop_types6.default.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType_default,
  /**
   * The label content.
   */
  label: import_prop_types6.default.node,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: import_prop_types6.default.oneOf(["dense", "none", "normal"]),
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: import_prop_types6.default.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: import_prop_types6.default.object,
  /**
   * Name attribute of the `input` element.
   */
  name: import_prop_types6.default.string,
  onBlur: import_prop_types6.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types6.default.func,
  /**
   * Callback fired when the clear button is clicked.
   */
  onClear: import_prop_types6.default.func,
  /**
   * Callback fired when the error associated with the current value changes.
   * When a validation error is detected, the `error` parameter contains a non-null value.
   * This can be used to render an appropriate form error.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @param {TError} error The reason why the current value is not valid.
   * @param {TValue} value The value associated with the error.
   */
  onError: import_prop_types6.default.func,
  onFocus: import_prop_types6.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types6.default.func,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   * @default false
   */
  readOnly: import_prop_types6.default.bool,
  /**
   * The date used to generate a part of the new value that is not present in the format when both `value` and `defaultValue` are empty.
   * For example, on time fields it will be used to determine the date to set.
   * @default The closest valid date using the validation props, except callbacks such as `shouldDisableDate`. Value is rounded to the most granular section used.
   */
  referenceDate: import_prop_types6.default.object,
  /**
   * If `true`, the label is displayed as required and the `input` element is required.
   * @default false
   */
  required: import_prop_types6.default.bool,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types6.default.oneOfType([import_prop_types6.default.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types6.default.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: import_prop_types6.default.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: import_prop_types6.default.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: import_prop_types6.default.func,
  /**
   * If `true`, the format will respect the leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `8/16/2018`)
   * If `false`, the format will always add leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `08/16/2018`)
   *
   * Warning n°1: Luxon is not able to respect the leading zeroes when using macro tokens (e.g: "DD"), so `shouldRespectLeadingZeros={true}` might lead to inconsistencies when using `AdapterLuxon`.
   *
   * Warning n°2: When `shouldRespectLeadingZeros={true}`, the field will add an invisible character on the sections containing a single digit to make sure `onChange` is fired.
   * If you need to get the clean value from the input, you can remove this character using `input.value.replace(/\u200e/g, '')`.
   *
   * Warning n°3: When used in strict mode, dayjs and moment require to respect the leading zeros.
   * This mean that when using `shouldRespectLeadingZeros={false}`, if you retrieve the value directly from the input (not listening to `onChange`) and your format contains tokens without leading zeros, the value will not be parsed by your library.
   *
   * @default false
   */
  shouldRespectLeadingZeros: import_prop_types6.default.bool,
  /**
   * The size of the component.
   */
  size: import_prop_types6.default.oneOf(["medium", "small"]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types6.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types6.default.object,
  style: import_prop_types6.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types6.default.oneOfType([import_prop_types6.default.arrayOf(import_prop_types6.default.oneOfType([import_prop_types6.default.func, import_prop_types6.default.object, import_prop_types6.default.bool])), import_prop_types6.default.func, import_prop_types6.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types6.default.string,
  /**
   * The ref object used to imperatively interact with the field.
   */
  unstableFieldRef: import_prop_types6.default.oneOfType([import_prop_types6.default.func, import_prop_types6.default.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types6.default.object,
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: import_prop_types6.default.oneOf(["filled", "outlined", "standard"])
} : void 0;

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMultiInputRangeField/shared.js
var excludeProps = (props, excludedProps) => {
  return Object.keys(props).reduce((acc, key) => {
    if (!excludedProps.includes(key)) {
      acc[key] = props[key];
    }
    return acc;
  }, {});
};

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMultiInputFieldSelectedSections.js
var React15 = __toESM(require_react());
var useMultiInputFieldSelectedSections = (params) => {
  const unstableEndFieldRef = React15.useRef(null);
  const handleUnstableEndFieldRef = useForkRef(params.unstableEndFieldRef, unstableEndFieldRef);
  const [startSelectedSection, setStartSelectedSection] = React15.useState(params.selectedSections ?? null);
  const [endSelectedSection, setEndSelectedSection] = React15.useState(null);
  const getActiveField = () => {
    if (unstableEndFieldRef.current && unstableEndFieldRef.current.isFieldFocused()) {
      return "end";
    }
    return "start";
  };
  const handleStartSelectedSectionChange = useEventCallback_default((newSelectedSections) => {
    var _a;
    setStartSelectedSection(newSelectedSections);
    if (getActiveField() === "start") {
      (_a = params.onSelectedSectionsChange) == null ? void 0 : _a.call(params, newSelectedSections);
    }
  });
  const handleEndSelectedSectionChange = useEventCallback_default((newSelectedSections) => {
    var _a;
    setEndSelectedSection(newSelectedSections);
    if (getActiveField() === "end") {
      (_a = params.onSelectedSectionsChange) == null ? void 0 : _a.call(params, newSelectedSections);
    }
  });
  const activeField = getActiveField();
  return {
    start: {
      unstableFieldRef: params.unstableStartFieldRef,
      selectedSections: activeField === "start" && params.selectedSections !== void 0 ? params.selectedSections : startSelectedSection,
      onSelectedSectionsChange: handleStartSelectedSectionChange
    },
    end: {
      unstableFieldRef: handleUnstableEndFieldRef,
      selectedSections: activeField === "end" && params.selectedSections !== void 0 ? params.selectedSections : endSelectedSection,
      onSelectedSectionsChange: handleEndSelectedSectionChange
    }
  };
};

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMultiInputRangeField/useMultiInputDateRangeField.js
var useMultiInputDateRangeField = ({
  sharedProps: inSharedProps,
  startTextFieldProps,
  unstableStartFieldRef,
  endTextFieldProps,
  unstableEndFieldRef
}) => {
  const sharedProps = useDefaultizedDateField(inSharedProps);
  const {
    value: valueProp,
    defaultValue,
    format,
    formatDensity,
    shouldRespectLeadingZeros,
    onChange,
    disabled,
    readOnly,
    selectedSections,
    onSelectedSectionsChange,
    timezone: timezoneProp,
    enableAccessibleFieldDOMStructure,
    autoFocus
  } = sharedProps;
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "useMultiInputDateRangeField",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: rangeValueManager
  });
  const {
    validationError,
    getValidationErrorForNewValue
  } = useValidation({
    props: sharedProps,
    value,
    timezone,
    validator: validateDateRange,
    onError: sharedProps.onError
  });
  const buildChangeHandler = (index) => {
    return (newDate, rawContext) => {
      const newDateRange = index === 0 ? [newDate, value[1]] : [value[0], newDate];
      const context = _extends({}, rawContext, {
        validationError: getValidationErrorForNewValue(newDateRange)
      });
      handleValueChange(newDateRange, context);
    };
  };
  const handleStartDateChange = useEventCallback_default(buildChangeHandler(0));
  const handleEndDateChange = useEventCallback_default(buildChangeHandler(1));
  const selectedSectionsResponse = useMultiInputFieldSelectedSections({
    selectedSections,
    onSelectedSectionsChange,
    unstableStartFieldRef,
    unstableEndFieldRef
  });
  const startFieldProps = _extends({
    error: !!validationError[0]
  }, startTextFieldProps, selectedSectionsResponse.start, {
    disabled,
    readOnly,
    format,
    formatDensity,
    shouldRespectLeadingZeros,
    timezone,
    value: valueProp === void 0 ? void 0 : valueProp[0],
    defaultValue: defaultValue === void 0 ? void 0 : defaultValue[0],
    onChange: handleStartDateChange,
    enableAccessibleFieldDOMStructure,
    autoFocus
    // Do not add on end field.
  });
  const endFieldProps = _extends({
    error: !!validationError[1]
  }, endTextFieldProps, selectedSectionsResponse.end, {
    format,
    formatDensity,
    shouldRespectLeadingZeros,
    disabled,
    readOnly,
    timezone,
    value: valueProp === void 0 ? void 0 : valueProp[1],
    defaultValue: defaultValue === void 0 ? void 0 : defaultValue[1],
    onChange: handleEndDateChange,
    enableAccessibleFieldDOMStructure
  });
  const startDateResponse = useDateField(startFieldProps);
  const endDateResponse = useDateField(endFieldProps);
  return {
    startDate: excludeProps(startDateResponse, ["clearable", "onClear"]),
    endDate: excludeProps(endDateResponse, ["clearable", "onClear"])
  };
};

// node_modules/@mui/x-date-pickers-pro/MultiInputDateRangeField/MultiInputDateRangeField.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var _excluded7 = ["slots", "slotProps", "unstableStartFieldRef", "unstableEndFieldRef", "className"];
var multiInputDateRangeFieldClasses = generateUtilityClasses("MuiMultiInputDateRangeField", ["root", "separator"]);
var getMultiInputDateRangeFieldUtilityClass = (slot) => generateUtilityClass("MuiMultiInputDateRangeField", slot);
var useUtilityClasses6 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    separator: ["separator"]
  };
  return composeClasses(slots, getMultiInputDateRangeFieldUtilityClass, classes);
};
var MultiInputDateRangeFieldRoot = styled_default(React16.forwardRef((props, ref) => (0, import_jsx_runtime11.jsx)(Stack_default, _extends({
  ref,
  spacing: 2,
  direction: "row",
  alignItems: "center"
}, props))), {
  name: "MuiMultiInputDateRangeField",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({});
var MultiInputDateRangeFieldSeparator = styled_default(Typography_default, {
  name: "MuiMultiInputDateRangeField",
  slot: "Separator",
  overridesResolver: (props, styles) => styles.separator
})({
  lineHeight: "1.4375em"
  // 23px
});
var MultiInputDateRangeField = React16.forwardRef(function MultiInputDateRangeField2(inProps, ref) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiMultiInputDateRangeField"
  });
  const {
    internalProps,
    forwardedProps
  } = useSplitFieldProps(themeProps, "date");
  const {
    slots,
    slotProps,
    unstableStartFieldRef,
    unstableEndFieldRef,
    className
  } = forwardedProps, otherForwardedProps = _objectWithoutPropertiesLoose(forwardedProps, _excluded7);
  const ownerState = themeProps;
  const classes = useUtilityClasses6(ownerState);
  const Root = (slots == null ? void 0 : slots.root) ?? MultiInputDateRangeFieldRoot;
  const rootProps = useSlotProps_default({
    elementType: Root,
    externalSlotProps: slotProps == null ? void 0 : slotProps.root,
    externalForwardedProps: otherForwardedProps,
    additionalProps: {
      ref
    },
    ownerState,
    className: clsx_default(className, classes.root)
  });
  const TextField = (slots == null ? void 0 : slots.textField) ?? (inProps.enableAccessibleFieldDOMStructure ? PickersTextField : TextField_default);
  const startTextFieldProps = useSlotProps_default({
    elementType: TextField,
    externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
    ownerState: _extends({}, ownerState, {
      position: "start"
    })
  });
  const endTextFieldProps = useSlotProps_default({
    elementType: TextField,
    externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
    ownerState: _extends({}, ownerState, {
      position: "end"
    })
  });
  const Separator = (slots == null ? void 0 : slots.separator) ?? MultiInputDateRangeFieldSeparator;
  const separatorProps = useSlotProps_default({
    elementType: Separator,
    externalSlotProps: slotProps == null ? void 0 : slotProps.separator,
    additionalProps: {
      children: ` ${internalProps.dateSeparator ?? "–"} `
    },
    ownerState,
    className: classes.separator
  });
  const fieldResponse = useMultiInputDateRangeField({
    sharedProps: internalProps,
    startTextFieldProps,
    endTextFieldProps,
    unstableStartFieldRef,
    unstableEndFieldRef
  });
  const startDateProps = convertFieldResponseIntoMuiTextFieldProps(fieldResponse.startDate);
  const endDateProps = convertFieldResponseIntoMuiTextFieldProps(fieldResponse.endDate);
  return (0, import_jsx_runtime11.jsxs)(Root, _extends({}, rootProps, {
    children: [(0, import_jsx_runtime11.jsx)(TextField, _extends({
      fullWidth: true
    }, startDateProps)), (0, import_jsx_runtime11.jsx)(Separator, _extends({}, separatorProps)), (0, import_jsx_runtime11.jsx)(TextField, _extends({
      fullWidth: true
    }, endDateProps))]
  }));
});
true ? MultiInputDateRangeField.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: import_prop_types7.default.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types7.default.object,
  className: import_prop_types7.default.string,
  component: import_prop_types7.default.elementType,
  /**
   * String displayed between the start and the end dates.
   * @default "–"
   */
  dateSeparator: import_prop_types7.default.string,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: import_prop_types7.default.arrayOf(import_prop_types7.default.object),
  /**
   * Defines the `flex-direction` style property.
   * It is applied for all screen sizes.
   * @default 'column'
   */
  direction: import_prop_types7.default.oneOfType([import_prop_types7.default.oneOf(["column-reverse", "column", "row-reverse", "row"]), import_prop_types7.default.arrayOf(import_prop_types7.default.oneOf(["column-reverse", "column", "row-reverse", "row"])), import_prop_types7.default.object]),
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: import_prop_types7.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types7.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types7.default.bool,
  /**
   * Add an element between each child.
   */
  divider: import_prop_types7.default.node,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: import_prop_types7.default.bool,
  /**
   * Format of the date when rendered in the input(s).
   */
  format: import_prop_types7.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types7.default.oneOf(["dense", "spacious"]),
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: import_prop_types7.default.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: import_prop_types7.default.object,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types7.default.func,
  /**
   * Callback fired when the error associated with the current value changes.
   * When a validation error is detected, the `error` parameter contains a non-null value.
   * This can be used to render an appropriate form error.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @param {TError} error The reason why the current value is not valid.
   * @param {TValue} value The value associated with the error.
   */
  onError: import_prop_types7.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types7.default.func,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   * @default false
   */
  readOnly: import_prop_types7.default.bool,
  /**
   * The date used to generate a part of the new value that is not present in the format when both `value` and `defaultValue` are empty.
   * For example, on time fields it will be used to determine the date to set.
   * @default The closest valid date using the validation props, except callbacks such as `shouldDisableDate`. Value is rounded to the most granular section used.
   */
  referenceDate: import_prop_types7.default.object,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types7.default.oneOfType([import_prop_types7.default.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types7.default.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types7.default.func,
  /**
   * If `true`, the format will respect the leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `8/16/2018`)
   * If `false`, the format will always add leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `08/16/2018`)
   *
   * Warning n°1: Luxon is not able to respect the leading zeroes when using macro tokens (e.g: "DD"), so `shouldRespectLeadingZeros={true}` might lead to inconsistencies when using `AdapterLuxon`.
   *
   * Warning n°2: When `shouldRespectLeadingZeros={true}`, the field will add an invisible character on the sections containing a single digit to make sure `onChange` is fired.
   * If you need to get the clean value from the input, you can remove this character using `input.value.replace(/\u200e/g, '')`.
   *
   * Warning n°3: When used in strict mode, dayjs and moment require to respect the leading zeros.
   * This mean that when using `shouldRespectLeadingZeros={false}`, if you retrieve the value directly from the input (not listening to `onChange`) and your format contains tokens without leading zeros, the value will not be parsed by your library.
   *
   * @default false
   */
  shouldRespectLeadingZeros: import_prop_types7.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types7.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types7.default.object,
  /**
   * Defines the space between immediate children.
   * @default 0
   */
  spacing: import_prop_types7.default.oneOfType([import_prop_types7.default.arrayOf(import_prop_types7.default.oneOfType([import_prop_types7.default.number, import_prop_types7.default.string])), import_prop_types7.default.number, import_prop_types7.default.object, import_prop_types7.default.string]),
  style: import_prop_types7.default.object,
  /**
   * The system prop, which allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types7.default.oneOfType([import_prop_types7.default.arrayOf(import_prop_types7.default.oneOfType([import_prop_types7.default.func, import_prop_types7.default.object, import_prop_types7.default.bool])), import_prop_types7.default.func, import_prop_types7.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types7.default.string,
  unstableEndFieldRef: import_prop_types7.default.oneOfType([import_prop_types7.default.func, import_prop_types7.default.object]),
  unstableStartFieldRef: import_prop_types7.default.oneOfType([import_prop_types7.default.func, import_prop_types7.default.object]),
  /**
   * If `true`, the CSS flexbox `gap` is used instead of applying `margin` to children.
   *
   * While CSS `gap` removes the [known limitations](https://mui.com/joy-ui/react-stack/#limitations),
   * it is not fully supported in some browsers. We recommend checking https://caniuse.com/?search=flex%20gap before using this flag.
   *
   * To enable this flag globally, follow the [theme's default props](https://mui.com/material-ui/customization/theme-components/#default-props) configuration.
   * @default false
   */
  useFlexGap: import_prop_types7.default.bool,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types7.default.arrayOf(import_prop_types7.default.object)
} : void 0;

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMobileRangePicker/useMobileRangePicker.js
init_extends();
var React18 = __toESM(require_react());

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useEnrichedRangePickerFieldProps.js
init_extends();
var React17 = __toESM(require_react());
var _excluded8 = ["clearable", "onClear"];
var useMultiInputFieldSlotProps = ({
  wrapperVariant,
  open,
  actions,
  readOnly,
  labelId,
  disableOpenPicker,
  onBlur,
  rangePosition,
  onRangePositionChange,
  localeText: inLocaleText,
  pickerSlotProps,
  pickerSlots,
  fieldProps,
  anchorRef,
  currentView,
  initialView,
  onViewChange,
  startFieldRef,
  endFieldRef
}) => {
  const translations = usePickersTranslations();
  const handleStartFieldRef = useForkRef(fieldProps.unstableStartFieldRef, startFieldRef);
  const handleEndFieldRef = useForkRef(fieldProps.unstableEndFieldRef, endFieldRef);
  const previousRangePosition = React17.useRef(rangePosition);
  React17.useEffect(() => {
    var _a;
    if (!open) {
      return;
    }
    const currentFieldRef = rangePosition === "start" ? startFieldRef : endFieldRef;
    (_a = currentFieldRef.current) == null ? void 0 : _a.focusField();
    if (!currentFieldRef.current || !currentView) {
      previousRangePosition.current = rangePosition;
      return;
    }
    currentFieldRef.current.setSelectedSections(
      // use the current view or `0` when the range position has just been swapped
      previousRangePosition.current === rangePosition ? currentView : 0
    );
    previousRangePosition.current = rangePosition;
  }, [rangePosition, open, currentView, startFieldRef, endFieldRef]);
  const openRangeStartSelection = (event) => {
    event.stopPropagation();
    onRangePositionChange("start");
    if (!readOnly && !disableOpenPicker) {
      actions.onOpen(event);
    }
  };
  const openRangeEndSelection = (event) => {
    event.stopPropagation();
    onRangePositionChange("end");
    if (!readOnly && !disableOpenPicker) {
      actions.onOpen(event);
    }
  };
  const handleFocusStart = () => {
    if (open) {
      onRangePositionChange("start");
      if (previousRangePosition.current !== "start" && initialView) {
        onViewChange == null ? void 0 : onViewChange(initialView);
      }
    }
  };
  const handleFocusEnd = () => {
    if (open) {
      onRangePositionChange("end");
      if (previousRangePosition.current !== "end" && initialView) {
        onViewChange == null ? void 0 : onViewChange(initialView);
      }
    }
  };
  const slots = _extends({
    textField: pickerSlots == null ? void 0 : pickerSlots.textField,
    root: pickerSlots == null ? void 0 : pickerSlots.fieldRoot,
    separator: pickerSlots == null ? void 0 : pickerSlots.fieldSeparator
  }, fieldProps.slots);
  const slotProps = _extends({}, fieldProps.slotProps, {
    textField: (ownerState) => {
      const resolvedComponentProps = resolveComponentProps_default(pickerSlotProps == null ? void 0 : pickerSlotProps.textField, ownerState);
      let textFieldProps;
      let InputProps;
      if (ownerState.position === "start") {
        textFieldProps = _extends({
          label: (inLocaleText == null ? void 0 : inLocaleText.start) ?? translations.start,
          onKeyDown: onSpaceOrEnter(openRangeStartSelection),
          onFocus: handleFocusStart,
          focused: open ? rangePosition === "start" : void 0
        }, !readOnly && !fieldProps.disabled && {
          onClick: openRangeStartSelection
        }, wrapperVariant === "mobile" && {
          readOnly: true
        });
        if (anchorRef) {
          InputProps = _extends({}, resolvedComponentProps == null ? void 0 : resolvedComponentProps.InputProps, {
            ref: anchorRef
          });
        }
      } else {
        textFieldProps = _extends({
          label: (inLocaleText == null ? void 0 : inLocaleText.end) ?? translations.end,
          onKeyDown: onSpaceOrEnter(openRangeEndSelection),
          onFocus: handleFocusEnd,
          focused: open ? rangePosition === "end" : void 0
        }, !readOnly && !fieldProps.disabled && {
          onClick: openRangeEndSelection
        }, wrapperVariant === "mobile" && {
          readOnly: true
        });
        InputProps = resolvedComponentProps == null ? void 0 : resolvedComponentProps.InputProps;
      }
      return _extends({}, labelId != null && {
        id: `${labelId}-${ownerState.position}`
      }, textFieldProps, resolveComponentProps_default(pickerSlotProps == null ? void 0 : pickerSlotProps.textField, ownerState), {
        InputProps
      });
    },
    root: (ownerState) => {
      const rootProps = {
        onBlur
      };
      return _extends({}, rootProps, resolveComponentProps_default(pickerSlotProps == null ? void 0 : pickerSlotProps.fieldRoot, ownerState));
    },
    separator: pickerSlotProps == null ? void 0 : pickerSlotProps.fieldSeparator
  });
  const _ref = fieldProps, restFieldProps = _objectWithoutPropertiesLoose(_ref, _excluded8);
  const enrichedFieldProps = _extends({}, restFieldProps, {
    unstableStartFieldRef: handleStartFieldRef,
    unstableEndFieldRef: handleEndFieldRef,
    slots,
    slotProps
  });
  return enrichedFieldProps;
};
var useSingleInputFieldSlotProps = ({
  wrapperVariant,
  open,
  actions,
  readOnly,
  labelId,
  disableOpenPicker,
  label,
  onBlur,
  rangePosition,
  onRangePositionChange,
  startFieldRef,
  endFieldRef,
  pickerSlots,
  pickerSlotProps,
  fieldProps,
  anchorRef,
  currentView
}) => {
  const handleFieldRef = useForkRef(fieldProps.unstableFieldRef, startFieldRef, endFieldRef);
  React17.useEffect(() => {
    var _a;
    if (!open || !startFieldRef.current) {
      return;
    }
    if (startFieldRef.current.isFieldFocused()) {
      return;
    }
    if (currentView) {
      const sections = startFieldRef.current.getSections().map((section) => section.type);
      const newSelectedSection = rangePosition === "start" ? sections.indexOf(currentView) : sections.lastIndexOf(currentView);
      (_a = startFieldRef.current) == null ? void 0 : _a.focusField(newSelectedSection);
    }
  }, [rangePosition, open, currentView, startFieldRef]);
  const updateRangePosition = () => {
    var _a, _b;
    if (!((_a = startFieldRef.current) == null ? void 0 : _a.isFieldFocused())) {
      return;
    }
    const sections = startFieldRef.current.getSections();
    const activeSectionIndex = (_b = startFieldRef.current) == null ? void 0 : _b.getActiveSectionIndex();
    const domRangePosition = activeSectionIndex == null || activeSectionIndex < sections.length / 2 ? "start" : "end";
    if (domRangePosition != null && domRangePosition !== rangePosition) {
      onRangePositionChange(domRangePosition);
    }
  };
  const handleSelectedSectionsChange = useEventCallback_default((selectedSection) => {
    var _a;
    setTimeout(updateRangePosition);
    (_a = fieldProps.onSelectedSectionsChange) == null ? void 0 : _a.call(fieldProps, selectedSection);
  });
  const openPicker = (event) => {
    event.stopPropagation();
    if (!readOnly && !disableOpenPicker) {
      actions.onOpen(event);
    }
  };
  const slots = _extends({}, fieldProps.slots, {
    textField: pickerSlots == null ? void 0 : pickerSlots.textField,
    clearButton: pickerSlots == null ? void 0 : pickerSlots.clearButton,
    clearIcon: pickerSlots == null ? void 0 : pickerSlots.clearIcon
  });
  const slotProps = _extends({}, fieldProps.slotProps, {
    textField: pickerSlotProps == null ? void 0 : pickerSlotProps.textField,
    clearButton: pickerSlots == null ? void 0 : pickerSlots.clearButton,
    clearIcon: pickerSlots == null ? void 0 : pickerSlots.clearIcon
  });
  const enrichedFieldProps = _extends({}, fieldProps, {
    slots,
    slotProps,
    label,
    unstableFieldRef: handleFieldRef,
    onKeyDown: onSpaceOrEnter(openPicker, fieldProps.onKeyDown),
    onSelectedSectionsChange: handleSelectedSectionsChange,
    onBlur,
    InputProps: _extends({
      ref: anchorRef
    }, fieldProps == null ? void 0 : fieldProps.InputProps),
    focused: open ? true : void 0
  }, labelId != null && {
    id: labelId
  }, wrapperVariant === "mobile" && {
    readOnly: true
  }, !readOnly && !fieldProps.disabled && {
    onClick: openPicker
  });
  return enrichedFieldProps;
};
var useEnrichedRangePickerFieldProps = (params) => {
  if (true) {
    const fieldTypeRef = React17.useRef(params.fieldType);
    if (params.fieldType !== fieldTypeRef.current) {
      console.error("Should not switch between a multi input field and a single input field on a range picker.");
    }
  }
  if (params.fieldType === "multi-input") {
    return useMultiInputFieldSlotProps(params);
  }
  return useSingleInputFieldSlotProps(params);
};

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMobileRangePicker/useMobileRangePicker.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var _excluded9 = ["props"];
var releaseInfo3 = getReleaseInfo();
var useMobileRangePicker = (_ref) => {
  var _a;
  let {
    props
  } = _ref, pickerParams = _objectWithoutPropertiesLoose(_ref, _excluded9);
  useLicenseVerifier("x-date-pickers-pro", releaseInfo3);
  const {
    slots,
    slotProps: innerSlotProps,
    className,
    sx,
    format,
    formatDensity,
    enableAccessibleFieldDOMStructure,
    selectedSections,
    onSelectedSectionsChange,
    timezone,
    label,
    inputRef,
    name,
    readOnly,
    disabled,
    disableOpenPicker,
    localeText
  } = props;
  const startFieldRef = React18.useRef(null);
  const endFieldRef = React18.useRef(null);
  const fieldType = slots.field.fieldType ?? "multi-input";
  const {
    rangePosition,
    onRangePositionChange
  } = useRangePosition(props, fieldType === "single-input" ? startFieldRef : void 0);
  const labelId = useId();
  const contextTranslations = usePickersTranslations();
  const {
    open,
    actions,
    layoutProps,
    renderCurrentView,
    fieldProps: pickerFieldProps,
    contextValue
  } = usePicker(_extends({}, pickerParams, {
    props,
    wrapperVariant: "mobile",
    autoFocusView: true,
    fieldRef: rangePosition === "start" ? startFieldRef : endFieldRef,
    additionalViewProps: {
      rangePosition,
      onRangePositionChange
    }
  }));
  const Field = slots.field;
  const fieldProps = useSlotProps_default({
    elementType: Field,
    externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.field,
    additionalProps: _extends({}, pickerFieldProps, {
      readOnly: readOnly ?? true,
      disabled,
      className,
      sx,
      format,
      formatDensity,
      enableAccessibleFieldDOMStructure,
      selectedSections,
      onSelectedSectionsChange,
      timezone
    }, fieldType === "single-input" ? {
      inputRef,
      name
    } : {}),
    ownerState: props
  });
  const isToolbarHidden = ((_a = innerSlotProps == null ? void 0 : innerSlotProps.toolbar) == null ? void 0 : _a.hidden) ?? false;
  const enrichedFieldProps = useEnrichedRangePickerFieldProps({
    wrapperVariant: "mobile",
    fieldType,
    open,
    actions,
    readOnly,
    labelId,
    disableOpenPicker,
    label,
    localeText,
    rangePosition,
    onRangePositionChange,
    pickerSlots: slots,
    pickerSlotProps: innerSlotProps,
    fieldProps,
    startFieldRef,
    endFieldRef
  });
  const slotPropsForLayout = _extends({}, innerSlotProps, {
    tabs: _extends({}, innerSlotProps == null ? void 0 : innerSlotProps.tabs, {
      rangePosition,
      onRangePositionChange
    }),
    toolbar: _extends({}, innerSlotProps == null ? void 0 : innerSlotProps.toolbar, {
      titleId: labelId,
      rangePosition,
      onRangePositionChange
    })
  });
  const Layout = (slots == null ? void 0 : slots.layout) ?? PickersLayout;
  const finalLocaleText = _extends({}, contextTranslations, localeText);
  let labelledById = pickerParams.valueType === "date-time" ? `${labelId}-start-toolbar ${labelId}-end-toolbar` : labelId;
  if (isToolbarHidden) {
    const labels = [];
    if (fieldType === "multi-input") {
      if (finalLocaleText.start) {
        labels.push(`${labelId}-start-label`);
      }
      if (finalLocaleText.end) {
        labels.push(`${labelId}-end-label`);
      }
    } else if (label != null) {
      labels.push(`${labelId}-label`);
    }
    labelledById = labels.length > 0 ? labels.join(" ") : void 0;
  }
  const slotProps = _extends({}, innerSlotProps, {
    mobilePaper: _extends({
      "aria-labelledby": labelledById
    }, innerSlotProps == null ? void 0 : innerSlotProps.mobilePaper)
  });
  const renderPicker = () => (0, import_jsx_runtime12.jsxs)(PickersProvider, {
    contextValue,
    localeText,
    children: [(0, import_jsx_runtime12.jsx)(Field, _extends({}, enrichedFieldProps)), (0, import_jsx_runtime12.jsx)(PickersModalDialog, _extends({}, actions, {
      open,
      slots,
      slotProps,
      children: (0, import_jsx_runtime12.jsx)(Layout, _extends({}, layoutProps, slotProps == null ? void 0 : slotProps.layout, {
        slots,
        slotProps: slotPropsForLayout,
        children: renderCurrentView()
      }))
    }))]
  });
  return {
    renderPicker
  };
};

// node_modules/@mui/x-date-pickers-pro/MobileDateRangePicker/MobileDateRangePicker.js
var MobileDateRangePicker = React19.forwardRef(function MobileDateRangePicker2(inProps, ref) {
  var _a;
  const defaultizedProps = useDateRangePickerDefaultizedProps(inProps, "MuiMobileDateRangePicker");
  const viewRenderers = _extends({
    day: renderDateRangeViewCalendar
  }, defaultizedProps.viewRenderers);
  const props = _extends({}, defaultizedProps, {
    viewRenderers,
    // Force one calendar on mobile to avoid layout issues
    calendars: 1,
    views: ["day"],
    openTo: "day",
    slots: _extends({
      field: MultiInputDateRangeField
    }, defaultizedProps.slots),
    slotProps: _extends({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _a2;
        return _extends({}, resolveComponentProps_default((_a2 = defaultizedProps.slotProps) == null ? void 0 : _a2.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      toolbar: _extends({
        hidden: false
      }, (_a = defaultizedProps.slotProps) == null ? void 0 : _a.toolbar)
    })
  });
  const {
    renderPicker
  } = useMobileRangePicker({
    props,
    valueManager: rangeValueManager,
    valueType: "date",
    validator: validateDateRange
  });
  return renderPicker();
});
MobileDateRangePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types8.default.bool,
  className: import_prop_types8.default.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: import_prop_types8.default.bool,
  /**
   * Position the current month is rendered in.
   * @default 1
   */
  currentMonthCalendarPosition: import_prop_types8.default.oneOf([1, 2, 3]),
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: import_prop_types8.default.func,
  /**
   * The initial position in the edited date range.
   * Used when the component is not controlled.
   * @default 'start'
   */
  defaultRangePosition: import_prop_types8.default.oneOf(["end", "start"]),
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types8.default.arrayOf(import_prop_types8.default.object),
  /**
   * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
   * @default false
   */
  disableAutoMonthSwitching: import_prop_types8.default.bool,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types8.default.bool,
  /**
   * If `true`, editing dates by dragging is disabled.
   * @default false
   */
  disableDragEditing: import_prop_types8.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types8.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types8.default.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: import_prop_types8.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types8.default.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: import_prop_types8.default.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: import_prop_types8.default.any,
  /**
   * The day view will show as many weeks as needed after the end of the current month to match this value.
   * Put it to 6 to have a fixed number of weeks in Gregorian calendars
   */
  fixedWeekNumber: import_prop_types8.default.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: import_prop_types8.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types8.default.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   * Ignored if the field has several inputs.
   */
  inputRef: refType_default,
  /**
   * The label content.
   * Ignored if the field has several inputs.
   */
  label: import_prop_types8.default.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: import_prop_types8.default.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: import_prop_types8.default.object,
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: import_prop_types8.default.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: import_prop_types8.default.object,
  /**
   * Name attribute used by the `input` element in the Field.
   * Ignored if the field has several inputs.
   */
  name: import_prop_types8.default.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onAccept: import_prop_types8.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types8.default.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: import_prop_types8.default.func,
  /**
   * Callback fired when the error associated with the current value changes.
   * When a validation error is detected, the `error` parameter contains a non-null value.
   * This can be used to render an appropriate form error.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @param {TError} error The reason why the current value is not valid.
   * @param {TValue} value The value associated with the error.
   */
  onError: import_prop_types8.default.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: import_prop_types8.default.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: import_prop_types8.default.func,
  /**
   * Callback fired when the range position changes.
   * @param {RangePosition} rangePosition The new range position.
   */
  onRangePositionChange: import_prop_types8.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types8.default.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: import_prop_types8.default.bool,
  /**
   * The position in the currently edited date range.
   * Used when the component position is controlled.
   */
  rangePosition: import_prop_types8.default.oneOf(["end", "start"]),
  readOnly: import_prop_types8.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types8.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: import_prop_types8.default.object,
  /**
   * Component rendered on the "day" view when `props.loading` is true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => "..."
   */
  renderLoading: import_prop_types8.default.func,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types8.default.oneOfType([import_prop_types8.default.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types8.default.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types8.default.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types8.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types8.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types8.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types8.default.oneOfType([import_prop_types8.default.arrayOf(import_prop_types8.default.oneOfType([import_prop_types8.default.func, import_prop_types8.default.object, import_prop_types8.default.bool])), import_prop_types8.default.func, import_prop_types8.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types8.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types8.default.arrayOf(import_prop_types8.default.object),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be used.
   */
  viewRenderers: import_prop_types8.default.shape({
    day: import_prop_types8.default.func
  })
};

export {
  getDateRangePickerToolbarUtilityClass,
  dateRangePickerToolbarClasses,
  DateRangePickerToolbar,
  useDateRangePickerDefaultizedProps,
  LicenseInfo,
  useLicenseVerifier,
  getReleaseInfo,
  getDateRangeCalendarUtilityClass,
  dateRangeCalendarClasses,
  calculateRangeChange,
  getDateRangePickerDayUtilityClass,
  dateRangePickerDayClasses,
  DateRangePickerDay2 as DateRangePickerDay,
  useRangePosition,
  RANGE_VIEW_HEIGHT,
  pickersCalendarHeaderClasses,
  pickersFadeTransitionGroupClasses,
  PickersFadeTransitionGroup,
  PickersCalendarHeader,
  PickersRangeCalendarHeader,
  DateRangeCalendar,
  renderDateRangeViewCalendar,
  useDateField,
  DateField,
  excludeProps,
  useMultiInputFieldSelectedSections,
  useMultiInputDateRangeField,
  multiInputDateRangeFieldClasses,
  getMultiInputDateRangeFieldUtilityClass,
  MultiInputDateRangeField,
  useEnrichedRangePickerFieldProps,
  useMobileRangePicker,
  MobileDateRangePicker
};
/*! Bundled license information:

@mui/x-license/index.js:
  (**
   * @mui/x-license v7.21.0
   *
   * @license MUI X Commercial
   * This source code is licensed under the commercial license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-Y5DPMJ5M.js.map
