import {
  init_styled_components_browser_esm,
  styled_components_browser_esm_exports
} from "./chunk-5RT5PXLT.js";
import "./chunk-BWKARGHI.js";
import {
  require_extends,
  require_objectWithoutPropertiesLoose
} from "./chunk-6FVX65JR.js";
import "./chunk-O5BZTIH4.js";
import "./chunk-6XQ6XUBZ.js";
import "./chunk-QZRZLDTY.js";
import {
  require_react_dom
} from "./chunk-6FQJH6UM.js";
import {
  require_react
} from "./chunk-RA4EGHW6.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-2LSFTFF7.js";

// node_modules/@react-spring/rafz/dist/cjs/react-spring_rafz.development.cjs
var require_react_spring_rafz_development = __commonJS({
  "node_modules/@react-spring/rafz/dist/cjs/react-spring_rafz.development.cjs"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      __raf: () => __raf,
      raf: () => raf
    });
    module.exports = __toCommonJS2(src_exports);
    var updateQueue = makeQueue();
    var raf = (fn) => schedule(fn, updateQueue);
    var writeQueue = makeQueue();
    raf.write = (fn) => schedule(fn, writeQueue);
    var onStartQueue = makeQueue();
    raf.onStart = (fn) => schedule(fn, onStartQueue);
    var onFrameQueue = makeQueue();
    raf.onFrame = (fn) => schedule(fn, onFrameQueue);
    var onFinishQueue = makeQueue();
    raf.onFinish = (fn) => schedule(fn, onFinishQueue);
    var timeouts = [];
    raf.setTimeout = (handler, ms) => {
      const time = raf.now() + ms;
      const cancel = () => {
        const i = timeouts.findIndex((t) => t.cancel == cancel);
        if (~i)
          timeouts.splice(i, 1);
        pendingCount -= ~i ? 1 : 0;
      };
      const timeout = { time, handler, cancel };
      timeouts.splice(findTimeout(time), 0, timeout);
      pendingCount += 1;
      start();
      return timeout;
    };
    var findTimeout = (time) => ~(~timeouts.findIndex((t) => t.time > time) || ~timeouts.length);
    raf.cancel = (fn) => {
      onStartQueue.delete(fn);
      onFrameQueue.delete(fn);
      onFinishQueue.delete(fn);
      updateQueue.delete(fn);
      writeQueue.delete(fn);
    };
    raf.sync = (fn) => {
      sync = true;
      raf.batchedUpdates(fn);
      sync = false;
    };
    raf.throttle = (fn) => {
      let lastArgs;
      function queuedFn() {
        try {
          fn(...lastArgs);
        } finally {
          lastArgs = null;
        }
      }
      function throttled(...args) {
        lastArgs = args;
        raf.onStart(queuedFn);
      }
      throttled.handler = fn;
      throttled.cancel = () => {
        onStartQueue.delete(queuedFn);
        lastArgs = null;
      };
      return throttled;
    };
    var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : (
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      () => {
      }
    );
    raf.use = (impl) => nativeRaf = impl;
    raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
    raf.batchedUpdates = (fn) => fn();
    raf.catch = console.error;
    raf.frameLoop = "always";
    raf.advance = () => {
      if (raf.frameLoop !== "demand") {
        console.warn(
          "Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"
        );
      } else {
        update();
      }
    };
    var ts = -1;
    var pendingCount = 0;
    var sync = false;
    function schedule(fn, queue) {
      if (sync) {
        queue.delete(fn);
        fn(0);
      } else {
        queue.add(fn);
        start();
      }
    }
    function start() {
      if (ts < 0) {
        ts = 0;
        if (raf.frameLoop !== "demand") {
          nativeRaf(loop);
        }
      }
    }
    function stop() {
      ts = -1;
    }
    function loop() {
      if (~ts) {
        nativeRaf(loop);
        raf.batchedUpdates(update);
      }
    }
    function update() {
      const prevTs = ts;
      ts = raf.now();
      const count = findTimeout(ts);
      if (count) {
        eachSafely(timeouts.splice(0, count), (t) => t.handler());
        pendingCount -= count;
      }
      if (!pendingCount) {
        stop();
        return;
      }
      onStartQueue.flush();
      updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
      onFrameQueue.flush();
      writeQueue.flush();
      onFinishQueue.flush();
    }
    function makeQueue() {
      let next = /* @__PURE__ */ new Set();
      let current = next;
      return {
        add(fn) {
          pendingCount += current == next && !next.has(fn) ? 1 : 0;
          next.add(fn);
        },
        delete(fn) {
          pendingCount -= current == next && next.has(fn) ? 1 : 0;
          return next.delete(fn);
        },
        flush(arg) {
          if (current.size) {
            next = /* @__PURE__ */ new Set();
            pendingCount -= current.size;
            eachSafely(current, (fn) => fn(arg) && next.add(fn));
            pendingCount += next.size;
            current = next;
          }
        }
      };
    }
    function eachSafely(values, each) {
      values.forEach((value) => {
        try {
          each(value);
        } catch (e) {
          raf.catch(e);
        }
      });
    }
    var __raf = {
      /** The number of pending tasks */
      count() {
        return pendingCount;
      },
      /** Whether there's a raf update loop running */
      isRunning() {
        return ts >= 0;
      },
      /** Clear internal state. Never call from update loop! */
      clear() {
        ts = -1;
        timeouts = [];
        onStartQueue = makeQueue();
        updateQueue = makeQueue();
        onFrameQueue = makeQueue();
        writeQueue = makeQueue();
        onFinishQueue = makeQueue();
        pendingCount = 0;
      }
    };
  }
});

// node_modules/@react-spring/rafz/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@react-spring/rafz/dist/cjs/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_spring_rafz_development();
    }
  }
});

// node_modules/@react-spring/shared/dist/cjs/react-spring_shared.development.cjs
var require_react_spring_shared_development = __commonJS({
  "node_modules/@react-spring/shared/dist/cjs/react-spring_shared.development.cjs"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to2, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to2, key) && key !== except)
            __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to2;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      FluidValue: () => FluidValue,
      Globals: () => globals_exports,
      addFluidObserver: () => addFluidObserver,
      callFluidObserver: () => callFluidObserver,
      callFluidObservers: () => callFluidObservers,
      clamp: () => clamp,
      colorToRgba: () => colorToRgba,
      colors: () => colors2,
      createInterpolator: () => createInterpolator,
      createStringInterpolator: () => createStringInterpolator2,
      defineHidden: () => defineHidden,
      deprecateDirectCall: () => deprecateDirectCall,
      deprecateInterpolate: () => deprecateInterpolate,
      each: () => each,
      eachProp: () => eachProp,
      easings: () => easings,
      flush: () => flush,
      flushCalls: () => flushCalls,
      frameLoop: () => frameLoop,
      getFluidObservers: () => getFluidObservers,
      getFluidValue: () => getFluidValue,
      hasFluidValue: () => hasFluidValue,
      hex3: () => hex3,
      hex4: () => hex4,
      hex6: () => hex6,
      hex8: () => hex8,
      hsl: () => hsl,
      hsla: () => hsla,
      is: () => is,
      isAnimatedString: () => isAnimatedString,
      isEqual: () => isEqual2,
      isSSR: () => isSSR,
      noop: () => noop2,
      onResize: () => onResize,
      onScroll: () => onScroll,
      once: () => once,
      prefix: () => prefix,
      raf: () => import_rafz4.raf,
      removeFluidObserver: () => removeFluidObserver,
      rgb: () => rgb,
      rgba: () => rgba,
      setFluidGetter: () => setFluidGetter,
      toArray: () => toArray,
      useConstant: () => useConstant,
      useForceUpdate: () => useForceUpdate,
      useIsomorphicLayoutEffect: () => useIsomorphicLayoutEffect,
      useMemoOne: () => useMemoOne,
      useOnce: () => useOnce,
      usePrev: () => usePrev,
      useReducedMotion: () => useReducedMotion
    });
    module.exports = __toCommonJS2(src_exports);
    var globals_exports = {};
    __export2(globals_exports, {
      assign: () => assign,
      colors: () => colors,
      createStringInterpolator: () => createStringInterpolator,
      skipAnimation: () => skipAnimation,
      to: () => to,
      willAdvance: () => willAdvance
    });
    var import_rafz = require_cjs();
    function noop2() {
    }
    var defineHidden = (obj, key, value) => Object.defineProperty(obj, key, { value, writable: true, configurable: true });
    var is = {
      arr: Array.isArray,
      obj: (a) => !!a && a.constructor.name === "Object",
      fun: (a) => typeof a === "function",
      str: (a) => typeof a === "string",
      num: (a) => typeof a === "number",
      und: (a) => a === void 0
    };
    function isEqual2(a, b) {
      if (is.arr(a)) {
        if (!is.arr(b) || a.length !== b.length)
          return false;
        for (let i = 0; i < a.length; i++) {
          if (a[i] !== b[i])
            return false;
        }
        return true;
      }
      return a === b;
    }
    var each = (obj, fn) => obj.forEach(fn);
    function eachProp(obj, fn, ctx) {
      if (is.arr(obj)) {
        for (let i = 0; i < obj.length; i++) {
          fn.call(ctx, obj[i], `${i}`);
        }
        return;
      }
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          fn.call(ctx, obj[key], key);
        }
      }
    }
    var toArray = (a) => is.und(a) ? [] : is.arr(a) ? a : [a];
    function flush(queue, iterator) {
      if (queue.size) {
        const items = Array.from(queue);
        queue.clear();
        each(items, iterator);
      }
    }
    var flushCalls = (queue, ...args) => flush(queue, (fn) => fn(...args));
    var isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
    var createStringInterpolator;
    var to;
    var colors = null;
    var skipAnimation = false;
    var willAdvance = noop2;
    var assign = (globals) => {
      if (globals.to)
        to = globals.to;
      if (globals.now)
        import_rafz.raf.now = globals.now;
      if (globals.colors !== void 0)
        colors = globals.colors;
      if (globals.skipAnimation != null)
        skipAnimation = globals.skipAnimation;
      if (globals.createStringInterpolator)
        createStringInterpolator = globals.createStringInterpolator;
      if (globals.requestAnimationFrame)
        import_rafz.raf.use(globals.requestAnimationFrame);
      if (globals.batchedUpdates)
        import_rafz.raf.batchedUpdates = globals.batchedUpdates;
      if (globals.willAdvance)
        willAdvance = globals.willAdvance;
      if (globals.frameLoop)
        import_rafz.raf.frameLoop = globals.frameLoop;
    };
    var import_rafz2 = require_cjs();
    var startQueue = /* @__PURE__ */ new Set();
    var currentFrame = [];
    var prevFrame = [];
    var priority = 0;
    var frameLoop = {
      get idle() {
        return !startQueue.size && !currentFrame.length;
      },
      /** Advance the given animation on every frame until idle. */
      start(animation) {
        if (priority > animation.priority) {
          startQueue.add(animation);
          import_rafz2.raf.onStart(flushStartQueue);
        } else {
          startSafely(animation);
          (0, import_rafz2.raf)(advance);
        }
      },
      /** Advance all animations by the given time. */
      advance,
      /** Call this when an animation's priority changes. */
      sort(animation) {
        if (priority) {
          import_rafz2.raf.onFrame(() => frameLoop.sort(animation));
        } else {
          const prevIndex = currentFrame.indexOf(animation);
          if (~prevIndex) {
            currentFrame.splice(prevIndex, 1);
            startUnsafely(animation);
          }
        }
      },
      /**
       * Clear all animations. For testing purposes.
       *
       * ☠️ Never call this from within the frameloop.
       */
      clear() {
        currentFrame = [];
        startQueue.clear();
      }
    };
    function flushStartQueue() {
      startQueue.forEach(startSafely);
      startQueue.clear();
      (0, import_rafz2.raf)(advance);
    }
    function startSafely(animation) {
      if (!currentFrame.includes(animation))
        startUnsafely(animation);
    }
    function startUnsafely(animation) {
      currentFrame.splice(
        findIndex(currentFrame, (other) => other.priority > animation.priority),
        0,
        animation
      );
    }
    function advance(dt) {
      const nextFrame = prevFrame;
      for (let i = 0; i < currentFrame.length; i++) {
        const animation = currentFrame[i];
        priority = animation.priority;
        if (!animation.idle) {
          willAdvance(animation);
          animation.advance(dt);
          if (!animation.idle) {
            nextFrame.push(animation);
          }
        }
      }
      priority = 0;
      prevFrame = currentFrame;
      prevFrame.length = 0;
      currentFrame = nextFrame;
      return currentFrame.length > 0;
    }
    function findIndex(arr, test) {
      const index = arr.findIndex(test);
      return index < 0 ? arr.length : index;
    }
    var clamp = (min, max, v) => Math.min(Math.max(v, min), max);
    var colors2 = {
      transparent: 0,
      aliceblue: 4042850303,
      antiquewhite: 4209760255,
      aqua: 16777215,
      aquamarine: 2147472639,
      azure: 4043309055,
      beige: 4126530815,
      bisque: 4293182719,
      black: 255,
      blanchedalmond: 4293643775,
      blue: 65535,
      blueviolet: 2318131967,
      brown: 2771004159,
      burlywood: 3736635391,
      burntsienna: 3934150143,
      cadetblue: 1604231423,
      chartreuse: 2147418367,
      chocolate: 3530104575,
      coral: 4286533887,
      cornflowerblue: 1687547391,
      cornsilk: 4294499583,
      crimson: 3692313855,
      cyan: 16777215,
      darkblue: 35839,
      darkcyan: 9145343,
      darkgoldenrod: 3095792639,
      darkgray: 2846468607,
      darkgreen: 6553855,
      darkgrey: 2846468607,
      darkkhaki: 3182914559,
      darkmagenta: 2332068863,
      darkolivegreen: 1433087999,
      darkorange: 4287365375,
      darkorchid: 2570243327,
      darkred: 2332033279,
      darksalmon: 3918953215,
      darkseagreen: 2411499519,
      darkslateblue: 1211993087,
      darkslategray: 793726975,
      darkslategrey: 793726975,
      darkturquoise: 13554175,
      darkviolet: 2483082239,
      deeppink: 4279538687,
      deepskyblue: 12582911,
      dimgray: 1768516095,
      dimgrey: 1768516095,
      dodgerblue: 512819199,
      firebrick: 2988581631,
      floralwhite: 4294635775,
      forestgreen: 579543807,
      fuchsia: 4278255615,
      gainsboro: 3705462015,
      ghostwhite: 4177068031,
      gold: 4292280575,
      goldenrod: 3668254975,
      gray: 2155905279,
      green: 8388863,
      greenyellow: 2919182335,
      grey: 2155905279,
      honeydew: 4043305215,
      hotpink: 4285117695,
      indianred: 3445382399,
      indigo: 1258324735,
      ivory: 4294963455,
      khaki: 4041641215,
      lavender: 3873897215,
      lavenderblush: 4293981695,
      lawngreen: 2096890111,
      lemonchiffon: 4294626815,
      lightblue: 2916673279,
      lightcoral: 4034953471,
      lightcyan: 3774873599,
      lightgoldenrodyellow: 4210742015,
      lightgray: 3553874943,
      lightgreen: 2431553791,
      lightgrey: 3553874943,
      lightpink: 4290167295,
      lightsalmon: 4288707327,
      lightseagreen: 548580095,
      lightskyblue: 2278488831,
      lightslategray: 2005441023,
      lightslategrey: 2005441023,
      lightsteelblue: 2965692159,
      lightyellow: 4294959359,
      lime: 16711935,
      limegreen: 852308735,
      linen: 4210091775,
      magenta: 4278255615,
      maroon: 2147483903,
      mediumaquamarine: 1724754687,
      mediumblue: 52735,
      mediumorchid: 3126187007,
      mediumpurple: 2473647103,
      mediumseagreen: 1018393087,
      mediumslateblue: 2070474495,
      mediumspringgreen: 16423679,
      mediumturquoise: 1221709055,
      mediumvioletred: 3340076543,
      midnightblue: 421097727,
      mintcream: 4127193855,
      mistyrose: 4293190143,
      moccasin: 4293178879,
      navajowhite: 4292783615,
      navy: 33023,
      oldlace: 4260751103,
      olive: 2155872511,
      olivedrab: 1804477439,
      orange: 4289003775,
      orangered: 4282712319,
      orchid: 3664828159,
      palegoldenrod: 4008225535,
      palegreen: 2566625535,
      paleturquoise: 2951671551,
      palevioletred: 3681588223,
      papayawhip: 4293907967,
      peachpuff: 4292524543,
      peru: 3448061951,
      pink: 4290825215,
      plum: 3718307327,
      powderblue: 2967529215,
      purple: 2147516671,
      rebeccapurple: 1714657791,
      red: 4278190335,
      rosybrown: 3163525119,
      royalblue: 1097458175,
      saddlebrown: 2336560127,
      salmon: 4202722047,
      sandybrown: 4104413439,
      seagreen: 780883967,
      seashell: 4294307583,
      sienna: 2689740287,
      silver: 3233857791,
      skyblue: 2278484991,
      slateblue: 1784335871,
      slategray: 1887473919,
      slategrey: 1887473919,
      snow: 4294638335,
      springgreen: 16744447,
      steelblue: 1182971135,
      tan: 3535047935,
      teal: 8421631,
      thistle: 3636451583,
      tomato: 4284696575,
      turquoise: 1088475391,
      violet: 4001558271,
      wheat: 4125012991,
      white: 4294967295,
      whitesmoke: 4126537215,
      yellow: 4294902015,
      yellowgreen: 2597139199
    };
    var NUMBER = "[-+]?\\d*\\.?\\d+";
    var PERCENTAGE = NUMBER + "%";
    function call(...parts) {
      return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
    }
    var rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
    var rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
    var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
    var hsla = new RegExp(
      "hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)
    );
    var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
    var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
    var hex6 = /^#([0-9a-fA-F]{6})$/;
    var hex8 = /^#([0-9a-fA-F]{8})$/;
    function normalizeColor(color) {
      let match;
      if (typeof color === "number") {
        return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;
      }
      if (match = hex6.exec(color))
        return parseInt(match[1] + "ff", 16) >>> 0;
      if (colors && colors[color] !== void 0) {
        return colors[color];
      }
      if (match = rgb.exec(color)) {
        return (parse255(match[1]) << 24 | // r
        parse255(match[2]) << 16 | // g
        parse255(match[3]) << 8 | // b
        255) >>> // a
        0;
      }
      if (match = rgba.exec(color)) {
        return (parse255(match[1]) << 24 | // r
        parse255(match[2]) << 16 | // g
        parse255(match[3]) << 8 | // b
        parse1(match[4])) >>> // a
        0;
      }
      if (match = hex3.exec(color)) {
        return parseInt(
          match[1] + match[1] + // r
          match[2] + match[2] + // g
          match[3] + match[3] + // b
          "ff",
          // a
          16
        ) >>> 0;
      }
      if (match = hex8.exec(color))
        return parseInt(match[1], 16) >>> 0;
      if (match = hex4.exec(color)) {
        return parseInt(
          match[1] + match[1] + // r
          match[2] + match[2] + // g
          match[3] + match[3] + // b
          match[4] + match[4],
          // a
          16
        ) >>> 0;
      }
      if (match = hsl.exec(color)) {
        return (hslToRgb(
          parse360(match[1]),
          // h
          parsePercentage(match[2]),
          // s
          parsePercentage(match[3])
          // l
        ) | 255) >>> // a
        0;
      }
      if (match = hsla.exec(color)) {
        return (hslToRgb(
          parse360(match[1]),
          // h
          parsePercentage(match[2]),
          // s
          parsePercentage(match[3])
          // l
        ) | parse1(match[4])) >>> // a
        0;
      }
      return null;
    }
    function hue2rgb(p, q, t) {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p + (q - p) * 6 * t;
      if (t < 1 / 2)
        return q;
      if (t < 2 / 3)
        return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }
    function hslToRgb(h, s, l) {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      const r = hue2rgb(p, q, h + 1 / 3);
      const g = hue2rgb(p, q, h);
      const b = hue2rgb(p, q, h - 1 / 3);
      return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
    }
    function parse255(str) {
      const int = parseInt(str, 10);
      if (int < 0)
        return 0;
      if (int > 255)
        return 255;
      return int;
    }
    function parse360(str) {
      const int = parseFloat(str);
      return (int % 360 + 360) % 360 / 360;
    }
    function parse1(str) {
      const num = parseFloat(str);
      if (num < 0)
        return 0;
      if (num > 1)
        return 255;
      return Math.round(num * 255);
    }
    function parsePercentage(str) {
      const int = parseFloat(str);
      if (int < 0)
        return 0;
      if (int > 100)
        return 1;
      return int / 100;
    }
    function colorToRgba(input) {
      let int32Color = normalizeColor(input);
      if (int32Color === null)
        return input;
      int32Color = int32Color || 0;
      const r = (int32Color & 4278190080) >>> 24;
      const g = (int32Color & 16711680) >>> 16;
      const b = (int32Color & 65280) >>> 8;
      const a = (int32Color & 255) / 255;
      return `rgba(${r}, ${g}, ${b}, ${a})`;
    }
    var createInterpolator = (range, output, extrapolate) => {
      if (is.fun(range)) {
        return range;
      }
      if (is.arr(range)) {
        return createInterpolator({
          range,
          output,
          extrapolate
        });
      }
      if (is.str(range.output[0])) {
        return createStringInterpolator(range);
      }
      const config = range;
      const outputRange = config.output;
      const inputRange = config.range || [0, 1];
      const extrapolateLeft = config.extrapolateLeft || config.extrapolate || "extend";
      const extrapolateRight = config.extrapolateRight || config.extrapolate || "extend";
      const easing = config.easing || ((t) => t);
      return (input) => {
        const range2 = findRange(input, inputRange);
        return interpolate(
          input,
          inputRange[range2],
          inputRange[range2 + 1],
          outputRange[range2],
          outputRange[range2 + 1],
          easing,
          extrapolateLeft,
          extrapolateRight,
          config.map
        );
      };
    };
    function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
      let result = map ? map(input) : input;
      if (result < inputMin) {
        if (extrapolateLeft === "identity")
          return result;
        else if (extrapolateLeft === "clamp")
          result = inputMin;
      }
      if (result > inputMax) {
        if (extrapolateRight === "identity")
          return result;
        else if (extrapolateRight === "clamp")
          result = inputMax;
      }
      if (outputMin === outputMax)
        return outputMin;
      if (inputMin === inputMax)
        return input <= inputMin ? outputMin : outputMax;
      if (inputMin === -Infinity)
        result = -result;
      else if (inputMax === Infinity)
        result = result - inputMin;
      else
        result = (result - inputMin) / (inputMax - inputMin);
      result = easing(result);
      if (outputMin === -Infinity)
        result = -result;
      else if (outputMax === Infinity)
        result = result + outputMin;
      else
        result = result * (outputMax - outputMin) + outputMin;
      return result;
    }
    function findRange(input, inputRange) {
      for (var i = 1; i < inputRange.length - 1; ++i)
        if (inputRange[i] >= input)
          break;
      return i - 1;
    }
    var steps = (steps2, direction = "end") => (progress2) => {
      progress2 = direction === "end" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);
      const expanded = progress2 * steps2;
      const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
      return clamp(0, 1, rounded / steps2);
    };
    var c1 = 1.70158;
    var c2 = c1 * 1.525;
    var c3 = c1 + 1;
    var c4 = 2 * Math.PI / 3;
    var c5 = 2 * Math.PI / 4.5;
    var bounceOut = (x) => {
      const n1 = 7.5625;
      const d1 = 2.75;
      if (x < 1 / d1) {
        return n1 * x * x;
      } else if (x < 2 / d1) {
        return n1 * (x -= 1.5 / d1) * x + 0.75;
      } else if (x < 2.5 / d1) {
        return n1 * (x -= 2.25 / d1) * x + 0.9375;
      } else {
        return n1 * (x -= 2.625 / d1) * x + 0.984375;
      }
    };
    var easings = {
      linear: (x) => x,
      easeInQuad: (x) => x * x,
      easeOutQuad: (x) => 1 - (1 - x) * (1 - x),
      easeInOutQuad: (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,
      easeInCubic: (x) => x * x * x,
      easeOutCubic: (x) => 1 - Math.pow(1 - x, 3),
      easeInOutCubic: (x) => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,
      easeInQuart: (x) => x * x * x * x,
      easeOutQuart: (x) => 1 - Math.pow(1 - x, 4),
      easeInOutQuart: (x) => x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,
      easeInQuint: (x) => x * x * x * x * x,
      easeOutQuint: (x) => 1 - Math.pow(1 - x, 5),
      easeInOutQuint: (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2,
      easeInSine: (x) => 1 - Math.cos(x * Math.PI / 2),
      easeOutSine: (x) => Math.sin(x * Math.PI / 2),
      easeInOutSine: (x) => -(Math.cos(Math.PI * x) - 1) / 2,
      easeInExpo: (x) => x === 0 ? 0 : Math.pow(2, 10 * x - 10),
      easeOutExpo: (x) => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),
      easeInOutExpo: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2,
      easeInCirc: (x) => 1 - Math.sqrt(1 - Math.pow(x, 2)),
      easeOutCirc: (x) => Math.sqrt(1 - Math.pow(x - 1, 2)),
      easeInOutCirc: (x) => x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2,
      easeInBack: (x) => c3 * x * x * x - c1 * x * x,
      easeOutBack: (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2),
      easeInOutBack: (x) => x < 0.5 ? Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2,
      easeInElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4),
      easeOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1,
      easeInOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1,
      easeInBounce: (x) => 1 - bounceOut(1 - x),
      easeOutBounce: bounceOut,
      easeInOutBounce: (x) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2,
      steps
    };
    var $get = Symbol.for("FluidValue.get");
    var $observers = Symbol.for("FluidValue.observers");
    var hasFluidValue = (arg) => Boolean(arg && arg[$get]);
    var getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
    var getFluidObservers = (target) => target[$observers] || null;
    function callFluidObserver(observer2, event) {
      if (observer2.eventObserved) {
        observer2.eventObserved(event);
      } else {
        observer2(event);
      }
    }
    function callFluidObservers(target, event) {
      const observers = target[$observers];
      if (observers) {
        observers.forEach((observer2) => {
          callFluidObserver(observer2, event);
        });
      }
    }
    var FluidValue = class {
      constructor(get) {
        if (!get && !(get = this.get)) {
          throw Error("Unknown getter");
        }
        setFluidGetter(this, get);
      }
    };
    var setFluidGetter = (target, get) => setHidden(target, $get, get);
    function addFluidObserver(target, observer2) {
      if (target[$get]) {
        let observers = target[$observers];
        if (!observers) {
          setHidden(target, $observers, observers = /* @__PURE__ */ new Set());
        }
        if (!observers.has(observer2)) {
          observers.add(observer2);
          if (target.observerAdded) {
            target.observerAdded(observers.size, observer2);
          }
        }
      }
      return observer2;
    }
    function removeFluidObserver(target, observer2) {
      const observers = target[$observers];
      if (observers && observers.has(observer2)) {
        const count = observers.size - 1;
        if (count) {
          observers.delete(observer2);
        } else {
          target[$observers] = null;
        }
        if (target.observerRemoved) {
          target.observerRemoved(count, observer2);
        }
      }
    }
    var setHidden = (target, key, value) => Object.defineProperty(target, key, {
      value,
      writable: true,
      configurable: true
    });
    var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
    var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
    var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
    var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
    var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
    var variableToRgba = (input) => {
      const [token, fallback] = parseCSSVariable(input);
      if (!token || isSSR()) {
        return input;
      }
      const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);
      if (value) {
        return value.trim();
      } else if (fallback && fallback.startsWith("--")) {
        const value2 = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
        if (value2) {
          return value2;
        } else {
          return input;
        }
      } else if (fallback && cssVariableRegex.test(fallback)) {
        return variableToRgba(fallback);
      } else if (fallback) {
        return fallback;
      }
      return input;
    };
    var parseCSSVariable = (current) => {
      const match = cssVariableRegex.exec(current);
      if (!match)
        return [,];
      const [, token, fallback] = match;
      return [token, fallback];
    };
    var namedColorRegex;
    var rgbaRound = (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;
    var createStringInterpolator2 = (config) => {
      if (!namedColorRegex)
        namedColorRegex = colors ? (
          // match color names, ignore partial matches
          new RegExp(`(${Object.keys(colors).join("|")})(?!\\w)`, "g")
        ) : (
          // never match
          /^\b$/
        );
      const output = config.output.map((value) => {
        return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
      });
      const keyframes = output.map((value) => value.match(numberRegex).map(Number));
      const outputRanges = keyframes[0].map(
        (_, i) => keyframes.map((values) => {
          if (!(i in values)) {
            throw Error('The arity of each "output" value must be equal');
          }
          return values[i];
        })
      );
      const interpolators = outputRanges.map(
        (output2) => createInterpolator({ ...config, output: output2 })
      );
      return (input) => {
        var _a;
        const missingUnit = !unitRegex.test(output[0]) && ((_a = output.find((value) => unitRegex.test(value))) == null ? void 0 : _a.replace(numberRegex, ""));
        let i = 0;
        return output[0].replace(
          numberRegex,
          () => `${interpolators[i++](input)}${missingUnit || ""}`
        ).replace(rgbaRegex, rgbaRound);
      };
    };
    var prefix = "react-spring: ";
    var once = (fn) => {
      const func = fn;
      let called = false;
      if (typeof func != "function") {
        throw new TypeError(`${prefix}once requires a function parameter`);
      }
      return (...args) => {
        if (!called) {
          func(...args);
          called = true;
        }
      };
    };
    var warnInterpolate = once(console.warn);
    function deprecateInterpolate() {
      warnInterpolate(
        `${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`
      );
    }
    var warnDirectCall = once(console.warn);
    function deprecateDirectCall() {
      warnDirectCall(
        `${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`
      );
    }
    function isAnimatedString(value) {
      return is.str(value) && (value[0] == "#" || /\d/.test(value) || // Do not identify a CSS variable as an AnimatedString if its SSR
      !isSSR() && cssVariableRegex.test(value) || value in (colors || {}));
    }
    var import_rafz3 = require_cjs();
    var observer;
    var resizeHandlers = /* @__PURE__ */ new WeakMap();
    var handleObservation = (entries) => entries.forEach(({ target, contentRect }) => {
      var _a;
      return (_a = resizeHandlers.get(target)) == null ? void 0 : _a.forEach((handler) => handler(contentRect));
    });
    function resizeElement(handler, target) {
      if (!observer) {
        if (typeof ResizeObserver !== "undefined") {
          observer = new ResizeObserver(handleObservation);
        }
      }
      let elementHandlers = resizeHandlers.get(target);
      if (!elementHandlers) {
        elementHandlers = /* @__PURE__ */ new Set();
        resizeHandlers.set(target, elementHandlers);
      }
      elementHandlers.add(handler);
      if (observer) {
        observer.observe(target);
      }
      return () => {
        const elementHandlers2 = resizeHandlers.get(target);
        if (!elementHandlers2)
          return;
        elementHandlers2.delete(handler);
        if (!elementHandlers2.size && observer) {
          observer.unobserve(target);
        }
      };
    }
    var listeners = /* @__PURE__ */ new Set();
    var cleanupWindowResizeHandler;
    var createResizeHandler = () => {
      const handleResize = () => {
        listeners.forEach(
          (callback) => callback({
            width: window.innerWidth,
            height: window.innerHeight
          })
        );
      };
      window.addEventListener("resize", handleResize);
      return () => {
        window.removeEventListener("resize", handleResize);
      };
    };
    var resizeWindow = (callback) => {
      listeners.add(callback);
      if (!cleanupWindowResizeHandler) {
        cleanupWindowResizeHandler = createResizeHandler();
      }
      return () => {
        listeners.delete(callback);
        if (!listeners.size && cleanupWindowResizeHandler) {
          cleanupWindowResizeHandler();
          cleanupWindowResizeHandler = void 0;
        }
      };
    };
    var onResize = (callback, { container = document.documentElement } = {}) => {
      if (container === document.documentElement) {
        return resizeWindow(callback);
      } else {
        return resizeElement(callback, container);
      }
    };
    var progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);
    var SCROLL_KEYS = {
      x: {
        length: "Width",
        position: "Left"
      },
      y: {
        length: "Height",
        position: "Top"
      }
    };
    var ScrollHandler = class {
      constructor(callback, container) {
        this.createAxis = () => ({
          current: 0,
          progress: 0,
          scrollLength: 0
        });
        this.updateAxis = (axisName) => {
          const axis = this.info[axisName];
          const { length, position } = SCROLL_KEYS[axisName];
          axis.current = this.container[`scroll${position}`];
          axis.scrollLength = this.container[`scroll${length}`] - this.container[`client${length}`];
          axis.progress = progress(0, axis.scrollLength, axis.current);
        };
        this.update = () => {
          this.updateAxis("x");
          this.updateAxis("y");
        };
        this.sendEvent = () => {
          this.callback(this.info);
        };
        this.advance = () => {
          this.update();
          this.sendEvent();
        };
        this.callback = callback;
        this.container = container;
        this.info = {
          time: 0,
          x: this.createAxis(),
          y: this.createAxis()
        };
      }
    };
    var scrollListeners = /* @__PURE__ */ new WeakMap();
    var resizeListeners = /* @__PURE__ */ new WeakMap();
    var onScrollHandlers = /* @__PURE__ */ new WeakMap();
    var getTarget = (container) => container === document.documentElement ? window : container;
    var onScroll = (callback, { container = document.documentElement } = {}) => {
      let containerHandlers = onScrollHandlers.get(container);
      if (!containerHandlers) {
        containerHandlers = /* @__PURE__ */ new Set();
        onScrollHandlers.set(container, containerHandlers);
      }
      const containerHandler = new ScrollHandler(callback, container);
      containerHandlers.add(containerHandler);
      if (!scrollListeners.has(container)) {
        const listener = () => {
          containerHandlers == null ? void 0 : containerHandlers.forEach((handler) => handler.advance());
          return true;
        };
        scrollListeners.set(container, listener);
        const target = getTarget(container);
        window.addEventListener("resize", listener, { passive: true });
        if (container !== document.documentElement) {
          resizeListeners.set(container, onResize(listener, { container }));
        }
        target.addEventListener("scroll", listener, { passive: true });
      }
      const animateScroll = scrollListeners.get(container);
      (0, import_rafz3.raf)(animateScroll);
      return () => {
        var _a;
        import_rafz3.raf.cancel(animateScroll);
        const containerHandlers2 = onScrollHandlers.get(container);
        if (!containerHandlers2)
          return;
        containerHandlers2.delete(containerHandler);
        if (containerHandlers2.size)
          return;
        const listener = scrollListeners.get(container);
        scrollListeners.delete(container);
        if (listener) {
          getTarget(container).removeEventListener("scroll", listener);
          window.removeEventListener("resize", listener);
          (_a = resizeListeners.get(container)) == null ? void 0 : _a();
        }
      };
    };
    var import_react2 = require_react();
    function useConstant(init) {
      const ref = (0, import_react2.useRef)(null);
      if (ref.current === null) {
        ref.current = init();
      }
      return ref.current;
    }
    var import_react4 = require_react();
    var import_react3 = require_react();
    var import_react22 = require_react();
    var useIsomorphicLayoutEffect = isSSR() ? import_react22.useEffect : import_react22.useLayoutEffect;
    var useIsMounted = () => {
      const isMounted = (0, import_react3.useRef)(false);
      useIsomorphicLayoutEffect(() => {
        isMounted.current = true;
        return () => {
          isMounted.current = false;
        };
      }, []);
      return isMounted;
    };
    function useForceUpdate() {
      const update = (0, import_react4.useState)()[1];
      const isMounted = useIsMounted();
      return () => {
        if (isMounted.current) {
          update(Math.random());
        }
      };
    }
    var import_react5 = require_react();
    function useMemoOne(getResult, inputs) {
      const [initial2] = (0, import_react5.useState)(
        () => ({
          inputs,
          result: getResult()
        })
      );
      const committed = (0, import_react5.useRef)();
      const prevCache = committed.current;
      let cache = prevCache;
      if (cache) {
        const useCache = Boolean(
          inputs && cache.inputs && areInputsEqual(inputs, cache.inputs)
        );
        if (!useCache) {
          cache = {
            inputs,
            result: getResult()
          };
        }
      } else {
        cache = initial2;
      }
      (0, import_react5.useEffect)(() => {
        committed.current = cache;
        if (prevCache == initial2) {
          initial2.inputs = initial2.result = void 0;
        }
      }, [cache]);
      return cache.result;
    }
    function areInputsEqual(next, prev) {
      if (next.length !== prev.length) {
        return false;
      }
      for (let i = 0; i < next.length; i++) {
        if (next[i] !== prev[i]) {
          return false;
        }
      }
      return true;
    }
    var import_react6 = require_react();
    var useOnce = (effect) => (0, import_react6.useEffect)(effect, emptyDeps);
    var emptyDeps = [];
    var import_react7 = require_react();
    function usePrev(value) {
      const prevRef = (0, import_react7.useRef)();
      (0, import_react7.useEffect)(() => {
        prevRef.current = value;
      });
      return prevRef.current;
    }
    var import_react8 = require_react();
    var useReducedMotion = () => {
      const [reducedMotion, setReducedMotion] = (0, import_react8.useState)(null);
      useIsomorphicLayoutEffect(() => {
        const mql = window.matchMedia("(prefers-reduced-motion)");
        const handleMediaChange = (e) => {
          setReducedMotion(e.matches);
          assign({
            skipAnimation: e.matches
          });
        };
        handleMediaChange(mql);
        if (mql.addEventListener) {
          mql.addEventListener("change", handleMediaChange);
        } else {
          mql.addListener(handleMediaChange);
        }
        return () => {
          if (mql.removeEventListener) {
            mql.removeEventListener("change", handleMediaChange);
          } else {
            mql.removeListener(handleMediaChange);
          }
        };
      }, []);
      return reducedMotion;
    };
    var import_rafz4 = require_cjs();
  }
});

// node_modules/@react-spring/shared/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@react-spring/shared/dist/cjs/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_spring_shared_development();
    }
  }
});

// node_modules/@react-spring/animated/dist/cjs/react-spring_animated.development.cjs
var require_react_spring_animated_development = __commonJS({
  "node_modules/@react-spring/animated/dist/cjs/react-spring_animated.development.cjs"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      Animated: () => Animated,
      AnimatedArray: () => AnimatedArray,
      AnimatedObject: () => AnimatedObject,
      AnimatedString: () => AnimatedString,
      AnimatedValue: () => AnimatedValue,
      createHost: () => createHost,
      getAnimated: () => getAnimated,
      getAnimatedType: () => getAnimatedType,
      getPayload: () => getPayload,
      isAnimated: () => isAnimated,
      setAnimated: () => setAnimated
    });
    module.exports = __toCommonJS2(src_exports);
    var import_shared = require_cjs2();
    var $node = Symbol.for("Animated:node");
    var isAnimated = (value) => !!value && value[$node] === value;
    var getAnimated = (owner) => owner && owner[$node];
    var setAnimated = (owner, node) => (0, import_shared.defineHidden)(owner, $node, node);
    var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
    var Animated = class {
      constructor() {
        setAnimated(this, this);
      }
      /** Get every `AnimatedValue` used by this node. */
      getPayload() {
        return this.payload || [];
      }
    };
    var import_shared2 = require_cjs2();
    var AnimatedValue = class extends Animated {
      constructor(_value) {
        super();
        this._value = _value;
        this.done = true;
        this.durationProgress = 0;
        if (import_shared2.is.num(this._value)) {
          this.lastPosition = this._value;
        }
      }
      /** @internal */
      static create(value) {
        return new AnimatedValue(value);
      }
      getPayload() {
        return [this];
      }
      getValue() {
        return this._value;
      }
      setValue(value, step) {
        if (import_shared2.is.num(value)) {
          this.lastPosition = value;
          if (step) {
            value = Math.round(value / step) * step;
            if (this.done) {
              this.lastPosition = value;
            }
          }
        }
        if (this._value === value) {
          return false;
        }
        this._value = value;
        return true;
      }
      reset() {
        const { done } = this;
        this.done = false;
        if (import_shared2.is.num(this._value)) {
          this.elapsedTime = 0;
          this.durationProgress = 0;
          this.lastPosition = this._value;
          if (done)
            this.lastVelocity = null;
          this.v0 = null;
        }
      }
    };
    var import_shared3 = require_cjs2();
    var AnimatedString = class extends AnimatedValue {
      constructor(value) {
        super(0);
        this._string = null;
        this._toString = (0, import_shared3.createInterpolator)({
          output: [value, value]
        });
      }
      /** @internal */
      static create(value) {
        return new AnimatedString(value);
      }
      getValue() {
        const value = this._string;
        return value == null ? this._string = this._toString(this._value) : value;
      }
      setValue(value) {
        if (import_shared3.is.str(value)) {
          if (value == this._string) {
            return false;
          }
          this._string = value;
          this._value = 1;
        } else if (super.setValue(value)) {
          this._string = null;
        } else {
          return false;
        }
        return true;
      }
      reset(goal) {
        if (goal) {
          this._toString = (0, import_shared3.createInterpolator)({
            output: [this.getValue(), goal]
          });
        }
        this._value = 0;
        super.reset();
      }
    };
    var import_shared5 = require_cjs2();
    var import_shared4 = require_cjs2();
    var TreeContext = { dependencies: null };
    var AnimatedObject = class extends Animated {
      constructor(source) {
        super();
        this.source = source;
        this.setValue(source);
      }
      getValue(animated) {
        const values = {};
        (0, import_shared4.eachProp)(this.source, (source, key) => {
          if (isAnimated(source)) {
            values[key] = source.getValue(animated);
          } else if ((0, import_shared4.hasFluidValue)(source)) {
            values[key] = (0, import_shared4.getFluidValue)(source);
          } else if (!animated) {
            values[key] = source;
          }
        });
        return values;
      }
      /** Replace the raw object data */
      setValue(source) {
        this.source = source;
        this.payload = this._makePayload(source);
      }
      reset() {
        if (this.payload) {
          (0, import_shared4.each)(this.payload, (node) => node.reset());
        }
      }
      /** Create a payload set. */
      _makePayload(source) {
        if (source) {
          const payload = /* @__PURE__ */ new Set();
          (0, import_shared4.eachProp)(source, this._addToPayload, payload);
          return Array.from(payload);
        }
      }
      /** Add to a payload set. */
      _addToPayload(source) {
        if (TreeContext.dependencies && (0, import_shared4.hasFluidValue)(source)) {
          TreeContext.dependencies.add(source);
        }
        const payload = getPayload(source);
        if (payload) {
          (0, import_shared4.each)(payload, (node) => this.add(node));
        }
      }
    };
    var AnimatedArray = class extends AnimatedObject {
      constructor(source) {
        super(source);
      }
      /** @internal */
      static create(source) {
        return new AnimatedArray(source);
      }
      getValue() {
        return this.source.map((node) => node.getValue());
      }
      setValue(source) {
        const payload = this.getPayload();
        if (source.length == payload.length) {
          return payload.map((node, i) => node.setValue(source[i])).some(Boolean);
        }
        super.setValue(source.map(makeAnimated));
        return true;
      }
    };
    function makeAnimated(value) {
      const nodeType = (0, import_shared5.isAnimatedString)(value) ? AnimatedString : AnimatedValue;
      return nodeType.create(value);
    }
    var import_shared6 = require_cjs2();
    function getAnimatedType(value) {
      const parentNode = getAnimated(value);
      return parentNode ? parentNode.constructor : import_shared6.is.arr(value) ? AnimatedArray : (0, import_shared6.isAnimatedString)(value) ? AnimatedString : AnimatedValue;
    }
    var import_shared8 = require_cjs2();
    var React2 = __toESM2(require_react());
    var import_react2 = require_react();
    var import_shared7 = require_cjs2();
    var withAnimated = (Component, host) => {
      const hasInstance = (
        // Function components must use "forwardRef" to avoid being
        // re-rendered on every animation frame.
        !import_shared7.is.fun(Component) || Component.prototype && Component.prototype.isReactComponent
      );
      return (0, import_react2.forwardRef)((givenProps, givenRef) => {
        const instanceRef = (0, import_react2.useRef)(null);
        const ref = hasInstance && // eslint-disable-next-line react-hooks/rules-of-hooks
        (0, import_react2.useCallback)(
          (value) => {
            instanceRef.current = updateRef(givenRef, value);
          },
          [givenRef]
        );
        const [props, deps] = getAnimatedState(givenProps, host);
        const forceUpdate = (0, import_shared7.useForceUpdate)();
        const callback = () => {
          const instance = instanceRef.current;
          if (hasInstance && !instance) {
            return;
          }
          const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;
          if (didUpdate === false) {
            forceUpdate();
          }
        };
        const observer = new PropsObserver(callback, deps);
        const observerRef = (0, import_react2.useRef)();
        (0, import_shared7.useIsomorphicLayoutEffect)(() => {
          observerRef.current = observer;
          (0, import_shared7.each)(deps, (dep) => (0, import_shared7.addFluidObserver)(dep, observer));
          return () => {
            if (observerRef.current) {
              (0, import_shared7.each)(
                observerRef.current.deps,
                (dep) => (0, import_shared7.removeFluidObserver)(dep, observerRef.current)
              );
              import_shared7.raf.cancel(observerRef.current.update);
            }
          };
        });
        (0, import_react2.useEffect)(callback, []);
        (0, import_shared7.useOnce)(() => () => {
          const observer2 = observerRef.current;
          (0, import_shared7.each)(observer2.deps, (dep) => (0, import_shared7.removeFluidObserver)(dep, observer2));
        });
        const usedProps = host.getComponentProps(props.getValue());
        return React2.createElement(Component, { ...usedProps, ref });
      });
    };
    var PropsObserver = class {
      constructor(update, deps) {
        this.update = update;
        this.deps = deps;
      }
      eventObserved(event) {
        if (event.type == "change") {
          import_shared7.raf.write(this.update);
        }
      }
    };
    function getAnimatedState(props, host) {
      const dependencies = /* @__PURE__ */ new Set();
      TreeContext.dependencies = dependencies;
      if (props.style)
        props = {
          ...props,
          style: host.createAnimatedStyle(props.style)
        };
      props = new AnimatedObject(props);
      TreeContext.dependencies = null;
      return [props, dependencies];
    }
    function updateRef(ref, value) {
      if (ref) {
        if (import_shared7.is.fun(ref))
          ref(value);
        else
          ref.current = value;
      }
      return value;
    }
    var cacheKey = Symbol.for("AnimatedComponent");
    var createHost = (components, {
      applyAnimatedValues = () => false,
      createAnimatedStyle = (style) => new AnimatedObject(style),
      getComponentProps = (props) => props
    } = {}) => {
      const hostConfig = {
        applyAnimatedValues,
        createAnimatedStyle,
        getComponentProps
      };
      const animated = (Component) => {
        const displayName = getDisplayName(Component) || "Anonymous";
        if (import_shared8.is.str(Component)) {
          Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));
        } else {
          Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
        }
        Component.displayName = `Animated(${displayName})`;
        return Component;
      };
      (0, import_shared8.eachProp)(components, (Component, key) => {
        if (import_shared8.is.arr(components)) {
          key = getDisplayName(Component);
        }
        animated[key] = animated(Component);
      });
      return {
        animated
      };
    };
    var getDisplayName = (arg) => import_shared8.is.str(arg) ? arg : arg && import_shared8.is.str(arg.displayName) ? arg.displayName : import_shared8.is.fun(arg) && arg.name || null;
  }
});

// node_modules/@react-spring/animated/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@react-spring/animated/dist/cjs/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_spring_animated_development();
    }
  }
});

// node_modules/@react-spring/types/dist/cjs/react-spring_types.development.cjs
var require_react_spring_types_development = __commonJS({
  "node_modules/@react-spring/types/dist/cjs/react-spring_types.development.cjs"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      Any: () => Any
    });
    module.exports = __toCommonJS2(src_exports);
    var Any = class {
    };
  }
});

// node_modules/@react-spring/types/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@react-spring/types/dist/cjs/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_spring_types_development();
    }
  }
});

// node_modules/@react-spring/core/dist/cjs/react-spring_core.development.cjs
var require_react_spring_core_development = __commonJS({
  "node_modules/@react-spring/core/dist/cjs/react-spring_core.development.cjs"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to2, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to2, key) && key !== except)
            __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to2;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      BailSignal: () => BailSignal,
      Controller: () => Controller3,
      FrameValue: () => FrameValue,
      Globals: () => import_shared22.Globals,
      Interpolation: () => Interpolation,
      Spring: () => Spring,
      SpringContext: () => SpringContext,
      SpringRef: () => SpringRef,
      SpringValue: () => SpringValue,
      Trail: () => Trail,
      Transition: () => Transition,
      config: () => config,
      createInterpolator: () => import_shared23.createInterpolator,
      easings: () => import_shared23.easings,
      inferTo: () => inferTo,
      interpolate: () => interpolate,
      to: () => to,
      update: () => update,
      useChain: () => useChain,
      useInView: () => useInView,
      useIsomorphicLayoutEffect: () => import_shared23.useIsomorphicLayoutEffect,
      useReducedMotion: () => import_shared23.useReducedMotion,
      useResize: () => useResize,
      useScroll: () => useScroll2,
      useSpring: () => useSpring,
      useSpringRef: () => useSpringRef,
      useSpringValue: () => useSpringValue,
      useSprings: () => useSprings,
      useTrail: () => useTrail,
      useTransition: () => useTransition
    });
    module.exports = __toCommonJS2(src_exports);
    var import_shared2 = require_cjs2();
    var import_shared = require_cjs2();
    function callProp(value, ...args) {
      return import_shared.is.fun(value) ? value(...args) : value;
    }
    var matchProp = (value, key) => value === true || !!(key && value && (import_shared.is.fun(value) ? value(key) : (0, import_shared.toArray)(value).includes(key)));
    var resolveProp = (prop, key) => import_shared.is.obj(prop) ? key && prop[key] : prop;
    var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
    var noopTransform = (value) => value;
    var getDefaultProps = (props, transform = noopTransform) => {
      let keys = DEFAULT_PROPS;
      if (props.default && props.default !== true) {
        props = props.default;
        keys = Object.keys(props);
      }
      const defaults2 = {};
      for (const key of keys) {
        const value = transform(props[key], key);
        if (!import_shared.is.und(value)) {
          defaults2[key] = value;
        }
      }
      return defaults2;
    };
    var DEFAULT_PROPS = [
      "config",
      "onProps",
      "onStart",
      "onChange",
      "onPause",
      "onResume",
      "onRest"
    ];
    var RESERVED_PROPS = {
      config: 1,
      from: 1,
      to: 1,
      ref: 1,
      loop: 1,
      reset: 1,
      pause: 1,
      cancel: 1,
      reverse: 1,
      immediate: 1,
      default: 1,
      delay: 1,
      onProps: 1,
      onStart: 1,
      onChange: 1,
      onPause: 1,
      onResume: 1,
      onRest: 1,
      onResolve: 1,
      // Transition props
      items: 1,
      trail: 1,
      sort: 1,
      expires: 1,
      initial: 1,
      enter: 1,
      update: 1,
      leave: 1,
      children: 1,
      onDestroyed: 1,
      // Internal props
      keys: 1,
      callId: 1,
      parentId: 1
    };
    function getForwardProps(props) {
      const forward = {};
      let count = 0;
      (0, import_shared.eachProp)(props, (value, prop) => {
        if (!RESERVED_PROPS[prop]) {
          forward[prop] = value;
          count++;
        }
      });
      if (count) {
        return forward;
      }
    }
    function inferTo(props) {
      const to2 = getForwardProps(props);
      if (to2) {
        const out = { to: to2 };
        (0, import_shared.eachProp)(props, (val, key) => key in to2 || (out[key] = val));
        return out;
      }
      return { ...props };
    }
    function computeGoal(value) {
      value = (0, import_shared.getFluidValue)(value);
      return import_shared.is.arr(value) ? value.map(computeGoal) : (0, import_shared.isAnimatedString)(value) ? import_shared.Globals.createStringInterpolator({
        range: [0, 1],
        output: [value, value]
      })(1) : value;
    }
    function hasProps(props) {
      for (const _ in props)
        return true;
      return false;
    }
    function isAsyncTo(to2) {
      return import_shared.is.fun(to2) || import_shared.is.arr(to2) && import_shared.is.obj(to2[0]);
    }
    function detachRefs(ctrl, ref) {
      var _a;
      (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);
      ref == null ? void 0 : ref.delete(ctrl);
    }
    function replaceRef(ctrl, ref) {
      var _a;
      if (ref && ctrl.ref !== ref) {
        (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);
        ref.add(ctrl);
        ctrl.ref = ref;
      }
    }
    function useChain(refs, timeSteps, timeFrame = 1e3) {
      (0, import_shared2.useIsomorphicLayoutEffect)(() => {
        if (timeSteps) {
          let prevDelay = 0;
          (0, import_shared2.each)(refs, (ref, i) => {
            const controllers = ref.current;
            if (controllers.length) {
              let delay2 = timeFrame * timeSteps[i];
              if (isNaN(delay2))
                delay2 = prevDelay;
              else
                prevDelay = delay2;
              (0, import_shared2.each)(controllers, (ctrl) => {
                (0, import_shared2.each)(ctrl.queue, (props) => {
                  const memoizedDelayProp = props.delay;
                  props.delay = (key) => delay2 + callProp(memoizedDelayProp || 0, key);
                });
              });
              ref.start();
            }
          });
        } else {
          let p = Promise.resolve();
          (0, import_shared2.each)(refs, (ref) => {
            const controllers = ref.current;
            if (controllers.length) {
              const queues = controllers.map((ctrl) => {
                const q = ctrl.queue;
                ctrl.queue = [];
                return q;
              });
              p = p.then(() => {
                (0, import_shared2.each)(
                  controllers,
                  (ctrl, i) => (0, import_shared2.each)(queues[i] || [], (update2) => ctrl.queue.push(update2))
                );
                return Promise.all(ref.start());
              });
            }
          });
        }
      });
    }
    var import_shared12 = require_cjs2();
    var import_react2 = require_react();
    var import_shared11 = require_cjs2();
    var import_shared7 = require_cjs2();
    var import_animated2 = require_cjs3();
    var import_shared3 = require_cjs2();
    var config = {
      default: { tension: 170, friction: 26 },
      gentle: { tension: 120, friction: 14 },
      wobbly: { tension: 180, friction: 12 },
      stiff: { tension: 210, friction: 20 },
      slow: { tension: 280, friction: 60 },
      molasses: { tension: 280, friction: 120 }
    };
    var defaults = {
      ...config.default,
      mass: 1,
      damping: 1,
      easing: import_shared3.easings.linear,
      clamp: false
    };
    var AnimationConfig = class {
      constructor() {
        this.velocity = 0;
        Object.assign(this, defaults);
      }
    };
    function mergeConfig(config2, newConfig, defaultConfig) {
      if (defaultConfig) {
        defaultConfig = { ...defaultConfig };
        sanitizeConfig(defaultConfig, newConfig);
        newConfig = { ...defaultConfig, ...newConfig };
      }
      sanitizeConfig(config2, newConfig);
      Object.assign(config2, newConfig);
      for (const key in defaults) {
        if (config2[key] == null) {
          config2[key] = defaults[key];
        }
      }
      let { frequency, damping } = config2;
      const { mass } = config2;
      if (!import_shared3.is.und(frequency)) {
        if (frequency < 0.01)
          frequency = 0.01;
        if (damping < 0)
          damping = 0;
        config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
        config2.friction = 4 * Math.PI * damping * mass / frequency;
      }
      return config2;
    }
    function sanitizeConfig(config2, props) {
      if (!import_shared3.is.und(props.decay)) {
        config2.duration = void 0;
      } else {
        const isTensionConfig = !import_shared3.is.und(props.tension) || !import_shared3.is.und(props.friction);
        if (isTensionConfig || !import_shared3.is.und(props.frequency) || !import_shared3.is.und(props.damping) || !import_shared3.is.und(props.mass)) {
          config2.duration = void 0;
          config2.decay = void 0;
        }
        if (isTensionConfig) {
          config2.frequency = void 0;
        }
      }
    }
    var emptyArray = [];
    var Animation = class {
      constructor() {
        this.changed = false;
        this.values = emptyArray;
        this.toValues = null;
        this.fromValues = emptyArray;
        this.config = new AnimationConfig();
        this.immediate = false;
      }
    };
    var import_shared4 = require_cjs2();
    function scheduleProps(callId, { key, props, defaultProps, state, actions }) {
      return new Promise((resolve, reject) => {
        let delay2;
        let timeout;
        let cancel = matchProp(props.cancel ?? (defaultProps == null ? void 0 : defaultProps.cancel), key);
        if (cancel) {
          onStart();
        } else {
          if (!import_shared4.is.und(props.pause)) {
            state.paused = matchProp(props.pause, key);
          }
          let pause = defaultProps == null ? void 0 : defaultProps.pause;
          if (pause !== true) {
            pause = state.paused || matchProp(pause, key);
          }
          delay2 = callProp(props.delay || 0, key);
          if (pause) {
            state.resumeQueue.add(onResume);
            actions.pause();
          } else {
            actions.resume();
            onResume();
          }
        }
        function onPause() {
          state.resumeQueue.add(onResume);
          state.timeouts.delete(timeout);
          timeout.cancel();
          delay2 = timeout.time - import_shared4.raf.now();
        }
        function onResume() {
          if (delay2 > 0 && !import_shared4.Globals.skipAnimation) {
            state.delayed = true;
            timeout = import_shared4.raf.setTimeout(onStart, delay2);
            state.pauseQueue.add(onPause);
            state.timeouts.add(timeout);
          } else {
            onStart();
          }
        }
        function onStart() {
          if (state.delayed) {
            state.delayed = false;
          }
          state.pauseQueue.delete(onPause);
          state.timeouts.delete(timeout);
          if (callId <= (state.cancelId || 0)) {
            cancel = true;
          }
          try {
            actions.start({ ...props, callId, cancel }, resolve);
          } catch (err) {
            reject(err);
          }
        }
      });
    }
    var import_shared5 = require_cjs2();
    var getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(
      target.get(),
      results.every((result) => result.finished)
    );
    var getNoopResult = (value) => ({
      value,
      noop: true,
      finished: true,
      cancelled: false
    });
    var getFinishedResult = (value, finished, cancelled = false) => ({
      value,
      finished,
      cancelled
    });
    var getCancelledResult = (value) => ({
      value,
      cancelled: true,
      finished: false
    });
    function runAsync(to2, props, state, target) {
      const { callId, parentId, onRest } = props;
      const { asyncTo: prevTo, promise: prevPromise } = state;
      if (!parentId && to2 === prevTo && !props.reset) {
        return prevPromise;
      }
      return state.promise = (async () => {
        state.asyncId = callId;
        state.asyncTo = to2;
        const defaultProps = getDefaultProps(
          props,
          (value, key) => (
            // The `onRest` prop is only called when the `runAsync` promise is resolved.
            key === "onRest" ? void 0 : value
          )
        );
        let preventBail;
        let bail;
        const bailPromise = new Promise(
          (resolve, reject) => (preventBail = resolve, bail = reject)
        );
        const bailIfEnded = (bailSignal) => {
          const bailResult = (
            // The `cancel` prop or `stop` method was used.
            callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.
            callId !== state.asyncId && getFinishedResult(target, false)
          );
          if (bailResult) {
            bailSignal.result = bailResult;
            bail(bailSignal);
            throw bailSignal;
          }
        };
        const animate = (arg1, arg2) => {
          const bailSignal = new BailSignal();
          const skipAnimationSignal = new SkipAnimationSignal();
          return (async () => {
            if (import_shared5.Globals.skipAnimation) {
              stopAsync(state);
              skipAnimationSignal.result = getFinishedResult(target, false);
              bail(skipAnimationSignal);
              throw skipAnimationSignal;
            }
            bailIfEnded(bailSignal);
            const props2 = import_shared5.is.obj(arg1) ? { ...arg1 } : { ...arg2, to: arg1 };
            props2.parentId = callId;
            (0, import_shared5.eachProp)(defaultProps, (value, key) => {
              if (import_shared5.is.und(props2[key])) {
                props2[key] = value;
              }
            });
            const result2 = await target.start(props2);
            bailIfEnded(bailSignal);
            if (state.paused) {
              await new Promise((resume) => {
                state.resumeQueue.add(resume);
              });
            }
            return result2;
          })();
        };
        let result;
        if (import_shared5.Globals.skipAnimation) {
          stopAsync(state);
          return getFinishedResult(target, false);
        }
        try {
          let animating;
          if (import_shared5.is.arr(to2)) {
            animating = (async (queue) => {
              for (const props2 of queue) {
                await animate(props2);
              }
            })(to2);
          } else {
            animating = Promise.resolve(to2(animate, target.stop.bind(target)));
          }
          await Promise.all([animating.then(preventBail), bailPromise]);
          result = getFinishedResult(target.get(), true, false);
        } catch (err) {
          if (err instanceof BailSignal) {
            result = err.result;
          } else if (err instanceof SkipAnimationSignal) {
            result = err.result;
          } else {
            throw err;
          }
        } finally {
          if (callId == state.asyncId) {
            state.asyncId = parentId;
            state.asyncTo = parentId ? prevTo : void 0;
            state.promise = parentId ? prevPromise : void 0;
          }
        }
        if (import_shared5.is.fun(onRest)) {
          import_shared5.raf.batchedUpdates(() => {
            onRest(result, target, target.item);
          });
        }
        return result;
      })();
    }
    function stopAsync(state, cancelId) {
      (0, import_shared5.flush)(state.timeouts, (t) => t.cancel());
      state.pauseQueue.clear();
      state.resumeQueue.clear();
      state.asyncId = state.asyncTo = state.promise = void 0;
      if (cancelId)
        state.cancelId = cancelId;
    }
    var BailSignal = class extends Error {
      constructor() {
        super(
          "An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."
        );
      }
    };
    var SkipAnimationSignal = class extends Error {
      constructor() {
        super("SkipAnimationSignal");
      }
    };
    var import_shared6 = require_cjs2();
    var import_animated = require_cjs3();
    var isFrameValue = (value) => value instanceof FrameValue;
    var nextId = 1;
    var FrameValue = class extends import_shared6.FluidValue {
      constructor() {
        super(...arguments);
        this.id = nextId++;
        this._priority = 0;
      }
      get priority() {
        return this._priority;
      }
      set priority(priority) {
        if (this._priority != priority) {
          this._priority = priority;
          this._onPriorityChange(priority);
        }
      }
      /** Get the current value */
      get() {
        const node = (0, import_animated.getAnimated)(this);
        return node && node.getValue();
      }
      /** Create a spring that maps our value to another value */
      to(...args) {
        return import_shared6.Globals.to(this, args);
      }
      /** @deprecated Use the `to` method instead. */
      interpolate(...args) {
        (0, import_shared6.deprecateInterpolate)();
        return import_shared6.Globals.to(this, args);
      }
      toJSON() {
        return this.get();
      }
      observerAdded(count) {
        if (count == 1)
          this._attach();
      }
      observerRemoved(count) {
        if (count == 0)
          this._detach();
      }
      /** Called when the first child is added. */
      _attach() {
      }
      /** Called when the last child is removed. */
      _detach() {
      }
      /** Tell our children about our new value */
      _onChange(value, idle = false) {
        (0, import_shared6.callFluidObservers)(this, {
          type: "change",
          parent: this,
          value,
          idle
        });
      }
      /** Tell our children about our new priority */
      _onPriorityChange(priority) {
        if (!this.idle) {
          import_shared6.frameLoop.sort(this);
        }
        (0, import_shared6.callFluidObservers)(this, {
          type: "priority",
          parent: this,
          priority
        });
      }
    };
    var $P = Symbol.for("SpringPhase");
    var HAS_ANIMATED = 1;
    var IS_ANIMATING = 2;
    var IS_PAUSED = 4;
    var hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
    var isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
    var isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
    var setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
    var setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;
    var SpringValue = class extends FrameValue {
      constructor(arg1, arg2) {
        super();
        this.animation = new Animation();
        this.defaultProps = {};
        this._state = {
          paused: false,
          delayed: false,
          pauseQueue: /* @__PURE__ */ new Set(),
          resumeQueue: /* @__PURE__ */ new Set(),
          timeouts: /* @__PURE__ */ new Set()
        };
        this._pendingCalls = /* @__PURE__ */ new Set();
        this._lastCallId = 0;
        this._lastToId = 0;
        this._memoizedDuration = 0;
        if (!import_shared7.is.und(arg1) || !import_shared7.is.und(arg2)) {
          const props = import_shared7.is.obj(arg1) ? { ...arg1 } : { ...arg2, from: arg1 };
          if (import_shared7.is.und(props.default)) {
            props.default = true;
          }
          this.start(props);
        }
      }
      /** Equals true when not advancing on each frame. */
      get idle() {
        return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
      }
      get goal() {
        return (0, import_shared7.getFluidValue)(this.animation.to);
      }
      get velocity() {
        const node = (0, import_animated2.getAnimated)(this);
        return node instanceof import_animated2.AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
      }
      /**
       * When true, this value has been animated at least once.
       */
      get hasAnimated() {
        return hasAnimated(this);
      }
      /**
       * When true, this value has an unfinished animation,
       * which is either active or paused.
       */
      get isAnimating() {
        return isAnimating(this);
      }
      /**
       * When true, all current and future animations are paused.
       */
      get isPaused() {
        return isPaused(this);
      }
      /**
       *
       *
       */
      get isDelayed() {
        return this._state.delayed;
      }
      /** Advance the current animation by a number of milliseconds */
      advance(dt) {
        let idle = true;
        let changed = false;
        const anim = this.animation;
        let { toValues } = anim;
        const { config: config2 } = anim;
        const payload = (0, import_animated2.getPayload)(anim.to);
        if (!payload && (0, import_shared7.hasFluidValue)(anim.to)) {
          toValues = (0, import_shared7.toArray)((0, import_shared7.getFluidValue)(anim.to));
        }
        anim.values.forEach((node2, i) => {
          if (node2.done)
            return;
          const to2 = (
            // Animated strings always go from 0 to 1.
            node2.constructor == import_animated2.AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i]
          );
          let finished = anim.immediate;
          let position = to2;
          if (!finished) {
            position = node2.lastPosition;
            if (config2.tension <= 0) {
              node2.done = true;
              return;
            }
            let elapsed = node2.elapsedTime += dt;
            const from = anim.fromValues[i];
            const v0 = node2.v0 != null ? node2.v0 : node2.v0 = import_shared7.is.arr(config2.velocity) ? config2.velocity[i] : config2.velocity;
            let velocity;
            const precision = config2.precision || (from == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from) * 1e-3));
            if (!import_shared7.is.und(config2.duration)) {
              let p = 1;
              if (config2.duration > 0) {
                if (this._memoizedDuration !== config2.duration) {
                  this._memoizedDuration = config2.duration;
                  if (node2.durationProgress > 0) {
                    node2.elapsedTime = config2.duration * node2.durationProgress;
                    elapsed = node2.elapsedTime += dt;
                  }
                }
                p = (config2.progress || 0) + elapsed / this._memoizedDuration;
                p = p > 1 ? 1 : p < 0 ? 0 : p;
                node2.durationProgress = p;
              }
              position = from + config2.easing(p) * (to2 - from);
              velocity = (position - node2.lastPosition) / dt;
              finished = p == 1;
            } else if (config2.decay) {
              const decay = config2.decay === true ? 0.998 : config2.decay;
              const e = Math.exp(-(1 - decay) * elapsed);
              position = from + v0 / (1 - decay) * (1 - e);
              finished = Math.abs(node2.lastPosition - position) <= precision;
              velocity = v0 * e;
            } else {
              velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;
              const restVelocity = config2.restVelocity || precision / 10;
              const bounceFactor = config2.clamp ? 0 : config2.bounce;
              const canBounce = !import_shared7.is.und(bounceFactor);
              const isGrowing = from == to2 ? node2.v0 > 0 : from < to2;
              let isMoving;
              let isBouncing = false;
              const step = 1;
              const numSteps = Math.ceil(dt / step);
              for (let n = 0; n < numSteps; ++n) {
                isMoving = Math.abs(velocity) > restVelocity;
                if (!isMoving) {
                  finished = Math.abs(to2 - position) <= precision;
                  if (finished) {
                    break;
                  }
                }
                if (canBounce) {
                  isBouncing = position == to2 || position > to2 == isGrowing;
                  if (isBouncing) {
                    velocity = -velocity * bounceFactor;
                    position = to2;
                  }
                }
                const springForce = -config2.tension * 1e-6 * (position - to2);
                const dampingForce = -config2.friction * 1e-3 * velocity;
                const acceleration = (springForce + dampingForce) / config2.mass;
                velocity = velocity + acceleration * step;
                position = position + velocity * step;
              }
            }
            node2.lastVelocity = velocity;
            if (Number.isNaN(position)) {
              console.warn(`Got NaN while animating:`, this);
              finished = true;
            }
          }
          if (payload && !payload[i].done) {
            finished = false;
          }
          if (finished) {
            node2.done = true;
          } else {
            idle = false;
          }
          if (node2.setValue(position, config2.round)) {
            changed = true;
          }
        });
        const node = (0, import_animated2.getAnimated)(this);
        const currVal = node.getValue();
        if (idle) {
          const finalVal = (0, import_shared7.getFluidValue)(anim.to);
          if ((currVal !== finalVal || changed) && !config2.decay) {
            node.setValue(finalVal);
            this._onChange(finalVal);
          } else if (changed && config2.decay) {
            this._onChange(currVal);
          }
          this._stop();
        } else if (changed) {
          this._onChange(currVal);
        }
      }
      /** Set the current value, while stopping the current animation */
      set(value) {
        import_shared7.raf.batchedUpdates(() => {
          this._stop();
          this._focus(value);
          this._set(value);
        });
        return this;
      }
      /**
       * Freeze the active animation in time, as well as any updates merged
       * before `resume` is called.
       */
      pause() {
        this._update({ pause: true });
      }
      /** Resume the animation if paused. */
      resume() {
        this._update({ pause: false });
      }
      /** Skip to the end of the current animation. */
      finish() {
        if (isAnimating(this)) {
          const { to: to2, config: config2 } = this.animation;
          import_shared7.raf.batchedUpdates(() => {
            this._onStart();
            if (!config2.decay) {
              this._set(to2, false);
            }
            this._stop();
          });
        }
        return this;
      }
      /** Push props into the pending queue. */
      update(props) {
        const queue = this.queue || (this.queue = []);
        queue.push(props);
        return this;
      }
      start(to2, arg2) {
        let queue;
        if (!import_shared7.is.und(to2)) {
          queue = [import_shared7.is.obj(to2) ? to2 : { ...arg2, to: to2 }];
        } else {
          queue = this.queue || [];
          this.queue = [];
        }
        return Promise.all(
          queue.map((props) => {
            const up = this._update(props);
            return up;
          })
        ).then((results) => getCombinedResult(this, results));
      }
      /**
       * Stop the current animation, and cancel any delayed updates.
       *
       * Pass `true` to call `onRest` with `cancelled: true`.
       */
      stop(cancel) {
        const { to: to2 } = this.animation;
        this._focus(this.get());
        stopAsync(this._state, cancel && this._lastCallId);
        import_shared7.raf.batchedUpdates(() => this._stop(to2, cancel));
        return this;
      }
      /** Restart the animation. */
      reset() {
        this._update({ reset: true });
      }
      /** @internal */
      eventObserved(event) {
        if (event.type == "change") {
          this._start();
        } else if (event.type == "priority") {
          this.priority = event.priority + 1;
        }
      }
      /**
       * Parse the `to` and `from` range from the given `props` object.
       *
       * This also ensures the initial value is available to animated components
       * during the render phase.
       */
      _prepareNode(props) {
        const key = this.key || "";
        let { to: to2, from } = props;
        to2 = import_shared7.is.obj(to2) ? to2[key] : to2;
        if (to2 == null || isAsyncTo(to2)) {
          to2 = void 0;
        }
        from = import_shared7.is.obj(from) ? from[key] : from;
        if (from == null) {
          from = void 0;
        }
        const range = { to: to2, from };
        if (!hasAnimated(this)) {
          if (props.reverse)
            [to2, from] = [from, to2];
          from = (0, import_shared7.getFluidValue)(from);
          if (!import_shared7.is.und(from)) {
            this._set(from);
          } else if (!(0, import_animated2.getAnimated)(this)) {
            this._set(to2);
          }
        }
        return range;
      }
      /** Every update is processed by this method before merging. */
      _update({ ...props }, isLoop) {
        const { key, defaultProps } = this;
        if (props.default)
          Object.assign(
            defaultProps,
            getDefaultProps(
              props,
              (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value
            )
          );
        mergeActiveFn(this, props, "onProps");
        sendEvent(this, "onProps", props, this);
        const range = this._prepareNode(props);
        if (Object.isFrozen(this)) {
          throw Error(
            "Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?"
          );
        }
        const state = this._state;
        return scheduleProps(++this._lastCallId, {
          key,
          props,
          defaultProps,
          state,
          actions: {
            pause: () => {
              if (!isPaused(this)) {
                setPausedBit(this, true);
                (0, import_shared7.flushCalls)(state.pauseQueue);
                sendEvent(
                  this,
                  "onPause",
                  getFinishedResult(this, checkFinished(this, this.animation.to)),
                  this
                );
              }
            },
            resume: () => {
              if (isPaused(this)) {
                setPausedBit(this, false);
                if (isAnimating(this)) {
                  this._resume();
                }
                (0, import_shared7.flushCalls)(state.resumeQueue);
                sendEvent(
                  this,
                  "onResume",
                  getFinishedResult(this, checkFinished(this, this.animation.to)),
                  this
                );
              }
            },
            start: this._merge.bind(this, range)
          }
        }).then((result) => {
          if (props.loop && result.finished && !(isLoop && result.noop)) {
            const nextProps = createLoopUpdate(props);
            if (nextProps) {
              return this._update(nextProps, true);
            }
          }
          return result;
        });
      }
      /** Merge props into the current animation */
      _merge(range, props, resolve) {
        if (props.cancel) {
          this.stop(true);
          return resolve(getCancelledResult(this));
        }
        const hasToProp = !import_shared7.is.und(range.to);
        const hasFromProp = !import_shared7.is.und(range.from);
        if (hasToProp || hasFromProp) {
          if (props.callId > this._lastToId) {
            this._lastToId = props.callId;
          } else {
            return resolve(getCancelledResult(this));
          }
        }
        const { key, defaultProps, animation: anim } = this;
        const { to: prevTo, from: prevFrom } = anim;
        let { to: to2 = prevTo, from = prevFrom } = range;
        if (hasFromProp && !hasToProp && (!props.default || import_shared7.is.und(to2))) {
          to2 = from;
        }
        if (props.reverse)
          [to2, from] = [from, to2];
        const hasFromChanged = !(0, import_shared7.isEqual)(from, prevFrom);
        if (hasFromChanged) {
          anim.from = from;
        }
        from = (0, import_shared7.getFluidValue)(from);
        const hasToChanged = !(0, import_shared7.isEqual)(to2, prevTo);
        if (hasToChanged) {
          this._focus(to2);
        }
        const hasAsyncTo = isAsyncTo(props.to);
        const { config: config2 } = anim;
        const { decay, velocity } = config2;
        if (hasToProp || hasFromProp) {
          config2.velocity = 0;
        }
        if (props.config && !hasAsyncTo) {
          mergeConfig(
            config2,
            callProp(props.config, key),
            // Avoid calling the same "config" prop twice.
            props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0
          );
        }
        let node = (0, import_animated2.getAnimated)(this);
        if (!node || import_shared7.is.und(to2)) {
          return resolve(getFinishedResult(this, true));
        }
        const reset = (
          // When `reset` is undefined, the `from` prop implies `reset: true`,
          // except for declarative updates. When `reset` is defined, there
          // must exist a value to animate from.
          import_shared7.is.und(props.reset) ? hasFromProp && !props.default : !import_shared7.is.und(from) && matchProp(props.reset, key)
        );
        const value = reset ? from : this.get();
        const goal = computeGoal(to2);
        const isAnimatable = import_shared7.is.num(goal) || import_shared7.is.arr(goal) || (0, import_shared7.isAnimatedString)(goal);
        const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));
        if (hasToChanged) {
          const nodeType = (0, import_animated2.getAnimatedType)(to2);
          if (nodeType !== node.constructor) {
            if (immediate) {
              node = this._set(goal);
            } else
              throw Error(
                `Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`
              );
          }
        }
        const goalType = node.constructor;
        let started = (0, import_shared7.hasFluidValue)(to2);
        let finished = false;
        if (!started) {
          const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
          if (hasToChanged || hasValueChanged) {
            finished = (0, import_shared7.isEqual)(computeGoal(value), goal);
            started = !finished;
          }
          if (!(0, import_shared7.isEqual)(anim.immediate, immediate) && !immediate || !(0, import_shared7.isEqual)(config2.decay, decay) || !(0, import_shared7.isEqual)(config2.velocity, velocity)) {
            started = true;
          }
        }
        if (finished && isAnimating(this)) {
          if (anim.changed && !reset) {
            started = true;
          } else if (!started) {
            this._stop(prevTo);
          }
        }
        if (!hasAsyncTo) {
          if (started || (0, import_shared7.hasFluidValue)(prevTo)) {
            anim.values = node.getPayload();
            anim.toValues = (0, import_shared7.hasFluidValue)(to2) ? null : goalType == import_animated2.AnimatedString ? [1] : (0, import_shared7.toArray)(goal);
          }
          if (anim.immediate != immediate) {
            anim.immediate = immediate;
            if (!immediate && !reset) {
              this._set(prevTo);
            }
          }
          if (started) {
            const { onRest } = anim;
            (0, import_shared7.each)(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
            const result = getFinishedResult(this, checkFinished(this, prevTo));
            (0, import_shared7.flushCalls)(this._pendingCalls, result);
            this._pendingCalls.add(resolve);
            if (anim.changed)
              import_shared7.raf.batchedUpdates(() => {
                var _a;
                anim.changed = !reset;
                onRest == null ? void 0 : onRest(result, this);
                if (reset) {
                  callProp(defaultProps.onRest, result);
                } else {
                  (_a = anim.onStart) == null ? void 0 : _a.call(anim, result, this);
                }
              });
          }
        }
        if (reset) {
          this._set(value);
        }
        if (hasAsyncTo) {
          resolve(runAsync(props.to, props, this._state, this));
        } else if (started) {
          this._start();
        } else if (isAnimating(this) && !hasToChanged) {
          this._pendingCalls.add(resolve);
        } else {
          resolve(getNoopResult(value));
        }
      }
      /** Update the `animation.to` value, which might be a `FluidValue` */
      _focus(value) {
        const anim = this.animation;
        if (value !== anim.to) {
          if ((0, import_shared7.getFluidObservers)(this)) {
            this._detach();
          }
          anim.to = value;
          if ((0, import_shared7.getFluidObservers)(this)) {
            this._attach();
          }
        }
      }
      _attach() {
        let priority = 0;
        const { to: to2 } = this.animation;
        if ((0, import_shared7.hasFluidValue)(to2)) {
          (0, import_shared7.addFluidObserver)(to2, this);
          if (isFrameValue(to2)) {
            priority = to2.priority + 1;
          }
        }
        this.priority = priority;
      }
      _detach() {
        const { to: to2 } = this.animation;
        if ((0, import_shared7.hasFluidValue)(to2)) {
          (0, import_shared7.removeFluidObserver)(to2, this);
        }
      }
      /**
       * Update the current value from outside the frameloop,
       * and return the `Animated` node.
       */
      _set(arg, idle = true) {
        const value = (0, import_shared7.getFluidValue)(arg);
        if (!import_shared7.is.und(value)) {
          const oldNode = (0, import_animated2.getAnimated)(this);
          if (!oldNode || !(0, import_shared7.isEqual)(value, oldNode.getValue())) {
            const nodeType = (0, import_animated2.getAnimatedType)(value);
            if (!oldNode || oldNode.constructor != nodeType) {
              (0, import_animated2.setAnimated)(this, nodeType.create(value));
            } else {
              oldNode.setValue(value);
            }
            if (oldNode) {
              import_shared7.raf.batchedUpdates(() => {
                this._onChange(value, idle);
              });
            }
          }
        }
        return (0, import_animated2.getAnimated)(this);
      }
      _onStart() {
        const anim = this.animation;
        if (!anim.changed) {
          anim.changed = true;
          sendEvent(
            this,
            "onStart",
            getFinishedResult(this, checkFinished(this, anim.to)),
            this
          );
        }
      }
      _onChange(value, idle) {
        if (!idle) {
          this._onStart();
          callProp(this.animation.onChange, value, this);
        }
        callProp(this.defaultProps.onChange, value, this);
        super._onChange(value, idle);
      }
      // This method resets the animation state (even if already animating) to
      // ensure the latest from/to range is used, and it also ensures this spring
      // is added to the frameloop.
      _start() {
        const anim = this.animation;
        (0, import_animated2.getAnimated)(this).reset((0, import_shared7.getFluidValue)(anim.to));
        if (!anim.immediate) {
          anim.fromValues = anim.values.map((node) => node.lastPosition);
        }
        if (!isAnimating(this)) {
          setActiveBit(this, true);
          if (!isPaused(this)) {
            this._resume();
          }
        }
      }
      _resume() {
        if (import_shared7.Globals.skipAnimation) {
          this.finish();
        } else {
          import_shared7.frameLoop.start(this);
        }
      }
      /**
       * Exit the frameloop and notify `onRest` listeners.
       *
       * Always wrap `_stop` calls with `batchedUpdates`.
       */
      _stop(goal, cancel) {
        if (isAnimating(this)) {
          setActiveBit(this, false);
          const anim = this.animation;
          (0, import_shared7.each)(anim.values, (node) => {
            node.done = true;
          });
          if (anim.toValues) {
            anim.onChange = anim.onPause = anim.onResume = void 0;
          }
          (0, import_shared7.callFluidObservers)(this, {
            type: "idle",
            parent: this
          });
          const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal ?? anim.to));
          (0, import_shared7.flushCalls)(this._pendingCalls, result);
          if (anim.changed) {
            anim.changed = false;
            sendEvent(this, "onRest", result, this);
          }
        }
      }
    };
    function checkFinished(target, to2) {
      const goal = computeGoal(to2);
      const value = computeGoal(target.get());
      return (0, import_shared7.isEqual)(value, goal);
    }
    function createLoopUpdate(props, loop = props.loop, to2 = props.to) {
      const loopRet = callProp(loop);
      if (loopRet) {
        const overrides = loopRet !== true && inferTo(loopRet);
        const reverse = (overrides || props).reverse;
        const reset = !overrides || overrides.reset;
        return createUpdate({
          ...props,
          loop,
          // Avoid updating default props when looping.
          default: false,
          // Never loop the `pause` prop.
          pause: void 0,
          // For the "reverse" prop to loop as expected, the "to" prop
          // must be undefined. The "reverse" prop is ignored when the
          // "to" prop is an array or function.
          to: !reverse || isAsyncTo(to2) ? to2 : void 0,
          // Ignore the "from" prop except on reset.
          from: reset ? props.from : void 0,
          reset,
          // The "loop" prop can return a "useSpring" props object to
          // override any of the original props.
          ...overrides
        });
      }
    }
    function createUpdate(props) {
      const { to: to2, from } = props = inferTo(props);
      const keys = /* @__PURE__ */ new Set();
      if (import_shared7.is.obj(to2))
        findDefined(to2, keys);
      if (import_shared7.is.obj(from))
        findDefined(from, keys);
      props.keys = keys.size ? Array.from(keys) : null;
      return props;
    }
    function declareUpdate(props) {
      const update2 = createUpdate(props);
      if (import_shared7.is.und(update2.default)) {
        update2.default = getDefaultProps(update2);
      }
      return update2;
    }
    function findDefined(values, keys) {
      (0, import_shared7.eachProp)(values, (value, key) => value != null && keys.add(key));
    }
    var ACTIVE_EVENTS = [
      "onStart",
      "onRest",
      "onChange",
      "onPause",
      "onResume"
    ];
    function mergeActiveFn(target, props, type) {
      target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;
    }
    function sendEvent(target, type, ...args) {
      var _a, _b, _c, _d;
      (_b = (_a = target.animation)[type]) == null ? void 0 : _b.call(_a, ...args);
      (_d = (_c = target.defaultProps)[type]) == null ? void 0 : _d.call(_c, ...args);
    }
    var import_shared8 = require_cjs2();
    var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
    var nextId2 = 1;
    var Controller3 = class {
      constructor(props, flush3) {
        this.id = nextId2++;
        this.springs = {};
        this.queue = [];
        this._lastAsyncId = 0;
        this._active = /* @__PURE__ */ new Set();
        this._changed = /* @__PURE__ */ new Set();
        this._started = false;
        this._state = {
          paused: false,
          pauseQueue: /* @__PURE__ */ new Set(),
          resumeQueue: /* @__PURE__ */ new Set(),
          timeouts: /* @__PURE__ */ new Set()
        };
        this._events = {
          onStart: /* @__PURE__ */ new Map(),
          onChange: /* @__PURE__ */ new Map(),
          onRest: /* @__PURE__ */ new Map()
        };
        this._onFrame = this._onFrame.bind(this);
        if (flush3) {
          this._flush = flush3;
        }
        if (props) {
          this.start({ default: true, ...props });
        }
      }
      /**
       * Equals `true` when no spring values are in the frameloop, and
       * no async animation is currently active.
       */
      get idle() {
        return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
          return spring.idle && !spring.isDelayed && !spring.isPaused;
        });
      }
      get item() {
        return this._item;
      }
      set item(item) {
        this._item = item;
      }
      /** Get the current values of our springs */
      get() {
        const values = {};
        this.each((spring, key) => values[key] = spring.get());
        return values;
      }
      /** Set the current values without animating. */
      set(values) {
        for (const key in values) {
          const value = values[key];
          if (!import_shared8.is.und(value)) {
            this.springs[key].set(value);
          }
        }
      }
      /** Push an update onto the queue of each value. */
      update(props) {
        if (props) {
          this.queue.push(createUpdate(props));
        }
        return this;
      }
      /**
       * Start the queued animations for every spring, and resolve the returned
       * promise once all queued animations have finished or been cancelled.
       *
       * When you pass a queue (instead of nothing), that queue is used instead of
       * the queued animations added with the `update` method, which are left alone.
       */
      start(props) {
        let { queue } = this;
        if (props) {
          queue = (0, import_shared8.toArray)(props).map(createUpdate);
        } else {
          this.queue = [];
        }
        if (this._flush) {
          return this._flush(this, queue);
        }
        prepareKeys(this, queue);
        return flushUpdateQueue(this, queue);
      }
      /** @internal */
      stop(arg, keys) {
        if (arg !== !!arg) {
          keys = arg;
        }
        if (keys) {
          const springs = this.springs;
          (0, import_shared8.each)((0, import_shared8.toArray)(keys), (key) => springs[key].stop(!!arg));
        } else {
          stopAsync(this._state, this._lastAsyncId);
          this.each((spring) => spring.stop(!!arg));
        }
        return this;
      }
      /** Freeze the active animation in time */
      pause(keys) {
        if (import_shared8.is.und(keys)) {
          this.start({ pause: true });
        } else {
          const springs = this.springs;
          (0, import_shared8.each)((0, import_shared8.toArray)(keys), (key) => springs[key].pause());
        }
        return this;
      }
      /** Resume the animation if paused. */
      resume(keys) {
        if (import_shared8.is.und(keys)) {
          this.start({ pause: false });
        } else {
          const springs = this.springs;
          (0, import_shared8.each)((0, import_shared8.toArray)(keys), (key) => springs[key].resume());
        }
        return this;
      }
      /** Call a function once per spring value */
      each(iterator) {
        (0, import_shared8.eachProp)(this.springs, iterator);
      }
      /** @internal Called at the end of every animation frame */
      _onFrame() {
        const { onStart, onChange, onRest } = this._events;
        const active = this._active.size > 0;
        const changed = this._changed.size > 0;
        if (active && !this._started || changed && !this._started) {
          this._started = true;
          (0, import_shared8.flush)(onStart, ([onStart2, result]) => {
            result.value = this.get();
            onStart2(result, this, this._item);
          });
        }
        const idle = !active && this._started;
        const values = changed || idle && onRest.size ? this.get() : null;
        if (changed && onChange.size) {
          (0, import_shared8.flush)(onChange, ([onChange2, result]) => {
            result.value = values;
            onChange2(result, this, this._item);
          });
        }
        if (idle) {
          this._started = false;
          (0, import_shared8.flush)(onRest, ([onRest2, result]) => {
            result.value = values;
            onRest2(result, this, this._item);
          });
        }
      }
      /** @internal */
      eventObserved(event) {
        if (event.type == "change") {
          this._changed.add(event.parent);
          if (!event.idle) {
            this._active.add(event.parent);
          }
        } else if (event.type == "idle") {
          this._active.delete(event.parent);
        } else
          return;
        import_shared8.raf.onFrame(this._onFrame);
      }
    };
    function flushUpdateQueue(ctrl, queue) {
      return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then(
        (results) => getCombinedResult(ctrl, results)
      );
    }
    async function flushUpdate(ctrl, props, isLoop) {
      const { keys, to: to2, from, loop, onRest, onResolve } = props;
      const defaults2 = import_shared8.is.obj(props.default) && props.default;
      if (loop) {
        props.loop = false;
      }
      if (to2 === false)
        props.to = null;
      if (from === false)
        props.from = null;
      const asyncTo = import_shared8.is.arr(to2) || import_shared8.is.fun(to2) ? to2 : void 0;
      if (asyncTo) {
        props.to = void 0;
        props.onRest = void 0;
        if (defaults2) {
          defaults2.onRest = void 0;
        }
      } else {
        (0, import_shared8.each)(BATCHED_EVENTS, (key) => {
          const handler = props[key];
          if (import_shared8.is.fun(handler)) {
            const queue = ctrl["_events"][key];
            props[key] = ({ finished, cancelled }) => {
              const result2 = queue.get(handler);
              if (result2) {
                if (!finished)
                  result2.finished = false;
                if (cancelled)
                  result2.cancelled = true;
              } else {
                queue.set(handler, {
                  value: null,
                  finished: finished || false,
                  cancelled: cancelled || false
                });
              }
            };
            if (defaults2) {
              defaults2[key] = props[key];
            }
          }
        });
      }
      const state = ctrl["_state"];
      if (props.pause === !state.paused) {
        state.paused = props.pause;
        (0, import_shared8.flushCalls)(props.pause ? state.pauseQueue : state.resumeQueue);
      } else if (state.paused) {
        props.pause = true;
      }
      const promises = (keys || Object.keys(ctrl.springs)).map(
        (key) => ctrl.springs[key].start(props)
      );
      const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
      if (asyncTo || cancel && state.asyncId) {
        promises.push(
          scheduleProps(++ctrl["_lastAsyncId"], {
            props,
            state,
            actions: {
              pause: import_shared8.noop,
              resume: import_shared8.noop,
              start(props2, resolve) {
                if (cancel) {
                  stopAsync(state, ctrl["_lastAsyncId"]);
                  resolve(getCancelledResult(ctrl));
                } else {
                  props2.onRest = onRest;
                  resolve(
                    runAsync(
                      asyncTo,
                      props2,
                      state,
                      ctrl
                    )
                  );
                }
              }
            }
          })
        );
      }
      if (state.paused) {
        await new Promise((resume) => {
          state.resumeQueue.add(resume);
        });
      }
      const result = getCombinedResult(ctrl, await Promise.all(promises));
      if (loop && result.finished && !(isLoop && result.noop)) {
        const nextProps = createLoopUpdate(props, loop, to2);
        if (nextProps) {
          prepareKeys(ctrl, [nextProps]);
          return flushUpdate(ctrl, nextProps, true);
        }
      }
      if (onResolve) {
        import_shared8.raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
      }
      return result;
    }
    function getSprings(ctrl, props) {
      const springs = { ...ctrl.springs };
      if (props) {
        (0, import_shared8.each)((0, import_shared8.toArray)(props), (props2) => {
          if (import_shared8.is.und(props2.keys)) {
            props2 = createUpdate(props2);
          }
          if (!import_shared8.is.obj(props2.to)) {
            props2 = { ...props2, to: void 0 };
          }
          prepareSprings(springs, props2, (key) => {
            return createSpring(key);
          });
        });
      }
      setSprings(ctrl, springs);
      return springs;
    }
    function setSprings(ctrl, springs) {
      (0, import_shared8.eachProp)(springs, (spring, key) => {
        if (!ctrl.springs[key]) {
          ctrl.springs[key] = spring;
          (0, import_shared8.addFluidObserver)(spring, ctrl);
        }
      });
    }
    function createSpring(key, observer) {
      const spring = new SpringValue();
      spring.key = key;
      if (observer) {
        (0, import_shared8.addFluidObserver)(spring, observer);
      }
      return spring;
    }
    function prepareSprings(springs, props, create) {
      if (props.keys) {
        (0, import_shared8.each)(props.keys, (key) => {
          const spring = springs[key] || (springs[key] = create(key));
          spring["_prepareNode"](props);
        });
      }
    }
    function prepareKeys(ctrl, queue) {
      (0, import_shared8.each)(queue, (props) => {
        prepareSprings(ctrl.springs, props, (key) => {
          return createSpring(key, ctrl);
        });
      });
    }
    var React2 = __toESM2(require_react());
    var import_react3 = require_react();
    var import_shared9 = require_cjs2();
    var SpringContext = ({
      children,
      ...props
    }) => {
      const inherited = (0, import_react3.useContext)(ctx);
      const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
      props = (0, import_shared9.useMemoOne)(() => ({ pause, immediate }), [pause, immediate]);
      const { Provider } = ctx;
      return React2.createElement(Provider, { value: props }, children);
    };
    var ctx = makeContext(SpringContext, {});
    SpringContext.Provider = ctx.Provider;
    SpringContext.Consumer = ctx.Consumer;
    function makeContext(target, init) {
      Object.assign(target, React2.createContext(init));
      target.Provider._context = target;
      target.Consumer._context = target;
      return target;
    }
    var import_shared10 = require_cjs2();
    var SpringRef = () => {
      const current = [];
      const SpringRef2 = function(props) {
        (0, import_shared10.deprecateDirectCall)();
        const results = [];
        (0, import_shared10.each)(current, (ctrl, i) => {
          if (import_shared10.is.und(props)) {
            results.push(ctrl.start());
          } else {
            const update2 = _getProps(props, ctrl, i);
            if (update2) {
              results.push(ctrl.start(update2));
            }
          }
        });
        return results;
      };
      SpringRef2.current = current;
      SpringRef2.add = function(ctrl) {
        if (!current.includes(ctrl)) {
          current.push(ctrl);
        }
      };
      SpringRef2.delete = function(ctrl) {
        const i = current.indexOf(ctrl);
        if (~i)
          current.splice(i, 1);
      };
      SpringRef2.pause = function() {
        (0, import_shared10.each)(current, (ctrl) => ctrl.pause(...arguments));
        return this;
      };
      SpringRef2.resume = function() {
        (0, import_shared10.each)(current, (ctrl) => ctrl.resume(...arguments));
        return this;
      };
      SpringRef2.set = function(values) {
        (0, import_shared10.each)(current, (ctrl, i) => {
          const update2 = import_shared10.is.fun(values) ? values(i, ctrl) : values;
          if (update2) {
            ctrl.set(update2);
          }
        });
      };
      SpringRef2.start = function(props) {
        const results = [];
        (0, import_shared10.each)(current, (ctrl, i) => {
          if (import_shared10.is.und(props)) {
            results.push(ctrl.start());
          } else {
            const update2 = this._getProps(props, ctrl, i);
            if (update2) {
              results.push(ctrl.start(update2));
            }
          }
        });
        return results;
      };
      SpringRef2.stop = function() {
        (0, import_shared10.each)(current, (ctrl) => ctrl.stop(...arguments));
        return this;
      };
      SpringRef2.update = function(props) {
        (0, import_shared10.each)(current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));
        return this;
      };
      const _getProps = function(arg, ctrl, index) {
        return import_shared10.is.fun(arg) ? arg(index, ctrl) : arg;
      };
      SpringRef2._getProps = _getProps;
      return SpringRef2;
    };
    function useSprings(length, props, deps) {
      const propsFn = import_shared11.is.fun(props) && props;
      if (propsFn && !deps)
        deps = [];
      const ref = (0, import_react2.useMemo)(
        () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
        []
      );
      const layoutId = (0, import_react2.useRef)(0);
      const forceUpdate = (0, import_shared11.useForceUpdate)();
      const state = (0, import_react2.useMemo)(
        () => ({
          ctrls: [],
          queue: [],
          flush(ctrl, updates2) {
            const springs2 = getSprings(ctrl, updates2);
            const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
            return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {
              setSprings(ctrl, springs2);
              state.queue.push(() => {
                resolve(flushUpdateQueue(ctrl, updates2));
              });
              forceUpdate();
            });
          }
        }),
        []
      );
      const ctrls = (0, import_react2.useRef)([...state.ctrls]);
      const updates = [];
      const prevLength = (0, import_shared11.usePrev)(length) || 0;
      (0, import_react2.useMemo)(() => {
        (0, import_shared11.each)(ctrls.current.slice(length, prevLength), (ctrl) => {
          detachRefs(ctrl, ref);
          ctrl.stop(true);
        });
        ctrls.current.length = length;
        declareUpdates(prevLength, length);
      }, [length]);
      (0, import_react2.useMemo)(() => {
        declareUpdates(0, Math.min(prevLength, length));
      }, deps);
      function declareUpdates(startIndex, endIndex) {
        for (let i = startIndex; i < endIndex; i++) {
          const ctrl = ctrls.current[i] || (ctrls.current[i] = new Controller3(null, state.flush));
          const update2 = propsFn ? propsFn(i, ctrl) : props[i];
          if (update2) {
            updates[i] = declareUpdate(update2);
          }
        }
      }
      const springs = ctrls.current.map((ctrl, i) => getSprings(ctrl, updates[i]));
      const context = (0, import_react2.useContext)(SpringContext);
      const prevContext = (0, import_shared11.usePrev)(context);
      const hasContext = context !== prevContext && hasProps(context);
      (0, import_shared11.useIsomorphicLayoutEffect)(() => {
        layoutId.current++;
        state.ctrls = ctrls.current;
        const { queue } = state;
        if (queue.length) {
          state.queue = [];
          (0, import_shared11.each)(queue, (cb) => cb());
        }
        (0, import_shared11.each)(ctrls.current, (ctrl, i) => {
          ref == null ? void 0 : ref.add(ctrl);
          if (hasContext) {
            ctrl.start({ default: context });
          }
          const update2 = updates[i];
          if (update2) {
            replaceRef(ctrl, update2.ref);
            if (ctrl.ref) {
              ctrl.queue.push(update2);
            } else {
              ctrl.start(update2);
            }
          }
        });
      });
      (0, import_shared11.useOnce)(() => () => {
        (0, import_shared11.each)(state.ctrls, (ctrl) => ctrl.stop(true));
      });
      const values = springs.map((x) => ({ ...x }));
      return ref ? [values, ref] : values;
    }
    function useSpring(props, deps) {
      const isFn = import_shared12.is.fun(props);
      const [[values], ref] = useSprings(
        1,
        isFn ? props : [props],
        isFn ? deps || [] : deps
      );
      return isFn || arguments.length == 2 ? [values, ref] : values;
    }
    var import_react32 = require_react();
    var initSpringRef = () => SpringRef();
    var useSpringRef = () => (0, import_react32.useState)(initSpringRef)[0];
    var import_shared13 = require_cjs2();
    var useSpringValue = (initial2, props) => {
      const springValue = (0, import_shared13.useConstant)(() => new SpringValue(initial2, props));
      (0, import_shared13.useOnce)(() => () => {
        springValue.stop();
      });
      return springValue;
    };
    var import_shared14 = require_cjs2();
    function useTrail(length, propsArg, deps) {
      const propsFn = import_shared14.is.fun(propsArg) && propsArg;
      if (propsFn && !deps)
        deps = [];
      let reverse = true;
      let passedRef = void 0;
      const result = useSprings(
        length,
        (i, ctrl) => {
          const props = propsFn ? propsFn(i, ctrl) : propsArg;
          passedRef = props.ref;
          reverse = reverse && props.reverse;
          return props;
        },
        // Ensure the props function is called when no deps exist.
        // This works around the 3 argument rule.
        deps || [{}]
      );
      (0, import_shared14.useIsomorphicLayoutEffect)(() => {
        (0, import_shared14.each)(result[1].current, (ctrl, i) => {
          const parent = result[1].current[i + (reverse ? 1 : -1)];
          replaceRef(ctrl, passedRef);
          if (ctrl.ref) {
            if (parent) {
              ctrl.update({ to: parent.springs });
            }
            return;
          }
          if (parent) {
            ctrl.start({ to: parent.springs });
          } else {
            ctrl.start();
          }
        });
      }, deps);
      if (propsFn || arguments.length == 3) {
        const ref = passedRef ?? result[1];
        ref["_getProps"] = (propsArg2, ctrl, i) => {
          const props = import_shared14.is.fun(propsArg2) ? propsArg2(i, ctrl) : propsArg2;
          if (props) {
            const parent = ref.current[i + (props.reverse ? 1 : -1)];
            if (parent)
              props.to = parent.springs;
            return props;
          }
        };
        return result;
      }
      return result[0];
    }
    var React22 = __toESM2(require_react());
    var import_react4 = require_react();
    var import_shared15 = require_cjs2();
    function useTransition(data, props, deps) {
      const propsFn = import_shared15.is.fun(props) && props;
      const {
        reset,
        sort,
        trail = 0,
        expires = true,
        exitBeforeEnter = false,
        onDestroyed,
        ref: propsRef,
        config: propsConfig
      } = propsFn ? propsFn() : props;
      const ref = (0, import_react4.useMemo)(
        () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
        []
      );
      const items = (0, import_shared15.toArray)(data);
      const transitions = [];
      const usedTransitions = (0, import_react4.useRef)(null);
      const prevTransitions = reset ? null : usedTransitions.current;
      (0, import_shared15.useIsomorphicLayoutEffect)(() => {
        usedTransitions.current = transitions;
      });
      (0, import_shared15.useOnce)(() => {
        (0, import_shared15.each)(transitions, (t) => {
          ref == null ? void 0 : ref.add(t.ctrl);
          t.ctrl.ref = ref;
        });
        return () => {
          (0, import_shared15.each)(usedTransitions.current, (t) => {
            if (t.expired) {
              clearTimeout(t.expirationId);
            }
            detachRefs(t.ctrl, ref);
            t.ctrl.stop(true);
          });
        };
      });
      const keys = getKeys(items, propsFn ? propsFn() : props, prevTransitions);
      const expired = reset && usedTransitions.current || [];
      (0, import_shared15.useIsomorphicLayoutEffect)(
        () => (0, import_shared15.each)(expired, ({ ctrl, item, key }) => {
          detachRefs(ctrl, ref);
          callProp(onDestroyed, item, key);
        })
      );
      const reused = [];
      if (prevTransitions)
        (0, import_shared15.each)(prevTransitions, (t, i) => {
          if (t.expired) {
            clearTimeout(t.expirationId);
            expired.push(t);
          } else {
            i = reused[i] = keys.indexOf(t.key);
            if (~i)
              transitions[i] = t;
          }
        });
      (0, import_shared15.each)(items, (item, i) => {
        if (!transitions[i]) {
          transitions[i] = {
            key: keys[i],
            item,
            phase: "mount",
            ctrl: new Controller3()
          };
          transitions[i].ctrl.item = item;
        }
      });
      if (reused.length) {
        let i = -1;
        const { leave } = propsFn ? propsFn() : props;
        (0, import_shared15.each)(reused, (keyIndex, prevIndex) => {
          const t = prevTransitions[prevIndex];
          if (~keyIndex) {
            i = transitions.indexOf(t);
            transitions[i] = { ...t, item: items[keyIndex] };
          } else if (leave) {
            transitions.splice(++i, 0, t);
          }
        });
      }
      if (import_shared15.is.fun(sort)) {
        transitions.sort((a, b) => sort(a.item, b.item));
      }
      let delay2 = -trail;
      const forceUpdate = (0, import_shared15.useForceUpdate)();
      const defaultProps = getDefaultProps(props);
      const changes = /* @__PURE__ */ new Map();
      const exitingTransitions = (0, import_react4.useRef)(/* @__PURE__ */ new Map());
      const forceChange = (0, import_react4.useRef)(false);
      (0, import_shared15.each)(transitions, (t, i) => {
        const key = t.key;
        const prevPhase = t.phase;
        const p = propsFn ? propsFn() : props;
        let to2;
        let phase;
        const propsDelay = callProp(p.delay || 0, key);
        if (prevPhase == "mount") {
          to2 = p.enter;
          phase = "enter";
        } else {
          const isLeave = keys.indexOf(key) < 0;
          if (prevPhase != "leave") {
            if (isLeave) {
              to2 = p.leave;
              phase = "leave";
            } else if (to2 = p.update) {
              phase = "update";
            } else
              return;
          } else if (!isLeave) {
            to2 = p.enter;
            phase = "enter";
          } else
            return;
        }
        to2 = callProp(to2, t.item, i);
        to2 = import_shared15.is.obj(to2) ? inferTo(to2) : { to: to2 };
        if (!to2.config) {
          const config2 = propsConfig || defaultProps.config;
          to2.config = callProp(config2, t.item, i, phase);
        }
        delay2 += trail;
        const payload = {
          ...defaultProps,
          // we need to add our props.delay value you here.
          delay: propsDelay + delay2,
          ref: propsRef,
          immediate: p.immediate,
          // This prevents implied resets.
          reset: false,
          // Merge any phase-specific props.
          ...to2
        };
        if (phase == "enter" && import_shared15.is.und(payload.from)) {
          const p2 = propsFn ? propsFn() : props;
          const from = import_shared15.is.und(p2.initial) || prevTransitions ? p2.from : p2.initial;
          payload.from = callProp(from, t.item, i);
        }
        const { onResolve } = payload;
        payload.onResolve = (result) => {
          callProp(onResolve, result);
          const transitions2 = usedTransitions.current;
          const t2 = transitions2.find((t3) => t3.key === key);
          if (!t2)
            return;
          if (result.cancelled && t2.phase != "update") {
            return;
          }
          if (t2.ctrl.idle) {
            const idle = transitions2.every((t3) => t3.ctrl.idle);
            if (t2.phase == "leave") {
              const expiry = callProp(expires, t2.item);
              if (expiry !== false) {
                const expiryMs = expiry === true ? 0 : expiry;
                t2.expired = true;
                if (!idle && expiryMs > 0) {
                  if (expiryMs <= 2147483647)
                    t2.expirationId = setTimeout(forceUpdate, expiryMs);
                  return;
                }
              }
            }
            if (idle && transitions2.some((t3) => t3.expired)) {
              exitingTransitions.current.delete(t2);
              if (exitBeforeEnter) {
                forceChange.current = true;
              }
              forceUpdate();
            }
          }
        };
        const springs = getSprings(t.ctrl, payload);
        if (phase === "leave" && exitBeforeEnter) {
          exitingTransitions.current.set(t, { phase, springs, payload });
        } else {
          changes.set(t, { phase, springs, payload });
        }
      });
      const context = (0, import_react4.useContext)(SpringContext);
      const prevContext = (0, import_shared15.usePrev)(context);
      const hasContext = context !== prevContext && hasProps(context);
      (0, import_shared15.useIsomorphicLayoutEffect)(() => {
        if (hasContext) {
          (0, import_shared15.each)(transitions, (t) => {
            t.ctrl.start({ default: context });
          });
        }
      }, [context]);
      (0, import_shared15.each)(changes, (_, t) => {
        if (exitingTransitions.current.size) {
          const ind = transitions.findIndex((state) => state.key === t.key);
          transitions.splice(ind, 1);
        }
      });
      (0, import_shared15.useIsomorphicLayoutEffect)(
        () => {
          (0, import_shared15.each)(
            exitingTransitions.current.size ? exitingTransitions.current : changes,
            ({ phase, payload }, t) => {
              const { ctrl } = t;
              t.phase = phase;
              ref == null ? void 0 : ref.add(ctrl);
              if (hasContext && phase == "enter") {
                ctrl.start({ default: context });
              }
              if (payload) {
                replaceRef(ctrl, payload.ref);
                if ((ctrl.ref || ref) && !forceChange.current) {
                  ctrl.update(payload);
                } else {
                  ctrl.start(payload);
                  if (forceChange.current) {
                    forceChange.current = false;
                  }
                }
              }
            }
          );
        },
        reset ? void 0 : deps
      );
      const renderTransitions = (render) => React22.createElement(React22.Fragment, null, transitions.map((t, i) => {
        const { springs } = changes.get(t) || t.ctrl;
        const elem = render({ ...springs }, t.item, t, i);
        return elem && elem.type ? React22.createElement(
          elem.type,
          {
            ...elem.props,
            key: import_shared15.is.str(t.key) || import_shared15.is.num(t.key) ? t.key : t.ctrl.id,
            ref: elem.ref
          }
        ) : elem;
      }));
      return ref ? [renderTransitions, ref] : renderTransitions;
    }
    var nextKey = 1;
    function getKeys(items, { key, keys = key }, prevTransitions) {
      if (keys === null) {
        const reused = /* @__PURE__ */ new Set();
        return items.map((item) => {
          const t = prevTransitions && prevTransitions.find(
            (t2) => t2.item === item && t2.phase !== "leave" && !reused.has(t2)
          );
          if (t) {
            reused.add(t);
            return t.key;
          }
          return nextKey++;
        });
      }
      return import_shared15.is.und(keys) ? items : import_shared15.is.fun(keys) ? items.map(keys) : (0, import_shared15.toArray)(keys);
    }
    var import_shared16 = require_cjs2();
    var useScroll2 = ({
      container,
      ...springOptions
    } = {}) => {
      const [scrollValues, api] = useSpring(
        () => ({
          scrollX: 0,
          scrollY: 0,
          scrollXProgress: 0,
          scrollYProgress: 0,
          ...springOptions
        }),
        []
      );
      (0, import_shared16.useIsomorphicLayoutEffect)(() => {
        const cleanupScroll = (0, import_shared16.onScroll)(
          ({ x, y }) => {
            api.start({
              scrollX: x.current,
              scrollXProgress: x.progress,
              scrollY: y.current,
              scrollYProgress: y.progress
            });
          },
          { container: (container == null ? void 0 : container.current) || void 0 }
        );
        return () => {
          (0, import_shared16.each)(Object.values(scrollValues), (value) => value.stop());
          cleanupScroll();
        };
      }, []);
      return scrollValues;
    };
    var import_shared17 = require_cjs2();
    var useResize = ({
      container,
      ...springOptions
    }) => {
      const [sizeValues, api] = useSpring(
        () => ({
          width: 0,
          height: 0,
          ...springOptions
        }),
        []
      );
      (0, import_shared17.useIsomorphicLayoutEffect)(() => {
        const cleanupScroll = (0, import_shared17.onResize)(
          ({ width, height }) => {
            api.start({
              width,
              height,
              immediate: sizeValues.width.get() === 0 || sizeValues.height.get() === 0
            });
          },
          { container: (container == null ? void 0 : container.current) || void 0 }
        );
        return () => {
          (0, import_shared17.each)(Object.values(sizeValues), (value) => value.stop());
          cleanupScroll();
        };
      }, []);
      return sizeValues;
    };
    var import_react5 = require_react();
    var import_shared18 = require_cjs2();
    var defaultThresholdOptions = {
      any: 0,
      all: 1
    };
    function useInView(props, args) {
      const [isInView, setIsInView] = (0, import_react5.useState)(false);
      const ref = (0, import_react5.useRef)();
      const propsFn = import_shared18.is.fun(props) && props;
      const springsProps = propsFn ? propsFn() : {};
      const { to: to2 = {}, from = {}, ...restSpringProps } = springsProps;
      const intersectionArguments = propsFn ? args : props;
      const [springs, api] = useSpring(() => ({ from, ...restSpringProps }), []);
      (0, import_shared18.useIsomorphicLayoutEffect)(() => {
        const element = ref.current;
        const {
          root,
          once,
          amount = "any",
          ...restArgs
        } = intersectionArguments ?? {};
        if (!element || once && isInView || typeof IntersectionObserver === "undefined")
          return;
        const activeIntersections = /* @__PURE__ */ new WeakMap();
        const onEnter = () => {
          if (to2) {
            api.start(to2);
          }
          setIsInView(true);
          const cleanup = () => {
            if (from) {
              api.start(from);
            }
            setIsInView(false);
          };
          return once ? void 0 : cleanup;
        };
        const handleIntersection = (entries) => {
          entries.forEach((entry) => {
            const onLeave = activeIntersections.get(entry.target);
            if (entry.isIntersecting === Boolean(onLeave)) {
              return;
            }
            if (entry.isIntersecting) {
              const newOnLeave = onEnter();
              if (import_shared18.is.fun(newOnLeave)) {
                activeIntersections.set(entry.target, newOnLeave);
              } else {
                observer.unobserve(entry.target);
              }
            } else if (onLeave) {
              onLeave();
              activeIntersections.delete(entry.target);
            }
          });
        };
        const observer = new IntersectionObserver(handleIntersection, {
          root: root && root.current || void 0,
          threshold: typeof amount === "number" || Array.isArray(amount) ? amount : defaultThresholdOptions[amount],
          ...restArgs
        });
        observer.observe(element);
        return () => observer.unobserve(element);
      }, [intersectionArguments]);
      if (propsFn) {
        return [ref, springs];
      }
      return [ref, isInView];
    }
    function Spring({ children, ...props }) {
      return children(useSpring(props));
    }
    var import_shared19 = require_cjs2();
    function Trail({
      items,
      children,
      ...props
    }) {
      const trails = useTrail(items.length, props);
      return items.map((item, index) => {
        const result = children(item, index);
        return import_shared19.is.fun(result) ? result(trails[index]) : result;
      });
    }
    function Transition({
      items,
      children,
      ...props
    }) {
      return useTransition(items, props)(children);
    }
    var import_shared21 = require_cjs2();
    var import_shared20 = require_cjs2();
    var import_animated3 = require_cjs3();
    var Interpolation = class extends FrameValue {
      constructor(source, args) {
        super();
        this.source = source;
        this.idle = true;
        this._active = /* @__PURE__ */ new Set();
        this.calc = (0, import_shared20.createInterpolator)(...args);
        const value = this._get();
        const nodeType = (0, import_animated3.getAnimatedType)(value);
        (0, import_animated3.setAnimated)(this, nodeType.create(value));
      }
      advance(_dt) {
        const value = this._get();
        const oldValue = this.get();
        if (!(0, import_shared20.isEqual)(value, oldValue)) {
          (0, import_animated3.getAnimated)(this).setValue(value);
          this._onChange(value, this.idle);
        }
        if (!this.idle && checkIdle(this._active)) {
          becomeIdle(this);
        }
      }
      _get() {
        const inputs = import_shared20.is.arr(this.source) ? this.source.map(import_shared20.getFluidValue) : (0, import_shared20.toArray)((0, import_shared20.getFluidValue)(this.source));
        return this.calc(...inputs);
      }
      _start() {
        if (this.idle && !checkIdle(this._active)) {
          this.idle = false;
          (0, import_shared20.each)((0, import_animated3.getPayload)(this), (node) => {
            node.done = false;
          });
          if (import_shared20.Globals.skipAnimation) {
            import_shared20.raf.batchedUpdates(() => this.advance());
            becomeIdle(this);
          } else {
            import_shared20.frameLoop.start(this);
          }
        }
      }
      // Observe our sources only when we're observed.
      _attach() {
        let priority = 1;
        (0, import_shared20.each)((0, import_shared20.toArray)(this.source), (source) => {
          if ((0, import_shared20.hasFluidValue)(source)) {
            (0, import_shared20.addFluidObserver)(source, this);
          }
          if (isFrameValue(source)) {
            if (!source.idle) {
              this._active.add(source);
            }
            priority = Math.max(priority, source.priority + 1);
          }
        });
        this.priority = priority;
        this._start();
      }
      // Stop observing our sources once we have no observers.
      _detach() {
        (0, import_shared20.each)((0, import_shared20.toArray)(this.source), (source) => {
          if ((0, import_shared20.hasFluidValue)(source)) {
            (0, import_shared20.removeFluidObserver)(source, this);
          }
        });
        this._active.clear();
        becomeIdle(this);
      }
      /** @internal */
      eventObserved(event) {
        if (event.type == "change") {
          if (event.idle) {
            this.advance();
          } else {
            this._active.add(event.parent);
            this._start();
          }
        } else if (event.type == "idle") {
          this._active.delete(event.parent);
        } else if (event.type == "priority") {
          this.priority = (0, import_shared20.toArray)(this.source).reduce(
            (highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1),
            0
          );
        }
      }
    };
    function isIdle(source) {
      return source.idle !== false;
    }
    function checkIdle(active) {
      return !active.size || Array.from(active).every(isIdle);
    }
    function becomeIdle(self) {
      if (!self.idle) {
        self.idle = true;
        (0, import_shared20.each)((0, import_animated3.getPayload)(self), (node) => {
          node.done = true;
        });
        (0, import_shared20.callFluidObservers)(self, {
          type: "idle",
          parent: self
        });
      }
    }
    var to = (source, ...args) => new Interpolation(source, args);
    var interpolate = (source, ...args) => ((0, import_shared21.deprecateInterpolate)(), new Interpolation(source, args));
    var import_shared22 = require_cjs2();
    import_shared22.Globals.assign({
      createStringInterpolator: import_shared22.createStringInterpolator,
      to: (source, args) => new Interpolation(source, args)
    });
    var update = import_shared22.frameLoop.advance;
    var import_shared23 = require_cjs2();
    __reExport(src_exports, require_cjs4(), module.exports);
  }
});

// node_modules/@react-spring/core/dist/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/@react-spring/core/dist/cjs/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_spring_core_development();
    }
  }
});

// node_modules/@react-spring/web/dist/cjs/react-spring_web.development.cjs
var require_react_spring_web_development = __commonJS({
  "node_modules/@react-spring/web/dist/cjs/react-spring_web.development.cjs"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      a: () => animated,
      animated: () => animated
    });
    module.exports = __toCommonJS2(src_exports);
    var import_core = require_cjs5();
    var import_react_dom = require_react_dom();
    var import_shared2 = require_cjs2();
    var import_animated2 = require_cjs3();
    var isCustomPropRE = /^--/;
    function dangerousStyleValue(name, value) {
      if (value == null || typeof value === "boolean" || value === "")
        return "";
      if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
        return value + "px";
      return ("" + value).trim();
    }
    var attributeCache = {};
    function applyAnimatedValues(instance, props) {
      if (!instance.nodeType || !instance.setAttribute) {
        return false;
      }
      const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
      const {
        className,
        style,
        children,
        scrollTop,
        scrollLeft,
        viewBox,
        ...attributes
      } = props;
      const values = Object.values(attributes);
      const names = Object.keys(attributes).map(
        (name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(
          /([A-Z])/g,
          // Attributes are written in dash case
          (n) => "-" + n.toLowerCase()
        ))
      );
      if (children !== void 0) {
        instance.textContent = children;
      }
      for (const name in style) {
        if (style.hasOwnProperty(name)) {
          const value = dangerousStyleValue(name, style[name]);
          if (isCustomPropRE.test(name)) {
            instance.style.setProperty(name, value);
          } else {
            instance.style[name] = value;
          }
        }
      }
      names.forEach((name, i) => {
        instance.setAttribute(name, values[i]);
      });
      if (className !== void 0) {
        instance.className = className;
      }
      if (scrollTop !== void 0) {
        instance.scrollTop = scrollTop;
      }
      if (scrollLeft !== void 0) {
        instance.scrollLeft = scrollLeft;
      }
      if (viewBox !== void 0) {
        instance.setAttribute("viewBox", viewBox);
      }
    }
    var isUnitlessNumber = {
      animationIterationCount: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      // SVG-related properties
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    var prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);
    var prefixes = ["Webkit", "Ms", "Moz", "O"];
    isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
      prefixes.forEach((prefix) => acc[prefixKey(prefix, prop)] = acc[prop]);
      return acc;
    }, isUnitlessNumber);
    var import_animated = require_cjs3();
    var import_shared = require_cjs2();
    var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
    var pxTransforms = /^(translate)/;
    var degTransforms = /^(rotate|skew)/;
    var addUnit = (value, unit) => import_shared.is.num(value) && value !== 0 ? value + unit : value;
    var isValueIdentity = (value, id) => import_shared.is.arr(value) ? value.every((v) => isValueIdentity(v, id)) : import_shared.is.num(value) ? value === id : parseFloat(value) === id;
    var AnimatedStyle = class extends import_animated.AnimatedObject {
      constructor({ x, y, z, ...style }) {
        const inputs = [];
        const transforms = [];
        if (x || y || z) {
          inputs.push([x || 0, y || 0, z || 0]);
          transforms.push((xyz) => [
            `translate3d(${xyz.map((v) => addUnit(v, "px")).join(",")})`,
            // prettier-ignore
            isValueIdentity(xyz, 0)
          ]);
        }
        (0, import_shared.eachProp)(style, (value, key) => {
          if (key === "transform") {
            inputs.push([value || ""]);
            transforms.push((transform) => [transform, transform === ""]);
          } else if (domTransforms.test(key)) {
            delete style[key];
            if (import_shared.is.und(value))
              return;
            const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
            inputs.push((0, import_shared.toArray)(value));
            transforms.push(
              key === "rotate3d" ? ([x2, y2, z2, deg]) => [
                `rotate3d(${x2},${y2},${z2},${addUnit(deg, unit)})`,
                isValueIdentity(deg, 0)
              ] : (input) => [
                `${key}(${input.map((v) => addUnit(v, unit)).join(",")})`,
                isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
              ]
            );
          }
        });
        if (inputs.length) {
          style.transform = new FluidTransform(inputs, transforms);
        }
        super(style);
      }
    };
    var FluidTransform = class extends import_shared.FluidValue {
      constructor(inputs, transforms) {
        super();
        this.inputs = inputs;
        this.transforms = transforms;
        this._value = null;
      }
      get() {
        return this._value || (this._value = this._get());
      }
      _get() {
        let transform = "";
        let identity4 = true;
        (0, import_shared.each)(this.inputs, (input, i) => {
          const arg1 = (0, import_shared.getFluidValue)(input[0]);
          const [t, id] = this.transforms[i](
            import_shared.is.arr(arg1) ? arg1 : input.map(import_shared.getFluidValue)
          );
          transform += " " + t;
          identity4 = identity4 && id;
        });
        return identity4 ? "none" : transform;
      }
      // Start observing our inputs once we have an observer.
      observerAdded(count) {
        if (count == 1)
          (0, import_shared.each)(
            this.inputs,
            (input) => (0, import_shared.each)(
              input,
              (value) => (0, import_shared.hasFluidValue)(value) && (0, import_shared.addFluidObserver)(value, this)
            )
          );
      }
      // Stop observing our inputs once we have no observers.
      observerRemoved(count) {
        if (count == 0)
          (0, import_shared.each)(
            this.inputs,
            (input) => (0, import_shared.each)(
              input,
              (value) => (0, import_shared.hasFluidValue)(value) && (0, import_shared.removeFluidObserver)(value, this)
            )
          );
      }
      eventObserved(event) {
        if (event.type == "change") {
          this._value = null;
        }
        (0, import_shared.callFluidObservers)(this, event);
      }
    };
    var primitives = [
      "a",
      "abbr",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "base",
      "bdi",
      "bdo",
      "big",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "keygen",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "menu",
      "menuitem",
      "meta",
      "meter",
      "nav",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "param",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "script",
      "section",
      "select",
      "small",
      "source",
      "span",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "u",
      "ul",
      "var",
      "video",
      "wbr",
      // SVG
      "circle",
      "clipPath",
      "defs",
      "ellipse",
      "foreignObject",
      "g",
      "image",
      "line",
      "linearGradient",
      "mask",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialGradient",
      "rect",
      "stop",
      "svg",
      "text",
      "tspan"
    ];
    __reExport(src_exports, require_cjs5(), module.exports);
    import_core.Globals.assign({
      batchedUpdates: import_react_dom.unstable_batchedUpdates,
      createStringInterpolator: import_shared2.createStringInterpolator,
      colors: import_shared2.colors
    });
    var host = (0, import_animated2.createHost)(primitives, {
      applyAnimatedValues,
      createAnimatedStyle: (style) => new AnimatedStyle(style),
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getComponentProps: ({ scrollTop, scrollLeft, ...props }) => props
    });
    var animated = host.animated;
  }
});

// node_modules/@react-spring/web/dist/cjs/index.js
var require_cjs6 = __commonJS({
  "node_modules/@react-spring/web/dist/cjs/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_spring_web_development();
    }
  }
});

// node_modules/react-use-gesture/dist/reactusegesture.esm.js
var reactusegesture_esm_exports = {};
__export(reactusegesture_esm_exports, {
  addV: () => addV,
  rubberbandIfOutOfBounds: () => rubberbandIfOutOfBounds,
  subV: () => subV,
  useDrag: () => useDrag,
  useGesture: () => useGesture,
  useHover: () => useHover,
  useMove: () => useMove,
  usePinch: () => usePinch,
  useScroll: () => useScroll,
  useWheel: () => useWheel
});
function addV(v1, v2) {
  return v1.map(function(v, i) {
    return v + v2[i];
  });
}
function subV(v1, v2) {
  return v1.map(function(v, i) {
    return v - v2[i];
  });
}
function calculateDistance(movement) {
  return Math.hypot.apply(Math, movement);
}
function calculateAllGeometry(movement, delta) {
  if (delta === void 0) {
    delta = movement;
  }
  var dl = calculateDistance(delta);
  var alpha = dl === 0 ? 0 : 1 / dl;
  var direction = delta.map(function(v) {
    return alpha * v;
  });
  var distance = calculateDistance(movement);
  return {
    distance,
    direction
  };
}
function calculateAllKinematics(movement, delta, dt) {
  var dl = calculateDistance(delta);
  var alpha = dl === 0 ? 0 : 1 / dl;
  var beta = dt === 0 ? 0 : 1 / dt;
  var velocity = beta * dl;
  var velocities = delta.map(function(v) {
    return beta * v;
  });
  var direction = delta.map(function(v) {
    return alpha * v;
  });
  var distance = calculateDistance(movement);
  return {
    velocities,
    velocity,
    distance,
    direction
  };
}
function sign(x) {
  if (Math.sign)
    return Math.sign(x);
  return Number(x > 0) - Number(x < 0) || +x;
}
function minMax(value, min, max) {
  return Math.max(min, Math.min(value, max));
}
function rubberband2(distance, constant) {
  return Math.pow(distance, constant * 5);
}
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity)
    return rubberband2(distance, constant);
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position, min, max, constant) {
  if (constant === void 0) {
    constant = 0.15;
  }
  if (constant === 0)
    return minMax(position, min, max);
  if (position < min)
    return -rubberband(min - position, max - min, constant) + min;
  if (position > max)
    return +rubberband(position - max, max - min, constant) + max;
  return position;
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      return function() {
        if (i >= o.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  it = o[Symbol.iterator]();
  return it.next.bind(it);
}
function noop() {
}
function chainFns() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  if (fns.length === 0)
    return noop;
  if (fns.length === 1)
    return fns[0];
  return function() {
    var result;
    for (var _iterator = _createForOfIteratorHelperLoose(fns), _step; !(_step = _iterator()).done; ) {
      var fn = _step.value;
      result = fn.apply(this, arguments) || result;
    }
    return result;
  };
}
function ensureVector(value, fallback) {
  if (value === void 0) {
    if (fallback === void 0) {
      throw new Error("Must define fallback value if undefined is expected");
    }
    value = fallback;
  }
  if (Array.isArray(value))
    return value;
  return [value, value];
}
function assignDefault(value, fallback) {
  return Object.assign({}, fallback, value || {});
}
function valueFn(v) {
  if (typeof v === "function") {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    return v.apply(void 0, args);
  } else {
    return v;
  }
}
function resolveWith(config, resolvers) {
  if (config === void 0) {
    config = {};
  }
  var result = {};
  for (var _i = 0, _Object$entries = Object.entries(resolvers); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _Object$entries[_i], key = _Object$entries$_i[0], resolver = _Object$entries$_i[1];
    switch (typeof resolver) {
      case "function":
        result[key] = resolver.call(result, config[key], key, config);
        break;
      case "object":
        result[key] = resolveWith(config[key], resolver);
        break;
      case "boolean":
        if (resolver)
          result[key] = config[key];
        break;
    }
  }
  return result;
}
function supportsGestureEvents() {
  try {
    return "constructor" in GestureEvent;
  } catch (e) {
    return false;
  }
}
function supportsTouchEvents() {
  return typeof window !== "undefined" && "ontouchstart" in window;
}
function supportsPointerEvents() {
  return typeof window !== "undefined" && "onpointerdown" in window;
}
function getEventTouches(event) {
  if ("pointerId" in event)
    return null;
  return event.type === "touchend" ? event.changedTouches : event.targetTouches;
}
function getTouchIds(event) {
  return Array.from(getEventTouches(event)).map(function(t) {
    return t.identifier;
  });
}
function getGenericEventData(event) {
  var buttons = "buttons" in event ? event.buttons : 0;
  var shiftKey = event.shiftKey, altKey = event.altKey, metaKey = event.metaKey, ctrlKey = event.ctrlKey;
  return {
    buttons,
    shiftKey,
    altKey,
    metaKey,
    ctrlKey
  };
}
function getPointerEventValues(event, transform) {
  if (transform === void 0) {
    transform = identity;
  }
  var touchEvents = getEventTouches(event);
  var _ref = touchEvents ? touchEvents[0] : event, clientX = _ref.clientX, clientY = _ref.clientY;
  return transform([clientX, clientY]);
}
function getTwoTouchesEventValues(event, pointerIds, transform) {
  if (transform === void 0) {
    transform = identity;
  }
  var _Array$from$filter = Array.from(event.touches).filter(function(t) {
    return pointerIds.includes(t.identifier);
  }), A = _Array$from$filter[0], B = _Array$from$filter[1];
  if (!A || !B)
    throw Error("The event doesn't have two pointers matching the pointerIds");
  var dx = B.clientX - A.clientX;
  var dy = B.clientY - A.clientY;
  var cx = (B.clientX + A.clientX) / 2;
  var cy = (B.clientY + A.clientY) / 2;
  var distance = Math.hypot(dx, dy);
  var angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
  var values = transform([distance, angle]);
  var origin = transform([cx, cy]);
  return {
    values,
    origin
  };
}
function getScrollEventValues(event, transform) {
  if (transform === void 0) {
    transform = identity;
  }
  var _event$currentTarget = event.currentTarget, scrollX = _event$currentTarget.scrollX, scrollY = _event$currentTarget.scrollY, scrollLeft = _event$currentTarget.scrollLeft, scrollTop = _event$currentTarget.scrollTop;
  return transform([scrollX || scrollLeft || 0, scrollY || scrollTop || 0]);
}
function getWheelEventValues(event, transform) {
  if (transform === void 0) {
    transform = identity;
  }
  var deltaX = event.deltaX, deltaY = event.deltaY, deltaMode = event.deltaMode;
  if (deltaMode === 1) {
    deltaX *= LINE_HEIGHT;
    deltaY *= LINE_HEIGHT;
  } else if (deltaMode === 2) {
    deltaX *= PAGE_HEIGHT;
    deltaY *= PAGE_HEIGHT;
  }
  return transform([deltaX, deltaY]);
}
function getWebkitGestureEventValues(event, transform) {
  if (transform === void 0) {
    transform = identity;
  }
  return transform([event.scale, event.rotation]);
}
function getInternalGenericOptions(config) {
  if (config === void 0) {
    config = {};
  }
  return resolveWith(config, InternalGenericOptionsNormalizers);
}
function getInternalCoordinatesOptions(config) {
  if (config === void 0) {
    config = {};
  }
  return resolveWith(config, InternalCoordinatesOptionsNormalizers);
}
function getInternalDistanceAngleOptions(config) {
  if (config === void 0) {
    config = {};
  }
  return resolveWith(config, InternalDistanceAngleOptionsNormalizers);
}
function getInternalDragOptions(config) {
  if (config === void 0) {
    config = {};
  }
  return resolveWith(config, InternalDragOptionsNormalizers);
}
function _buildMoveConfig(_ref) {
  var domTarget = _ref.domTarget, eventOptions2 = _ref.eventOptions, window2 = _ref.window, enabled3 = _ref.enabled, rest = _objectWithoutPropertiesLoose(_ref, ["domTarget", "eventOptions", "window", "enabled"]);
  var opts = getInternalGenericOptions({
    domTarget,
    eventOptions: eventOptions2,
    window: window2,
    enabled: enabled3
  });
  opts.move = getInternalCoordinatesOptions(rest);
  return opts;
}
function _buildHoverConfig(_ref2) {
  var domTarget = _ref2.domTarget, eventOptions2 = _ref2.eventOptions, window2 = _ref2.window, enabled3 = _ref2.enabled, rest = _objectWithoutPropertiesLoose(_ref2, ["domTarget", "eventOptions", "window", "enabled"]);
  var opts = getInternalGenericOptions({
    domTarget,
    eventOptions: eventOptions2,
    window: window2,
    enabled: enabled3
  });
  opts.hover = _extends({
    enabled: true
  }, rest);
  return opts;
}
function _buildDragConfig(_ref3) {
  var domTarget = _ref3.domTarget, eventOptions2 = _ref3.eventOptions, window2 = _ref3.window, enabled3 = _ref3.enabled, rest = _objectWithoutPropertiesLoose(_ref3, ["domTarget", "eventOptions", "window", "enabled"]);
  var opts = getInternalGenericOptions({
    domTarget,
    eventOptions: eventOptions2,
    window: window2,
    enabled: enabled3
  });
  opts.drag = getInternalDragOptions(rest);
  return opts;
}
function _buildPinchConfig(_ref4) {
  var domTarget = _ref4.domTarget, eventOptions2 = _ref4.eventOptions, window2 = _ref4.window, enabled3 = _ref4.enabled, rest = _objectWithoutPropertiesLoose(_ref4, ["domTarget", "eventOptions", "window", "enabled"]);
  var opts = getInternalGenericOptions({
    domTarget,
    eventOptions: eventOptions2,
    window: window2,
    enabled: enabled3
  });
  opts.pinch = getInternalDistanceAngleOptions(rest);
  return opts;
}
function _buildScrollConfig(_ref5) {
  var domTarget = _ref5.domTarget, eventOptions2 = _ref5.eventOptions, window2 = _ref5.window, enabled3 = _ref5.enabled, rest = _objectWithoutPropertiesLoose(_ref5, ["domTarget", "eventOptions", "window", "enabled"]);
  var opts = getInternalGenericOptions({
    domTarget,
    eventOptions: eventOptions2,
    window: window2,
    enabled: enabled3
  });
  opts.scroll = getInternalCoordinatesOptions(rest);
  return opts;
}
function _buildWheelConfig(_ref6) {
  var domTarget = _ref6.domTarget, eventOptions2 = _ref6.eventOptions, window2 = _ref6.window, enabled3 = _ref6.enabled, rest = _objectWithoutPropertiesLoose(_ref6, ["domTarget", "eventOptions", "window", "enabled"]);
  var opts = getInternalGenericOptions({
    domTarget,
    eventOptions: eventOptions2,
    window: window2,
    enabled: enabled3
  });
  opts.wheel = getInternalCoordinatesOptions(rest);
  return opts;
}
function buildComplexConfig(config, actions) {
  if (config === void 0) {
    config = {};
  }
  if (actions === void 0) {
    actions = /* @__PURE__ */ new Set();
  }
  var _config = config, drag = _config.drag, wheel = _config.wheel, move = _config.move, scroll = _config.scroll, pinch = _config.pinch, hover = _config.hover, eventOptions2 = _config.eventOptions, window2 = _config.window, transform = _config.transform, domTarget = _config.domTarget, enabled3 = _config.enabled;
  var mergedConfig = getInternalGenericOptions({
    domTarget,
    eventOptions: eventOptions2,
    transform,
    window: window2,
    enabled: enabled3
  });
  if (actions.has("onDrag"))
    mergedConfig.drag = getInternalDragOptions(drag);
  if (actions.has("onWheel"))
    mergedConfig.wheel = getInternalCoordinatesOptions(wheel);
  if (actions.has("onScroll"))
    mergedConfig.scroll = getInternalCoordinatesOptions(scroll);
  if (actions.has("onMove"))
    mergedConfig.move = getInternalCoordinatesOptions(move);
  if (actions.has("onPinch"))
    mergedConfig.pinch = getInternalDistanceAngleOptions(pinch);
  if (actions.has("onHover"))
    mergedConfig.hover = _extends({
      enabled: true
    }, hover);
  return mergedConfig;
}
function getInitial(mixed) {
  return _extends({
    _active: false,
    _blocked: false,
    _intentional: [false, false],
    _movement: [0, 0],
    _initial: [0, 0],
    _bounds: [[-Infinity, Infinity], [-Infinity, Infinity]],
    _threshold: [0, 0],
    _lastEventType: void 0,
    _dragStarted: false,
    _dragPreventScroll: false,
    _dragIsTap: true,
    _dragDelayed: false,
    event: void 0,
    intentional: false,
    values: [0, 0],
    velocities: [0, 0],
    delta: [0, 0],
    movement: [0, 0],
    offset: [0, 0],
    lastOffset: [0, 0],
    direction: [0, 0],
    initial: [0, 0],
    previous: [0, 0],
    first: false,
    last: false,
    active: false,
    timeStamp: 0,
    startTime: 0,
    elapsedTime: 0,
    cancel: noop,
    canceled: false,
    memo: void 0,
    args: void 0
  }, mixed);
}
function getInitialState() {
  var shared = {
    hovering: false,
    scrolling: false,
    wheeling: false,
    dragging: false,
    moving: false,
    pinching: false,
    touches: 0,
    buttons: 0,
    down: false,
    shiftKey: false,
    altKey: false,
    metaKey: false,
    ctrlKey: false,
    locked: false
  };
  var drag = getInitial({
    _pointerId: void 0,
    axis: void 0,
    xy: [0, 0],
    vxvy: [0, 0],
    velocity: 0,
    distance: 0,
    tap: false,
    swipe: [0, 0]
  });
  var pinch = getInitial({
    // @ts-expect-error when used _pointerIds we can assert its type will be [number, number]
    _pointerIds: [],
    da: [0, 0],
    vdva: [0, 0],
    // @ts-expect-error origin can never be passed as undefined in userland
    origin: void 0,
    turns: 0
  });
  var wheel = getInitial({
    axis: void 0,
    xy: [0, 0],
    vxvy: [0, 0],
    velocity: 0,
    distance: 0
  });
  var move = getInitial({
    axis: void 0,
    xy: [0, 0],
    vxvy: [0, 0],
    velocity: 0,
    distance: 0
  });
  var scroll = getInitial({
    axis: void 0,
    xy: [0, 0],
    vxvy: [0, 0],
    velocity: 0,
    distance: 0
  });
  return {
    shared,
    drag,
    pinch,
    wheel,
    move,
    scroll
  };
}
function getIntentionalDisplacement(movement, threshold3) {
  if (Math.abs(movement) >= threshold3) {
    return sign(movement) * threshold3;
  } else {
    return false;
  }
}
function computeRubberband(bounds3, _ref, _ref2) {
  var Vx = _ref[0], Vy = _ref[1];
  var Rx = _ref2[0], Ry = _ref2[1];
  var _bounds$ = bounds3[0], X1 = _bounds$[0], X2 = _bounds$[1], _bounds$2 = bounds3[1], Y1 = _bounds$2[0], Y2 = _bounds$2[1];
  return [rubberbandIfOutOfBounds(Vx, X1, X2, Rx), rubberbandIfOutOfBounds(Vy, Y1, Y2, Ry)];
}
function getGenericPayload(_ref3, event, isStartEvent) {
  var state = _ref3.state;
  var timeStamp = event.timeStamp, _lastEventType = event.type;
  var previous = state.values;
  var elapsedTime = isStartEvent ? 0 : timeStamp - state.startTime;
  return {
    _lastEventType,
    event,
    timeStamp,
    elapsedTime,
    previous
  };
}
function getStartGestureState(_ref4, values, event, initial2) {
  var state = _ref4.state, config = _ref4.config, stateKey = _ref4.stateKey, args = _ref4.args, transform = _ref4.transform;
  var offset = state.offset;
  var startTime = event.timeStamp;
  var initialFn = config.initial, bounds3 = config.bounds, threshold3 = config.threshold;
  var _threshold = subV(transform(threshold3), transform([0, 0])).map(Math.abs);
  var _state = _extends({}, getInitialState()[stateKey], {
    _active: true,
    args,
    values,
    initial: initial2 != null ? initial2 : values,
    _threshold,
    offset,
    lastOffset: offset,
    startTime
  });
  return _extends({}, _state, {
    _initial: valueFn(initialFn, _state),
    _bounds: valueFn(bounds3, _state)
  });
}
function addEventIds(controller, event) {
  if ("pointerId" in event) {
    controller.pointerIds.add(event.pointerId);
  } else {
    controller.touchIds = new Set(getTouchIds(event));
  }
}
function removeEventIds(controller, event) {
  if ("pointerId" in event) {
    controller.pointerIds["delete"](event.pointerId);
  } else {
    getTouchIds(event).forEach(function(id) {
      return controller.touchIds["delete"](id);
    });
  }
}
function clearAllWindowListeners(controller) {
  var _controller$config = controller.config, el = _controller$config.window, eventOptions2 = _controller$config.eventOptions, windowListeners = controller.windowListeners;
  if (!el)
    return;
  for (var stateKey in windowListeners) {
    var handlers = windowListeners[stateKey];
    removeListeners(el, handlers, eventOptions2);
  }
  controller.windowListeners = {};
}
function clearWindowListeners(_ref, stateKey, options) {
  var config = _ref.config, windowListeners = _ref.windowListeners;
  if (options === void 0) {
    options = config.eventOptions;
  }
  if (!config.window)
    return;
  removeListeners(config.window, windowListeners[stateKey], options);
  delete windowListeners[stateKey];
}
function updateWindowListeners(_ref2, stateKey, listeners, options) {
  var config = _ref2.config, windowListeners = _ref2.windowListeners;
  if (listeners === void 0) {
    listeners = [];
  }
  if (options === void 0) {
    options = config.eventOptions;
  }
  if (!config.window)
    return;
  removeListeners(config.window, windowListeners[stateKey], options);
  addListeners(config.window, windowListeners[stateKey] = listeners, options);
}
function updateDomListeners(_ref3, bindings) {
  var config = _ref3.config, domListeners = _ref3.domListeners;
  var domTarget = getDomTargetFromConfig(config);
  if (!domTarget)
    throw new Error("domTarget must be defined");
  var eventOptions2 = config.eventOptions;
  removeListeners(domTarget, takeAll(domListeners), eventOptions2);
  for (var _i = 0, _Object$entries = Object.entries(bindings); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _Object$entries[_i], key = _Object$entries$_i[0], fns = _Object$entries$_i[1];
    var name = key.slice(2).toLowerCase();
    domListeners.push([name, chainFns.apply(void 0, fns)]);
  }
  addListeners(domTarget, domListeners, eventOptions2);
}
function getPropsListener(_ref4, bindings) {
  var config = _ref4.config;
  var props = {};
  var captureString = config.eventOptions.capture ? "Capture" : "";
  for (var _i2 = 0, _Object$entries2 = Object.entries(bindings); _i2 < _Object$entries2.length; _i2++) {
    var _Object$entries2$_i = _Object$entries2[_i2], event = _Object$entries2$_i[0], fns = _Object$entries2$_i[1];
    var fnsArray = Array.isArray(fns) ? fns : [fns];
    var key = event + captureString;
    props[key] = chainFns.apply(void 0, fnsArray);
  }
  return props;
}
function takeAll(array) {
  if (array === void 0) {
    array = [];
  }
  return array.splice(0, array.length);
}
function getDomTargetFromConfig(_ref5) {
  var domTarget = _ref5.domTarget;
  return domTarget && "current" in domTarget ? domTarget.current : domTarget;
}
function addBindings(bindings, name, fn) {
  if (!bindings[name])
    bindings[name] = [];
  bindings[name].push(fn);
}
function addListeners(el, listeners, options) {
  if (listeners === void 0) {
    listeners = [];
  }
  if (options === void 0) {
    options = {};
  }
  for (var _iterator2 = _createForOfIteratorHelperLoose(listeners), _step2; !(_step2 = _iterator2()).done; ) {
    var _step2$value = _step2.value, eventName = _step2$value[0], eventHandler = _step2$value[1];
    el.addEventListener(eventName, eventHandler, options);
  }
}
function removeListeners(el, listeners, options) {
  if (listeners === void 0) {
    listeners = [];
  }
  if (options === void 0) {
    options = {};
  }
  for (var _iterator3 = _createForOfIteratorHelperLoose(listeners), _step3; !(_step3 = _iterator3()).done; ) {
    var _step3$value = _step3.value, eventName = _step3$value[0], eventHandler = _step3$value[1];
    el.removeEventListener(eventName, eventHandler, options);
  }
}
function useRecognizers(handlers, config, nativeHandlers) {
  if (nativeHandlers === void 0) {
    nativeHandlers = {};
  }
  var classes = resolveClasses(handlers);
  var controller = import_react.default.useMemo(function() {
    return new Controller(classes);
  }, []);
  controller.config = config;
  controller.handlers = handlers;
  controller.nativeRefs = nativeHandlers;
  import_react.default.useEffect(controller.effect, []);
  if (controller.config.domTarget)
    return deprecationNoticeForDomTarget;
  return controller.bind;
}
function deprecationNoticeForDomTarget() {
  if (true) {
    console.warn("Deprecation notice: When the `domTarget` option is specified, you don't need to write `useEffect(bind, [bind])` anymore: event binding is now made handled internally to this lib.\n\nNext version won't return anything when `domTarget` is provided, therefore your code will break if you try to call `useEffect`.");
  }
}
function resolveClasses(internalHandlers) {
  var classes = /* @__PURE__ */ new Set();
  if (internalHandlers.drag)
    classes.add(RecognizersMap.get("drag"));
  if (internalHandlers.wheel)
    classes.add(RecognizersMap.get("wheel"));
  if (internalHandlers.scroll)
    classes.add(RecognizersMap.get("scroll"));
  if (internalHandlers.move)
    classes.add(RecognizersMap.get("move"));
  if (internalHandlers.pinch)
    classes.add(RecognizersMap.get("pinch"));
  if (internalHandlers.hover)
    classes.add(RecognizersMap.get("hover"));
  return classes;
}
function persistEvent(event) {
  "persist" in event && typeof event.persist === "function" && event.persist();
}
function memoizeOne(resultFn, isEqual2) {
  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;
  function memoized() {
    for (var _len = arguments.length, newArgs = new Array(_len), _key = 0; _key < _len; _key++) {
      newArgs[_key] = arguments[_key];
    }
    if (calledOnce && lastThis === this && isEqual2(newArgs, lastArgs)) {
      return lastResult;
    }
    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }
  return memoized;
}
function equal(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length)
        return false;
      for (i = length; i-- !== 0; ) {
        if (!equal(a[i], b[i]))
          return false;
      }
      return true;
    }
    var it;
    if (typeof Map === "function" && a instanceof Map && b instanceof Map) {
      if (a.size !== b.size)
        return false;
      it = a.entries();
      while (!(i = it.next()).done) {
        if (!b.has(i.value[0]))
          return false;
      }
      it = a.entries();
      while (!(i = it.next()).done) {
        if (!equal(i.value[1], b.get(i.value[0])))
          return false;
      }
      return true;
    }
    if (typeof Set === "function" && a instanceof Set && b instanceof Set) {
      if (a.size !== b.size)
        return false;
      it = a.entries();
      while (!(i = it.next()).done) {
        if (!b.has(i.value[0]))
          return false;
      }
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; ) {
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;
    }
    if (typeof Element !== "undefined" && a instanceof Element)
      return false;
    for (i = length; i-- !== 0; ) {
      if (keys[i] === "_owner" && a.$$typeof)
        continue;
      if (!equal(a[keys[i]], b[keys[i]]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
}
function isEqual(a, b) {
  try {
    return equal(a, b);
  } catch (error) {
    if ((error.message || "").match(/stack|recursion/i)) {
      console.warn("react-fast-compare cannot handle circular refs");
      return false;
    }
    throw error;
  }
}
function useDrag(handler, config) {
  if (config === void 0) {
    config = {};
  }
  RecognizersMap.set("drag", DragRecognizer);
  var buildDragConfig = (0, import_react.useRef)();
  if (!buildDragConfig.current) {
    buildDragConfig.current = memoizeOne(_buildDragConfig, isEqual);
  }
  return useRecognizers({
    drag: handler
  }, buildDragConfig.current(config));
}
function usePinch(handler, config) {
  if (config === void 0) {
    config = {};
  }
  RecognizersMap.set("pinch", PinchRecognizer);
  var buildPinchConfig = (0, import_react.useRef)();
  if (!buildPinchConfig.current) {
    buildPinchConfig.current = memoizeOne(_buildPinchConfig, isEqual);
  }
  return useRecognizers({
    pinch: handler
  }, buildPinchConfig.current(config));
}
function useWheel(handler, config) {
  if (config === void 0) {
    config = {};
  }
  RecognizersMap.set("wheel", WheelRecognizer);
  var buildWheelConfig = (0, import_react.useRef)();
  if (!buildWheelConfig.current) {
    buildWheelConfig.current = memoizeOne(_buildWheelConfig, isEqual);
  }
  return useRecognizers({
    wheel: handler
  }, buildWheelConfig.current(config));
}
function useMove(handler, config) {
  if (config === void 0) {
    config = {};
  }
  RecognizersMap.set("move", MoveRecognizer);
  var buildMoveConfig = (0, import_react.useRef)();
  if (!buildMoveConfig.current) {
    buildMoveConfig.current = memoizeOne(_buildMoveConfig, isEqual);
  }
  return useRecognizers({
    move: handler
  }, buildMoveConfig.current(config));
}
function useHover(handler, config) {
  if (config === void 0) {
    config = {};
  }
  RecognizersMap.set("hover", MoveRecognizer);
  var buildHoverConfig = (0, import_react.useRef)();
  if (!buildHoverConfig.current) {
    buildHoverConfig.current = memoizeOne(_buildHoverConfig, isEqual);
  }
  return useRecognizers({
    hover: handler
  }, buildHoverConfig.current(config));
}
function useScroll(handler, config) {
  if (config === void 0) {
    config = {};
  }
  RecognizersMap.set("scroll", ScrollRecognizer);
  var buildScrollConfig = (0, import_react.useRef)();
  if (!buildScrollConfig.current) {
    buildScrollConfig.current = memoizeOne(_buildScrollConfig, isEqual);
  }
  return useRecognizers({
    scroll: handler
  }, buildScrollConfig.current(config));
}
function sortHandlers(handlers) {
  var _native = {};
  var handle = {};
  var actions = /* @__PURE__ */ new Set();
  for (var key in handlers) {
    if (RE_NOT_NATIVE.test(key)) {
      actions.add(RegExp.lastMatch);
      handle[key] = handlers[key];
    } else {
      _native[key] = handlers[key];
    }
  }
  return [handle, _native, actions];
}
function useGesture(_handlers, config) {
  if (config === void 0) {
    config = {};
  }
  var _sortHandlers = sortHandlers(_handlers), handlers = _sortHandlers[0], nativeHandlers = _sortHandlers[1], actions = _sortHandlers[2];
  RecognizersMap.set("drag", DragRecognizer);
  RecognizersMap.set("hover", MoveRecognizer);
  RecognizersMap.set("move", MoveRecognizer);
  RecognizersMap.set("pinch", PinchRecognizer);
  RecognizersMap.set("scroll", ScrollRecognizer);
  RecognizersMap.set("wheel", WheelRecognizer);
  var mergedConfig = buildComplexConfig(config, actions);
  var internalHandlers = {};
  if (actions.has("onDrag"))
    internalHandlers.drag = includeStartEndHandlers(handlers, "onDrag");
  if (actions.has("onWheel"))
    internalHandlers.wheel = includeStartEndHandlers(handlers, "onWheel");
  if (actions.has("onScroll"))
    internalHandlers.scroll = includeStartEndHandlers(handlers, "onScroll");
  if (actions.has("onMove"))
    internalHandlers.move = includeStartEndHandlers(handlers, "onMove");
  if (actions.has("onPinch"))
    internalHandlers.pinch = includeStartEndHandlers(handlers, "onPinch");
  if (actions.has("onHover"))
    internalHandlers.hover = handlers.onHover;
  return useRecognizers(internalHandlers, mergedConfig, nativeHandlers);
}
function includeStartEndHandlers(handlers, handlerKey) {
  var startKey = handlerKey + "Start";
  var endKey = handlerKey + "End";
  var fn = function fn2(state) {
    var memo = void 0;
    if (state.first && startKey in handlers)
      handlers[startKey](state);
    if (handlerKey in handlers)
      memo = handlers[handlerKey](state);
    if (state.last && endKey in handlers)
      handlers[endKey](state);
    return memo;
  };
  return fn;
}
var import_react, identity, LINE_HEIGHT, PAGE_HEIGHT, DEFAULT_DRAG_DELAY, DEFAULT_RUBBERBAND, DEFAULT_SWIPE_VELOCITY, DEFAULT_SWIPE_DISTANCE, DEFAULT_SWIPE_DURATION, InternalGestureOptionsNormalizers, InternalCoordinatesOptionsNormalizers, isBrowser, InternalGenericOptionsNormalizers, InternalDistanceAngleOptionsNormalizers, InternalDragOptionsNormalizers, RecognizersMap, identity$1, Recognizer, Controller, CoordinatesRecognizer, TAP_DISTANCE_THRESHOLD, DragRecognizer, DistanceAngleRecognizer, ZOOM_CONSTANT, WEBKIT_DISTANCE_SCALE_FACTOR, PinchRecognizer, WheelRecognizer, MoveRecognizer, ScrollRecognizer, RE_NOT_NATIVE;
var init_reactusegesture_esm = __esm({
  "node_modules/react-use-gesture/dist/reactusegesture.esm.js"() {
    import_react = __toESM(require_react());
    identity = function identity2(xy) {
      return xy;
    };
    LINE_HEIGHT = 40;
    PAGE_HEIGHT = 800;
    DEFAULT_DRAG_DELAY = 180;
    DEFAULT_RUBBERBAND = 0.15;
    DEFAULT_SWIPE_VELOCITY = 0.5;
    DEFAULT_SWIPE_DISTANCE = 50;
    DEFAULT_SWIPE_DURATION = 250;
    InternalGestureOptionsNormalizers = {
      threshold: function threshold(value) {
        if (value === void 0) {
          value = 0;
        }
        return ensureVector(value);
      },
      rubberband: function rubberband3(value) {
        if (value === void 0) {
          value = 0;
        }
        switch (value) {
          case true:
            return ensureVector(DEFAULT_RUBBERBAND);
          case false:
            return ensureVector(0);
          default:
            return ensureVector(value);
        }
      },
      enabled: function enabled(value) {
        if (value === void 0) {
          value = true;
        }
        return value;
      },
      triggerAllEvents: function triggerAllEvents(value) {
        if (value === void 0) {
          value = false;
        }
        return value;
      },
      initial: function initial(value) {
        if (value === void 0) {
          value = 0;
        }
        if (typeof value === "function")
          return value;
        return ensureVector(value);
      },
      transform: true
    };
    InternalCoordinatesOptionsNormalizers = _extends({}, InternalGestureOptionsNormalizers, {
      axis: true,
      lockDirection: function lockDirection(value) {
        if (value === void 0) {
          value = false;
        }
        return value;
      },
      bounds: function bounds(value) {
        if (value === void 0) {
          value = {};
        }
        if (typeof value === "function")
          return function(state) {
            return InternalCoordinatesOptionsNormalizers.bounds(value(state));
          };
        var _value2 = value, _value2$left = _value2.left, left = _value2$left === void 0 ? -Infinity : _value2$left, _value2$right = _value2.right, right = _value2$right === void 0 ? Infinity : _value2$right, _value2$top = _value2.top, top = _value2$top === void 0 ? -Infinity : _value2$top, _value2$bottom = _value2.bottom, bottom = _value2$bottom === void 0 ? Infinity : _value2$bottom;
        return [[left, right], [top, bottom]];
      }
    });
    isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
    InternalGenericOptionsNormalizers = {
      enabled: function enabled2(value) {
        if (value === void 0) {
          value = true;
        }
        return value;
      },
      domTarget: true,
      window: function(_window) {
        function window2(_x) {
          return _window.apply(this, arguments);
        }
        window2.toString = function() {
          return _window.toString();
        };
        return window2;
      }(function(value) {
        if (value === void 0) {
          value = isBrowser ? window : void 0;
        }
        return value;
      }),
      eventOptions: function eventOptions(_temp) {
        var _ref = _temp === void 0 ? {} : _temp, _ref$passive = _ref.passive, passive = _ref$passive === void 0 ? true : _ref$passive, _ref$capture = _ref.capture, capture = _ref$capture === void 0 ? false : _ref$capture;
        return {
          passive,
          capture
        };
      },
      transform: true
    };
    InternalDistanceAngleOptionsNormalizers = _extends({}, InternalGestureOptionsNormalizers, {
      bounds: function bounds2(_value, _key, _ref2) {
        var _ref2$distanceBounds = _ref2.distanceBounds, distanceBounds = _ref2$distanceBounds === void 0 ? {} : _ref2$distanceBounds, _ref2$angleBounds = _ref2.angleBounds, angleBounds = _ref2$angleBounds === void 0 ? {} : _ref2$angleBounds;
        var _distanceBounds = function _distanceBounds2(state) {
          var D = assignDefault(valueFn(distanceBounds, state), {
            min: -Infinity,
            max: Infinity
          });
          return [D.min, D.max];
        };
        var _angleBounds = function _angleBounds2(state) {
          var A = assignDefault(valueFn(angleBounds, state), {
            min: -Infinity,
            max: Infinity
          });
          return [A.min, A.max];
        };
        if (typeof distanceBounds !== "function" && typeof angleBounds !== "function")
          return [_distanceBounds(), _angleBounds()];
        return function(state) {
          return [_distanceBounds(state), _angleBounds(state)];
        };
      }
    });
    InternalDragOptionsNormalizers = _extends({}, InternalCoordinatesOptionsNormalizers, {
      useTouch: function useTouch(value) {
        if (value === void 0) {
          value = false;
        }
        var supportsTouch = supportsTouchEvents();
        var supportsPointer = supportsPointerEvents();
        if (value && supportsTouch)
          return true;
        if (supportsTouch && !supportsPointer)
          return true;
        return false;
      },
      experimental_preventWindowScrollY: function experimental_preventWindowScrollY(value) {
        if (value === void 0) {
          value = false;
        }
        return value;
      },
      threshold: function threshold2(v, _k, _ref3) {
        var _ref3$filterTaps = _ref3.filterTaps, filterTaps = _ref3$filterTaps === void 0 ? false : _ref3$filterTaps, _ref3$lockDirection = _ref3.lockDirection, lockDirection2 = _ref3$lockDirection === void 0 ? false : _ref3$lockDirection, _ref3$axis = _ref3.axis, axis = _ref3$axis === void 0 ? void 0 : _ref3$axis;
        var A = ensureVector(v, filterTaps ? 3 : lockDirection2 ? 1 : axis ? 1 : 0);
        this.filterTaps = filterTaps;
        return A;
      },
      swipeVelocity: function swipeVelocity(v) {
        if (v === void 0) {
          v = DEFAULT_SWIPE_VELOCITY;
        }
        return ensureVector(v);
      },
      swipeDistance: function swipeDistance(v) {
        if (v === void 0) {
          v = DEFAULT_SWIPE_DISTANCE;
        }
        return ensureVector(v);
      },
      swipeDuration: function swipeDuration(value) {
        if (value === void 0) {
          value = DEFAULT_SWIPE_DURATION;
        }
        return value;
      },
      delay: function delay(value) {
        if (value === void 0) {
          value = 0;
        }
        switch (value) {
          case true:
            return DEFAULT_DRAG_DELAY;
          case false:
            return 0;
          default:
            return value;
        }
      }
    });
    RecognizersMap = /* @__PURE__ */ new Map();
    identity$1 = function identity3(xy) {
      return xy;
    };
    Recognizer = function() {
      function Recognizer2(controller, args) {
        var _this = this;
        if (args === void 0) {
          args = [];
        }
        this.controller = controller;
        this.args = args;
        this.debounced = true;
        this.setTimeout = function(callback, ms) {
          var _window;
          if (ms === void 0) {
            ms = 140;
          }
          clearTimeout(_this.controller.timeouts[_this.stateKey]);
          for (var _len = arguments.length, args2 = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args2[_key - 2] = arguments[_key];
          }
          _this.controller.timeouts[_this.stateKey] = (_window = window).setTimeout.apply(_window, [callback, ms].concat(args2));
        };
        this.clearTimeout = function() {
          clearTimeout(_this.controller.timeouts[_this.stateKey]);
        };
        this.fireGestureHandler = function(forceFlag) {
          if (forceFlag === void 0) {
            forceFlag = false;
          }
          if (_this.state._blocked) {
            if (!_this.debounced) {
              _this.state._active = false;
              _this.clean();
            }
            return null;
          }
          if (!forceFlag && !_this.state.intentional && !_this.config.triggerAllEvents)
            return null;
          if (_this.state.intentional) {
            var prev_active = _this.state.active;
            var next_active = _this.state._active;
            _this.state.active = next_active;
            _this.state.first = next_active && !prev_active;
            _this.state.last = prev_active && !next_active;
            _this.controller.state.shared[_this.ingKey] = next_active;
          }
          var touches = _this.controller.pointerIds.size || _this.controller.touchIds.size;
          var down = _this.controller.state.shared.buttons > 0 || touches > 0;
          var state = _extends({}, _this.controller.state.shared, _this.state, _this.mapStateValues(_this.state), {
            locked: !!document.pointerLockElement,
            touches,
            down
          });
          var newMemo = _this.handler(state);
          _this.state.memo = newMemo !== void 0 ? newMemo : _this.state.memo;
          return state;
        };
        this.controller = controller;
        this.args = args;
      }
      var _proto = Recognizer2.prototype;
      _proto.updateSharedState = function updateSharedState(sharedState) {
        Object.assign(this.controller.state.shared, sharedState);
      };
      _proto.updateGestureState = function updateGestureState(gestureState) {
        Object.assign(this.state, gestureState);
      };
      _proto.checkIntentionality = function checkIntentionality(_intentional, _movement) {
        return {
          _intentional,
          _blocked: false
        };
      };
      _proto.getMovement = function getMovement(values) {
        var rubberband4 = this.config.rubberband;
        var _this$state = this.state, _bounds = _this$state._bounds, _initial = _this$state._initial, _active = _this$state._active, wasIntentional = _this$state._intentional, lastOffset = _this$state.lastOffset, prevMovement = _this$state.movement, _T = _this$state._threshold;
        var M = this.getInternalMovement(values, this.state);
        var i0 = wasIntentional[0] === false ? getIntentionalDisplacement(M[0], _T[0]) : wasIntentional[0];
        var i1 = wasIntentional[1] === false ? getIntentionalDisplacement(M[1], _T[1]) : wasIntentional[1];
        var intentionalityCheck = this.checkIntentionality([i0, i1], M);
        if (intentionalityCheck._blocked) {
          return _extends({}, intentionalityCheck, {
            _movement: M,
            delta: [0, 0]
          });
        }
        var _intentional = intentionalityCheck._intentional;
        var _movement = M;
        var movement = [_intentional[0] !== false ? M[0] - _intentional[0] : 0, _intentional[1] !== false ? M[1] - _intentional[1] : 0];
        var offset = addV(movement, lastOffset);
        var _rubberband = _active ? rubberband4 : [0, 0];
        movement = computeRubberband(_bounds, addV(movement, _initial), _rubberband);
        return _extends({}, intentionalityCheck, {
          intentional: _intentional[0] !== false || _intentional[1] !== false,
          _initial,
          _movement,
          movement,
          values,
          offset: computeRubberband(_bounds, offset, _rubberband),
          delta: subV(movement, prevMovement)
        });
      };
      _proto.clean = function clean() {
        this.clearTimeout();
      };
      _createClass(Recognizer2, [{
        key: "config",
        get: function get() {
          return this.controller.config[this.stateKey];
        }
        // Is the gesture enabled
      }, {
        key: "enabled",
        get: function get() {
          return this.controller.config.enabled && this.config.enabled;
        }
        // Returns the controller state for a given gesture
      }, {
        key: "state",
        get: function get() {
          return this.controller.state[this.stateKey];
        }
        // Returns the gesture handler
      }, {
        key: "handler",
        get: function get() {
          return this.controller.handlers[this.stateKey];
        }
      }, {
        key: "transform",
        get: function get() {
          return this.config.transform || this.controller.config.transform || identity$1;
        }
      }]);
      return Recognizer2;
    }();
    Controller = function Controller2(classes) {
      var _this = this;
      this.classes = classes;
      this.pointerIds = /* @__PURE__ */ new Set();
      this.touchIds = /* @__PURE__ */ new Set();
      this.supportsTouchEvents = supportsTouchEvents();
      this.supportsGestureEvents = supportsGestureEvents();
      this.bind = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var bindings = {};
        for (var _iterator = _createForOfIteratorHelperLoose(_this.classes), _step; !(_step = _iterator()).done; ) {
          var RecognizerClass = _step.value;
          new RecognizerClass(_this, args).addBindings(bindings);
        }
        var _loop = function _loop2(eventKey2) {
          addBindings(bindings, eventKey2, function(event) {
            return _this.nativeRefs[eventKey2](_extends({}, _this.state.shared, {
              event,
              args
            }));
          });
        };
        for (var eventKey in _this.nativeRefs) {
          _loop(eventKey);
        }
        if (_this.config.domTarget) {
          return updateDomListeners(_this, bindings);
        } else {
          return getPropsListener(_this, bindings);
        }
      };
      this.effect = function() {
        if (_this.config.domTarget)
          _this.bind();
        return _this.clean;
      };
      this.clean = function() {
        var domTarget = getDomTargetFromConfig(_this.config);
        var eventOptions2 = _this.config.eventOptions;
        if (domTarget)
          removeListeners(domTarget, takeAll(_this.domListeners), eventOptions2);
        Object.values(_this.timeouts).forEach(clearTimeout);
        clearAllWindowListeners(_this);
      };
      this.classes = classes;
      this.state = getInitialState();
      this.timeouts = {};
      this.domListeners = [];
      this.windowListeners = {};
    };
    CoordinatesRecognizer = function(_Recognizer) {
      _inheritsLoose(CoordinatesRecognizer2, _Recognizer);
      function CoordinatesRecognizer2() {
        return _Recognizer.apply(this, arguments) || this;
      }
      var _proto = CoordinatesRecognizer2.prototype;
      _proto.getInternalMovement = function getInternalMovement(values, state) {
        return subV(values, state.initial);
      };
      _proto.checkIntentionality = function checkIntentionality(_intentional, _movement) {
        if (_intentional[0] === false && _intentional[1] === false) {
          return {
            _intentional,
            axis: this.state.axis
          };
        }
        var _movement$map = _movement.map(Math.abs), absX = _movement$map[0], absY = _movement$map[1];
        var axis = this.state.axis || (absX > absY ? "x" : absX < absY ? "y" : void 0);
        if (!this.config.axis && !this.config.lockDirection)
          return {
            _intentional,
            _blocked: false,
            axis
          };
        if (!axis)
          return {
            _intentional: [false, false],
            _blocked: false,
            axis
          };
        if (!!this.config.axis && axis !== this.config.axis)
          return {
            _intentional,
            _blocked: true,
            axis
          };
        _intentional[axis === "x" ? 1 : 0] = false;
        return {
          _intentional,
          _blocked: false,
          axis
        };
      };
      _proto.getKinematics = function getKinematics(values, event) {
        var state = this.getMovement(values);
        if (!state._blocked) {
          var dt = event.timeStamp - this.state.timeStamp;
          Object.assign(state, calculateAllKinematics(state.movement, state.delta, dt));
        }
        return state;
      };
      _proto.mapStateValues = function mapStateValues(state) {
        return {
          xy: state.values,
          vxvy: state.velocities
        };
      };
      return CoordinatesRecognizer2;
    }(Recognizer);
    TAP_DISTANCE_THRESHOLD = 3;
    DragRecognizer = function(_CoordinatesRecognize) {
      _inheritsLoose(DragRecognizer2, _CoordinatesRecognize);
      function DragRecognizer2() {
        var _this;
        _this = _CoordinatesRecognize.apply(this, arguments) || this;
        _this.ingKey = "dragging";
        _this.stateKey = "drag";
        _this.setPointerCapture = function(event) {
          if (_this.config.useTouch || document.pointerLockElement)
            return;
          var target = event.target, pointerId = event.pointerId;
          if (target && "setPointerCapture" in target) {
            target.setPointerCapture(pointerId);
          }
          _this.updateGestureState({
            _dragTarget: target,
            _dragPointerId: pointerId
          });
        };
        _this.releasePointerCapture = function() {
          if (_this.config.useTouch || document.pointerLockElement)
            return;
          var _this$state = _this.state, _dragTarget = _this$state._dragTarget, _dragPointerId = _this$state._dragPointerId;
          if (_dragPointerId && _dragTarget && "releasePointerCapture" in _dragTarget) {
            if (!("hasPointerCapture" in _dragTarget) || _dragTarget.hasPointerCapture(_dragPointerId))
              try {
                _dragTarget.releasePointerCapture(_dragPointerId);
              } catch (e) {
              }
          }
        };
        _this.preventScroll = function(event) {
          if (_this.state._dragPreventScroll && event.cancelable) {
            event.preventDefault();
          }
        };
        _this.getEventId = function(event) {
          if (_this.config.useTouch)
            return event.changedTouches[0].identifier;
          return event.pointerId;
        };
        _this.isValidEvent = function(event) {
          return _this.state._pointerId === _this.getEventId(event);
        };
        _this.shouldPreventWindowScrollY = _this.config.experimental_preventWindowScrollY && _this.controller.supportsTouchEvents;
        _this.setUpWindowScrollDetection = function(event) {
          persistEvent(event);
          updateWindowListeners(_this.controller, _this.stateKey, [["touchmove", _this.preventScroll], ["touchend", _this.clean.bind(_assertThisInitialized(_this))], ["touchcancel", _this.clean.bind(_assertThisInitialized(_this))]], {
            passive: false
          });
          _this.setTimeout(_this.startDrag.bind(_assertThisInitialized(_this)), 250, event);
        };
        _this.setUpDelayedDragTrigger = function(event) {
          _this.state._dragDelayed = true;
          persistEvent(event);
          _this.setTimeout(_this.startDrag.bind(_assertThisInitialized(_this)), _this.config.delay, event);
        };
        _this.setStartState = function(event) {
          var values = getPointerEventValues(event, _this.transform);
          _this.updateSharedState(getGenericEventData(event));
          _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {
            _pointerId: _this.getEventId(event)
          }));
          _this.updateGestureState(_this.getMovement(values));
        };
        _this.onDragStart = function(event) {
          addEventIds(_this.controller, event);
          if (!_this.enabled || _this.state._active)
            return;
          _this.setStartState(event);
          _this.setPointerCapture(event);
          if (_this.shouldPreventWindowScrollY)
            _this.setUpWindowScrollDetection(event);
          else if (_this.config.delay > 0)
            _this.setUpDelayedDragTrigger(event);
          else
            _this.startDrag(event, true);
        };
        _this.onDragChange = function(event) {
          if (
            // if the gesture was canceled or
            _this.state.canceled || // if onDragStart wasn't fired or
            !_this.state._active || // if the event pointerId doesn't match the one that initiated the drag
            !_this.isValidEvent(event) || // if the event has the same timestamp as the previous event
            // note that checking type equality is ONLY for tests ¯\_(ツ)_/¯
            _this.state._lastEventType === event.type && event.timeStamp === _this.state.timeStamp
          )
            return;
          var values;
          if (document.pointerLockElement) {
            var movementX = event.movementX, movementY = event.movementY;
            values = addV(_this.transform([movementX, movementY]), _this.state.values);
          } else
            values = getPointerEventValues(event, _this.transform);
          var kinematics = _this.getKinematics(values, event);
          if (!_this.state._dragStarted) {
            if (_this.state._dragDelayed) {
              _this.startDrag(event);
              return;
            }
            if (_this.shouldPreventWindowScrollY) {
              if (!_this.state._dragPreventScroll && kinematics.axis) {
                if (kinematics.axis === "x") {
                  _this.startDrag(event);
                } else {
                  _this.state._active = false;
                  return;
                }
              } else
                return;
            } else
              return;
          }
          var genericEventData = getGenericEventData(event);
          _this.updateSharedState(genericEventData);
          var genericPayload = getGenericPayload(_assertThisInitialized(_this), event);
          var realDistance = calculateDistance(kinematics._movement);
          var _dragIsTap = _this.state._dragIsTap;
          if (_dragIsTap && realDistance >= TAP_DISTANCE_THRESHOLD)
            _dragIsTap = false;
          _this.updateGestureState(_extends({}, genericPayload, kinematics, {
            _dragIsTap
          }));
          _this.fireGestureHandler();
        };
        _this.onDragEnd = function(event) {
          removeEventIds(_this.controller, event);
          if (!_this.isValidEvent(event))
            return;
          _this.clean();
          if (!_this.state._active)
            return;
          _this.state._active = false;
          var tap = _this.state._dragIsTap;
          var _this$state$velocitie = _this.state.velocities, vx = _this$state$velocitie[0], vy = _this$state$velocitie[1];
          var _this$state$movement = _this.state.movement, mx = _this$state$movement[0], my = _this$state$movement[1];
          var _this$state$_intentio = _this.state._intentional, ix = _this$state$_intentio[0], iy = _this$state$_intentio[1];
          var _this$config$swipeVel = _this.config.swipeVelocity, svx = _this$config$swipeVel[0], svy = _this$config$swipeVel[1];
          var _this$config$swipeDis = _this.config.swipeDistance, sx = _this$config$swipeDis[0], sy = _this$config$swipeDis[1];
          var sd = _this.config.swipeDuration;
          var endState = _extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values));
          var swipe = [0, 0];
          if (endState.elapsedTime < sd) {
            if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx)
              swipe[0] = sign(vx);
            if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy)
              swipe[1] = sign(vy);
          }
          _this.updateSharedState({
            buttons: 0
          });
          _this.updateGestureState(_extends({}, endState, {
            tap,
            swipe
          }));
          _this.fireGestureHandler(_this.config.filterTaps && tap === true);
        };
        _this.clean = function() {
          _CoordinatesRecognize.prototype.clean.call(_assertThisInitialized(_this));
          _this.state._dragStarted = false;
          _this.releasePointerCapture();
          clearWindowListeners(_this.controller, _this.stateKey);
        };
        _this.onCancel = function() {
          if (_this.state.canceled)
            return;
          _this.updateGestureState({
            canceled: true,
            _active: false
          });
          _this.updateSharedState({
            buttons: 0
          });
          setTimeout(function() {
            return _this.fireGestureHandler();
          }, 0);
        };
        _this.onClick = function(event) {
          if (!_this.state._dragIsTap)
            event.stopPropagation();
        };
        return _this;
      }
      var _proto = DragRecognizer2.prototype;
      _proto.startDrag = function startDrag(event, onDragIsStart) {
        if (onDragIsStart === void 0) {
          onDragIsStart = false;
        }
        if (
          // if the gesture isn't active (probably means)
          !this.state._active || // if the drag has already started we should ignore subsequent attempts
          this.state._dragStarted
        )
          return;
        if (!onDragIsStart)
          this.setStartState(event);
        this.updateGestureState({
          _dragStarted: true,
          _dragPreventScroll: true,
          cancel: this.onCancel
        });
        this.clearTimeout();
        this.fireGestureHandler();
      };
      _proto.addBindings = function addBindings$1(bindings) {
        if (this.config.useTouch) {
          addBindings(bindings, "onTouchStart", this.onDragStart);
          addBindings(bindings, "onTouchMove", this.onDragChange);
          addBindings(bindings, "onTouchEnd", this.onDragEnd);
          addBindings(bindings, "onTouchCancel", this.onDragEnd);
        } else {
          addBindings(bindings, "onPointerDown", this.onDragStart);
          addBindings(bindings, "onPointerMove", this.onDragChange);
          addBindings(bindings, "onPointerUp", this.onDragEnd);
          addBindings(bindings, "onPointerCancel", this.onDragEnd);
        }
        if (this.config.filterTaps) {
          var handler = this.controller.config.eventOptions.capture ? "onClick" : "onClickCapture";
          addBindings(bindings, handler, this.onClick);
        }
      };
      return DragRecognizer2;
    }(CoordinatesRecognizer);
    DistanceAngleRecognizer = function(_Recognizer) {
      _inheritsLoose(DistanceAngleRecognizer2, _Recognizer);
      function DistanceAngleRecognizer2() {
        return _Recognizer.apply(this, arguments) || this;
      }
      var _proto = DistanceAngleRecognizer2.prototype;
      _proto.getInternalMovement = function getInternalMovement(values, state) {
        var prev_a = state.values[1];
        var d = values[0], _values$ = values[1], a = _values$ === void 0 ? prev_a : _values$;
        var delta_a = a - prev_a;
        var next_turns = state.turns;
        if (Math.abs(delta_a) > 270)
          next_turns += sign(delta_a);
        return subV([d, a - 360 * next_turns], state.initial);
      };
      _proto.getKinematics = function getKinematics(values, event) {
        var state = this.getMovement(values);
        var turns = (values[1] - state._movement[1] - this.state.initial[1]) / 360;
        var dt = event.timeStamp - this.state.timeStamp;
        var _calculateAllKinemati = calculateAllKinematics(state.movement, state.delta, dt), kinematics = _objectWithoutPropertiesLoose(_calculateAllKinemati, ["distance", "velocity"]);
        return _extends({
          turns
        }, state, kinematics);
      };
      _proto.mapStateValues = function mapStateValues(state) {
        return {
          da: state.values,
          vdva: state.velocities
        };
      };
      return DistanceAngleRecognizer2;
    }(Recognizer);
    ZOOM_CONSTANT = 7;
    WEBKIT_DISTANCE_SCALE_FACTOR = 260;
    PinchRecognizer = function(_DistanceAngleRecogni) {
      _inheritsLoose(PinchRecognizer2, _DistanceAngleRecogni);
      function PinchRecognizer2() {
        var _this;
        _this = _DistanceAngleRecogni.apply(this, arguments) || this;
        _this.ingKey = "pinching";
        _this.stateKey = "pinch";
        _this.onPinchStart = function(event) {
          addEventIds(_this.controller, event);
          var touchIds = _this.controller.touchIds;
          if (!_this.enabled)
            return;
          if (_this.state._active) {
            if (_this.state._pointerIds.every(function(id) {
              return touchIds.has(id);
            }))
              return;
          }
          if (touchIds.size < 2)
            return;
          var _pointerIds = Array.from(touchIds).slice(0, 2);
          var _getTwoTouchesEventVa = getTwoTouchesEventValues(event, _pointerIds, _this.transform), values = _getTwoTouchesEventVa.values, origin = _getTwoTouchesEventVa.origin;
          _this.updateSharedState(getGenericEventData(event));
          _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {
            _pointerIds,
            cancel: _this.onCancel,
            origin
          }));
          _this.updateGestureState(_this.getMovement(values));
          _this.fireGestureHandler();
        };
        _this.onPinchChange = function(event) {
          var _this$state = _this.state, canceled = _this$state.canceled, _active = _this$state._active;
          if (canceled || !_active || // if the event has the same timestamp as the previous event
          event.timeStamp === _this.state.timeStamp)
            return;
          var genericEventData = getGenericEventData(event);
          _this.updateSharedState(genericEventData);
          try {
            var _getTwoTouchesEventVa2 = getTwoTouchesEventValues(event, _this.state._pointerIds, _this.transform), values = _getTwoTouchesEventVa2.values, origin = _getTwoTouchesEventVa2.origin;
            var kinematics = _this.getKinematics(values, event);
            _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), kinematics, {
              origin
            }));
            _this.fireGestureHandler();
          } catch (e) {
            _this.onPinchEnd(event);
          }
        };
        _this.onPinchEnd = function(event) {
          removeEventIds(_this.controller, event);
          var pointerIds = getTouchIds(event);
          if (_this.state._pointerIds.every(function(id) {
            return !pointerIds.includes(id);
          }))
            return;
          _this.clean();
          if (!_this.state._active)
            return;
          _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values), {
            _active: false
          }));
          _this.fireGestureHandler();
        };
        _this.onCancel = function() {
          if (_this.state.canceled)
            return;
          _this.updateGestureState({
            _active: false,
            canceled: true
          });
          setTimeout(function() {
            return _this.fireGestureHandler();
          }, 0);
        };
        _this.onGestureStart = function(event) {
          if (!_this.enabled)
            return;
          event.preventDefault();
          var values = getWebkitGestureEventValues(event, _this.transform);
          _this.updateSharedState(getGenericEventData(event));
          _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {
            origin: [event.clientX, event.clientY],
            cancel: _this.onCancel
          }));
          _this.updateGestureState(_this.getMovement(values));
          _this.fireGestureHandler();
        };
        _this.onGestureChange = function(event) {
          var _this$state2 = _this.state, canceled = _this$state2.canceled, _active = _this$state2._active;
          if (canceled || !_active)
            return;
          event.preventDefault();
          var genericEventData = getGenericEventData(event);
          _this.updateSharedState(genericEventData);
          var values = getWebkitGestureEventValues(event, _this.transform);
          values[0] = (values[0] - _this.state.event.scale) * WEBKIT_DISTANCE_SCALE_FACTOR + _this.state.values[0];
          var kinematics = _this.getKinematics(values, event);
          _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), kinematics, {
            origin: [event.clientX, event.clientY]
          }));
          _this.fireGestureHandler();
        };
        _this.onGestureEnd = function(event) {
          _this.clean();
          if (!_this.state._active)
            return;
          _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values), {
            _active: false,
            origin: [event.clientX, event.clientY]
          }));
          _this.fireGestureHandler();
        };
        _this.wheelShouldRun = function(event) {
          return _this.enabled && event.ctrlKey;
        };
        _this.getWheelValuesFromEvent = function(event) {
          var _getWheelEventValues = getWheelEventValues(event, _this.transform), delta_d = _getWheelEventValues[1];
          var _this$state$values = _this.state.values, prev_d = _this$state$values[0], prev_a = _this$state$values[1];
          var _delta_d = -delta_d * ZOOM_CONSTANT;
          var d = prev_d + _delta_d;
          var a = prev_a !== void 0 ? prev_a : 0;
          return {
            values: [d, a],
            origin: [event.clientX, event.clientY],
            delta: [_delta_d, a]
          };
        };
        _this.onWheel = function(event) {
          if (!_this.wheelShouldRun(event))
            return;
          _this.setTimeout(_this.onWheelEnd);
          if (!_this.state._active)
            _this.onWheelStart(event);
          else
            _this.onWheelChange(event);
        };
        _this.onWheelStart = function(event) {
          var _this$getWheelValuesF = _this.getWheelValuesFromEvent(event), values = _this$getWheelValuesF.values, delta = _this$getWheelValuesF.delta, origin = _this$getWheelValuesF.origin;
          if (event.cancelable)
            event.preventDefault();
          else if (true) {
            console.warn("To properly support zoom on trackpads, try using the `domTarget` option and `config.eventOptions.passive` set to `false`. This message will only appear in development mode.");
          }
          _this.updateSharedState(getGenericEventData(event));
          _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event, _this.state.values), getGenericPayload(_assertThisInitialized(_this), event, true), {
            offset: values,
            delta,
            origin
          }));
          _this.updateGestureState(_this.getMovement(values));
          _this.fireGestureHandler();
        };
        _this.onWheelChange = function(event) {
          if (event.cancelable)
            event.preventDefault();
          _this.updateSharedState(getGenericEventData(event));
          var _this$getWheelValuesF2 = _this.getWheelValuesFromEvent(event), values = _this$getWheelValuesF2.values, origin = _this$getWheelValuesF2.origin, delta = _this$getWheelValuesF2.delta;
          _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event), {
            origin,
            delta
          }));
          _this.fireGestureHandler();
        };
        _this.onWheelEnd = function() {
          _this.clean();
          if (!_this.state._active)
            return;
          _this.state._active = false;
          _this.updateGestureState(_this.getMovement(_this.state.values));
          _this.fireGestureHandler();
        };
        return _this;
      }
      var _proto = PinchRecognizer2.prototype;
      _proto.addBindings = function addBindings$1(bindings) {
        if (this.controller.config.domTarget && !this.controller.supportsTouchEvents && this.controller.supportsGestureEvents) {
          addBindings(bindings, "onGestureStart", this.onGestureStart);
          addBindings(bindings, "onGestureChange", this.onGestureChange);
          addBindings(bindings, "onGestureEnd", this.onGestureEnd);
        } else {
          addBindings(bindings, "onTouchStart", this.onPinchStart);
          addBindings(bindings, "onTouchMove", this.onPinchChange);
          addBindings(bindings, "onTouchEnd", this.onPinchEnd);
          addBindings(bindings, "onTouchCancel", this.onPinchEnd);
          addBindings(bindings, "onWheel", this.onWheel);
        }
      };
      return PinchRecognizer2;
    }(DistanceAngleRecognizer);
    WheelRecognizer = function(_CoordinatesRecognize) {
      _inheritsLoose(WheelRecognizer2, _CoordinatesRecognize);
      function WheelRecognizer2() {
        var _this;
        _this = _CoordinatesRecognize.apply(this, arguments) || this;
        _this.ingKey = "wheeling";
        _this.stateKey = "wheel";
        _this.debounced = true;
        _this.handleEvent = function(event) {
          if (event.ctrlKey && "pinch" in _this.controller.handlers)
            return;
          if (!_this.enabled)
            return;
          _this.setTimeout(_this.onEnd);
          _this.updateSharedState(getGenericEventData(event));
          var values = addV(getWheelEventValues(event, _this.transform), _this.state.values);
          if (!_this.state._active) {
            _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event, _this.state.values), getGenericPayload(_assertThisInitialized(_this), event, true)));
            var movement = _this.getMovement(values);
            var geometry = calculateAllGeometry(movement.delta);
            _this.updateGestureState(movement);
            _this.updateGestureState(geometry);
          } else {
            _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));
          }
          _this.fireGestureHandler();
        };
        _this.onEnd = function() {
          _this.clean();
          if (!_this.state._active)
            return;
          var movement = _this.getMovement(_this.state.values);
          _this.updateGestureState(movement);
          _this.updateGestureState({
            _active: false,
            velocities: [0, 0],
            velocity: 0
          });
          _this.fireGestureHandler();
        };
        return _this;
      }
      var _proto = WheelRecognizer2.prototype;
      _proto.addBindings = function addBindings$1(bindings) {
        addBindings(bindings, "onWheel", this.handleEvent);
      };
      return WheelRecognizer2;
    }(CoordinatesRecognizer);
    MoveRecognizer = function(_CoordinatesRecognize) {
      _inheritsLoose(MoveRecognizer2, _CoordinatesRecognize);
      function MoveRecognizer2() {
        var _this;
        _this = _CoordinatesRecognize.apply(this, arguments) || this;
        _this.ingKey = "moving";
        _this.stateKey = "move";
        _this.debounced = true;
        _this.onMove = function(event) {
          if (!_this.enabled)
            return;
          _this.setTimeout(_this.onMoveEnd);
          if (!_this.state._active)
            _this.onMoveStart(event);
          else
            _this.onMoveChange(event);
        };
        _this.onMoveStart = function(event) {
          _this.updateSharedState(getGenericEventData(event));
          var values = getPointerEventValues(event, _this.transform);
          _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true)));
          _this.updateGestureState(_this.getMovement(values));
          _this.fireGestureHandler();
        };
        _this.onMoveChange = function(event) {
          _this.updateSharedState(getGenericEventData(event));
          var values = getPointerEventValues(event, _this.transform);
          _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));
          _this.fireGestureHandler();
        };
        _this.onMoveEnd = function() {
          _this.clean();
          if (!_this.state._active)
            return;
          var values = _this.state.values;
          _this.updateGestureState(_this.getMovement(values));
          _this.updateGestureState({
            velocities: [0, 0],
            velocity: 0,
            _active: false
          });
          _this.fireGestureHandler();
        };
        _this.hoverTransform = function() {
          return _this.controller.config.hover.transform || _this.controller.config.transform;
        };
        _this.onPointerEnter = function(event) {
          _this.controller.state.shared.hovering = true;
          if (!_this.controller.config.enabled)
            return;
          if (_this.controller.config.hover.enabled) {
            var values = getPointerEventValues(event, _this.hoverTransform());
            var state = _extends({}, _this.controller.state.shared, _this.state, getGenericPayload(_assertThisInitialized(_this), event, true), {
              args: _this.args,
              values,
              active: true,
              hovering: true
            });
            _this.controller.handlers.hover(_extends({}, state, _this.mapStateValues(state)));
          }
          if ("move" in _this.controller.handlers)
            _this.onMoveStart(event);
        };
        _this.onPointerLeave = function(event) {
          _this.controller.state.shared.hovering = false;
          if ("move" in _this.controller.handlers)
            _this.onMoveEnd();
          if (!_this.controller.config.hover.enabled)
            return;
          var values = getPointerEventValues(event, _this.hoverTransform());
          var state = _extends({}, _this.controller.state.shared, _this.state, getGenericPayload(_assertThisInitialized(_this), event), {
            args: _this.args,
            values,
            active: false
          });
          _this.controller.handlers.hover(_extends({}, state, _this.mapStateValues(state)));
        };
        return _this;
      }
      var _proto = MoveRecognizer2.prototype;
      _proto.addBindings = function addBindings$1(bindings) {
        if ("move" in this.controller.handlers) {
          addBindings(bindings, "onPointerMove", this.onMove);
        }
        if ("hover" in this.controller.handlers) {
          addBindings(bindings, "onPointerEnter", this.onPointerEnter);
          addBindings(bindings, "onPointerLeave", this.onPointerLeave);
        }
      };
      return MoveRecognizer2;
    }(CoordinatesRecognizer);
    ScrollRecognizer = function(_CoordinatesRecognize) {
      _inheritsLoose(ScrollRecognizer2, _CoordinatesRecognize);
      function ScrollRecognizer2() {
        var _this;
        _this = _CoordinatesRecognize.apply(this, arguments) || this;
        _this.ingKey = "scrolling";
        _this.stateKey = "scroll";
        _this.debounced = true;
        _this.handleEvent = function(event) {
          if (!_this.enabled)
            return;
          _this.clearTimeout();
          _this.setTimeout(_this.onEnd);
          var values = getScrollEventValues(event, _this.transform);
          _this.updateSharedState(getGenericEventData(event));
          if (!_this.state._active) {
            _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event, _this.state.values), getGenericPayload(_assertThisInitialized(_this), event, true)));
            var movementDetection = _this.getMovement(values);
            var geometry = calculateAllGeometry(movementDetection.delta);
            _this.updateGestureState(movementDetection);
            _this.updateGestureState(geometry);
          } else {
            _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));
          }
          _this.fireGestureHandler();
        };
        _this.onEnd = function() {
          _this.clean();
          if (!_this.state._active)
            return;
          _this.updateGestureState(_extends({}, _this.getMovement(_this.state.values), {
            _active: false,
            velocities: [0, 0],
            velocity: 0
          }));
          _this.fireGestureHandler();
        };
        return _this;
      }
      var _proto = ScrollRecognizer2.prototype;
      _proto.addBindings = function addBindings$1(bindings) {
        addBindings(bindings, "onScroll", this.handleEvent);
      };
      return ScrollRecognizer2;
    }(CoordinatesRecognizer);
    RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof(o) {
      "@babel/helpers - typeof";
      return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
    }
    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS({
  "node_modules/@babel/runtime/helpers/toPrimitive.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    function toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t)
        return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i))
          return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS({
  "node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    var toPrimitive = require_toPrimitive();
    function toPropertyKey(t) {
      var i = toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module) {
    var toPropertyKey = require_toPropertyKey();
    function _defineProperty(e, r, t) {
      return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e[r] = t, e;
    }
    module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/objectWithoutProperties.js
var require_objectWithoutProperties = __commonJS({
  "node_modules/@babel/runtime/helpers/objectWithoutProperties.js"(exports, module) {
    var objectWithoutPropertiesLoose = require_objectWithoutPropertiesLoose();
    function _objectWithoutProperties(e, t) {
      if (null == e)
        return {};
      var o, r, i = objectWithoutPropertiesLoose(e, t);
      if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for (r = 0; r < s.length; r++)
          o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    module.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/react-spring-lightbox/dist/index.cjs.js
var require_index_cjs = __commonJS({
  "node_modules/react-spring-lightbox/dist/index.cjs.js"(exports, module) {
    var e = require_react();
    var t = require_extends();
    var n = require_cjs6();
    var r = (init_reactusegesture_esm(), __toCommonJS(reactusegesture_esm_exports));
    var i = require_defineProperty();
    var a = require_objectWithoutProperties();
    var l = (init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports));
    var o = require_react_dom();
    function s(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function c(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var t2 = /* @__PURE__ */ Object.create(null);
      return e2 && Object.keys(e2).forEach(function(n2) {
        if ("default" !== n2) {
          var r2 = Object.getOwnPropertyDescriptor(e2, n2);
          Object.defineProperty(t2, n2, r2.get ? r2 : { enumerable: true, get: function() {
            return e2[n2];
          } });
        }
      }), t2.default = e2, Object.freeze(t2);
    }
    var u = c(e);
    var d = s(t);
    var g = s(i);
    var f = s(a);
    var p = s(l);
    var m = s(o);
    var h = (e2) => {
      var _a;
      let { currentTranslate: [t2, n2], imageRef: r2, pinchDelta: i2, scale: a2, touchOrigin: [l2, o2] } = e2;
      if (!(r2 == null ? void 0 : r2.current))
        return [0, 0];
      const { height: s2, left: c2, top: u2, width: d2 } = (_a = r2.current) == null ? void 0 : _a.getBoundingClientRect();
      return [-((l2 - c2 - d2 / 2) / a2) * i2 + t2, -((o2 - u2 - s2 / 2) / a2) * i2 + n2];
    };
    var v = (e2) => {
      var _a;
      if (!e2.current)
        return false;
      const { bottom: t2, left: n2, right: r2, top: i2 } = (_a = e2.current) == null ? void 0 : _a.getBoundingClientRect(), { innerHeight: a2, innerWidth: l2 } = window;
      return n2 > 0.5 * l2 || i2 > 0.5 * a2 || r2 < 0.5 * l2 || t2 < 0.5 * a2;
    };
    var y = ["style"];
    function b(e2, t2) {
      var n2 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var r2 = Object.getOwnPropertySymbols(e2);
        t2 && (r2 = r2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), n2.push.apply(n2, r2);
      }
      return n2;
    }
    function w(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var n2 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? b(Object(n2), true).forEach(function(t3) {
          g.default(e2, t3, n2[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(n2)) : b(Object(n2)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(n2, t3));
        });
      }
      return e2;
    }
    var O = { pinching: false, scale: 1, translateX: 0, translateY: 0 };
    var E = (t2) => {
      let { imgProps: { style: i2 }, inline: a2, isCurrentImage: l2, pagerHeight: o2, pagerIsDragging: s2, setDisableDrag: c2, singleClickToZoom: g2 } = t2, p2 = f.default(t2.imgProps, y);
      const [m2, b2] = e.useState(false), E2 = e.useRef(null), [{ scale: C2, translateX: P2, translateY: j2 }, k2] = n.useSpring(() => w(w({}, O), {}, { onChange: (e2, t3) => {
        (e2.value.scale < 1 || !e2.value.pinching) && t3.start(O), e2.value.scale > 1 && v(E2) && t3.start(O);
      }, onRest: (e2, t3) => {
        1 === e2.value.scale && (t3.start(O), c2(false));
      } }));
      return e.useEffect(() => {
        l2 || 1 === C2.get() || k2.start(O);
      }, [l2, C2, k2]), r.useGesture({ onDrag: (e2) => {
        let { cancel: t3, first: n2, memo: r2 = { initialTranslateX: 0, initialTranslateY: 0 }, movement: [i3, a3], pinching: l3, tap: o3, touches: c3 } = e2;
        if (!(s2 || 1 === C2.get() || o3 || (i3 && a3 && !m2 && b2(true), c3 > 1 || l3 || C2.get() <= 1)))
          return C2.get() > 1 && v(E2) ? void t3() : n2 ? { initialTranslateX: P2.get(), initialTranslateY: j2.get() } : (k2.start({ translateX: r2.initialTranslateX + i3, translateY: r2.initialTranslateY + a3 }), r2);
      }, onDragEnd: (e2) => {
        let { memo: t3 } = e2;
        void 0 !== t3 && setTimeout(() => b2(false), 100);
      }, onPinch: (e2) => {
        let { cancel: t3, ctrlKey: n2, event: r2, last: i3, movement: [a3], origin: [l3, o3] } = e2;
        if (s2)
          return;
        if (c2(true), a3 && !m2 && b2(true), i3)
          return void t3();
        const u2 = n2 ? 1e3 : 250, d2 = C2.get() + a3 / u2, g3 = d2 - C2.get();
        let f2 = [l3, o3];
        "clientX" in r2 && "clientY" in r2 && n2 && (f2 = [r2.clientX, r2.clientY]);
        const [p3, v2] = h({ currentTranslate: [P2.get(), j2.get()], imageRef: E2, pinchDelta: g3, scale: C2.get(), touchOrigin: f2 });
        d2 < 0.5 ? k2.start({ pinching: true, scale: 0.5 }) : d2 > 3 ? k2.start({ pinching: true, scale: 3 }) : k2.start({ pinching: true, scale: d2, translateX: p3, translateY: v2 });
      }, onPinchEnd: () => {
        s2 || (C2.get() > 1 ? c2(true) : k2.start(O), setTimeout(() => b2(false), 100));
      } }, { domTarget: E2, drag: { filterTaps: true }, enabled: !a2, eventOptions: { passive: false } }), ((t3) => {
        let { enabled: n2 = true, latency: r2 = 300, onDoubleClick: i3 = () => null, onSingleClick: a3 = () => null, ref: l3 } = t3;
        e.useEffect(() => {
          const e2 = l3.current;
          let t4, o3 = 0;
          const s3 = (e3) => {
            n2 && (o3 += 1, t4 = setTimeout(() => {
              1 === o3 ? a3(e3) : 2 === o3 && i3(e3), o3 = 0;
            }, r2));
          };
          return e2 == null ? void 0 : e2.addEventListener("click", s3), () => {
            e2 == null ? void 0 : e2.removeEventListener("click", s3), t4 && clearTimeout(t4);
          };
        });
      })({ [g2 ? "onSingleClick" : "onDoubleClick"]: (e2) => {
        if (s2 || m2)
          return void e2.stopPropagation();
        if (1 !== C2.get())
          return void k2.start(O);
        const { clientX: t3, clientY: n2 } = e2, r2 = C2.get() + 1, i3 = r2 - C2.get(), [a3, l3] = h({ currentTranslate: [P2.get(), j2.get()], imageRef: E2, pinchDelta: i3, scale: C2.get(), touchOrigin: [t3, n2] });
        c2(true), k2.start({ pinching: true, scale: r2, translateX: a3, translateY: l3 });
      }, enabled: !a2, latency: g2 ? 0 : 200, ref: E2 }), u.default.createElement(x, d.default({ $inline: a2, className: "lightbox-image", draggable: "false", onClick: (e2) => {
        e2.stopPropagation(), e2.nativeEvent.stopImmediatePropagation();
      }, onDragStart: (e2) => {
        e2.preventDefault();
      }, ref: E2, style: w(w({}, i2), {}, { maxHeight: o2, transform: n.to([C2, P2, j2], (e2, t3, n2) => `translate(${t3}px, ${n2}px) scale(${e2})`) }, l2 && { willChange: "transform" }) }, p2));
    };
    E.displayName = "Image";
    var x = p.default(n.animated.img)`
    width: auto;
    height: auto;
    max-width: 100%;
    user-select: none;
    touch-action: ${(e2) => {
      let { $inline: t2 } = e2;
      return t2 ? "pan-y" : "none";
    }};
    ::selection {
        background: none;
    }
`;
    var C = (t2) => {
      let { currentIndex: i2, images: a2, imageStageHeight: l2, imageStageWidth: o2, inline: s2, onClose: c2, onNext: g2, onPrev: f2, renderImageOverlay: p2, singleClickToZoom: m2 } = t2;
      const h2 = e.useRef(true), [v2, y2] = e.useState(false), [b2, w2] = e.useState("100%"), [O2, x2] = e.useState(false);
      e.useEffect(() => {
        const e2 = s2 ? l2 : l2 - 50;
        e2 !== b2 && w2(e2);
      }, [s2, b2, l2]);
      const C2 = u.default.useCallback(function(e2) {
        const t3 = (e2 - i2) * o2 + (arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0 : 0);
        return e2 < i2 - 1 || e2 > i2 + 1 ? { display: "none", x: t3 } : { display: "flex", x: t3 };
      }, [i2, o2]), [I2, $2] = n.useSprings(a2.length, (e2) => C2(e2));
      e.useEffect(() => {
        h2.current ? h2.current = false : $2.start((e2) => C2(e2));
      }, [i2, C2, $2]);
      const N2 = r.useGesture({ onDrag: (e2) => {
        let { active: t3, cancel: n2, direction: [r2], distance: i3, down: a3, movement: [l3], tap: s3, touches: c3, velocity: u2 } = e2;
        if (v2 || 0 === l3 || s3)
          return;
        O2 || x2(true);
        const d2 = Math.abs(r2) > 0.7;
        if ((a3 && d2 && i3 > o2 / 3.5 || a3 && d2 && u2 > 2) && t3) {
          const e3 = r2 > 0 ? -1 : 1;
          return n2(), void (e3 > 0 ? g2() : e3 < 0 && f2());
        }
        c3 > 1 ? n2() : $2.start((e3) => C2(e3, a3, l3));
      }, onDragEnd: () => {
        O2 && ($2.start((e2) => C2(e2)), setTimeout(() => x2(false), 100));
      }, onWheel: (e2) => {
        let { ctrlKey: t3, direction: [n2, r2], velocity: i3 } = e2;
        if (t3 || v2 || 0 === i3)
          return;
        O2 || x2(true);
        if (i3 > 1.1) {
          const e3 = n2 + r2 > 0 ? -1 : 1;
          e3 > 0 ? g2() : e3 < 0 && f2();
        }
      }, onWheelEnd: () => {
        $2.start((e2) => C2(e2)), setTimeout(() => x2(false), 100);
      } }, { drag: { filterTaps: true }, wheel: { enabled: !s2 } });
      return u.default.createElement(P, null, I2.map((e2, t3) => {
        let { display: n2, x: r2 } = e2;
        return u.default.createElement(D, d.default({ $inline: s2 }, N2(), { className: "lightbox-image-pager", key: t3, onClick: () => {
          if (c2)
            return Math.abs(r2.get()) < 1 && !v2 && c2();
        }, role: "presentation", style: { display: n2, transform: r2.to((e3) => `translateX(${e3}px)`) } }), u.default.createElement(k, null, u.default.createElement(j, null, u.default.createElement(T, { $inline: s2, onClick: (e3) => {
          e3.stopPropagation(), e3.nativeEvent.stopImmediatePropagation();
        } }, u.default.createElement(E, { imgProps: a2[t3], inline: s2, isCurrentImage: t3 === i2, pagerHeight: b2, pagerIsDragging: O2, setDisableDrag: y2, singleClickToZoom: m2 }), p2()))));
      }));
    };
    C.displayName = "ImagePager";
    var P = p.default.div`
    height: 100%;
    width: 100%;
`;
    var j = p.default.div`
    display: flex;
    justify-content: center;
    align-items: center;
`;
    var k = p.default.div`
    width: 100%;
    display: flex;
    justify-content: center;
`;
    var D = p.default(n.animated.span)`
    position: absolute;
    top: 0px;
    left: 0px;
    right: 0px;
    bottom: 0px;
    height: 100%;
    width: 100%;
    will-change: transform;
    touch-action: ${(e2) => {
      let { $inline: t2 } = e2;
      return t2 ? "pan-y" : "none";
    }};
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
`;
    var T = p.default.div`
    position: relative;
    touch-action: ${(e2) => {
      let { $inline: t2 } = e2;
      return t2 ? "pan-y" : "none";
    }};
    user-select: none;
    display: flex;
    justify-content: center;
    width: 100%;
`;
    var I = (e2) => {
      let { currentIndex: t2, images: n2 } = e2;
      return u.createElement($, null, n2.map((e3, n3) => {
        let { alt: r2, src: i2 } = e3;
        return u.createElement(N, { $isCurrentImage: n3 === t2, alt: r2, key: `${r2}-${i2}-${n3}`, src: i2 });
      }));
    };
    var $ = p.default.div`
    width: 100%;
    height: inherit;
`;
    var N = p.default.img`
    ${(e2) => {
      let { $isCurrentImage: t2 } = e2;
      return !t2 && l.css`
            visibility: hidden;
            display: none;
        `;
    }}
    height:100%;
    width: 100%;
    object-fit: contain;
`;
    var S = (t2) => {
      let { className: n2 = "", currentIndex: r2, images: i2, inline: a2, onClose: l2, onNext: o2, onPrev: s2, renderImageOverlay: c2, renderNextButton: d2, renderPrevButton: g2, singleClickToZoom: f2 } = t2;
      const p2 = r2 > 0, m2 = r2 + 1 < i2.length, h2 = m2 ? o2 : () => null, v2 = p2 ? s2 : () => null, [{ height: y2, width: b2 }, w2] = (() => {
        var _a, _b;
        const t3 = e.useRef(null), [n3, r3] = e.useState(null), [i3, a3] = e.useState({ height: ((_a = t3.current) == null ? void 0 : _a.clientHeight) || 0, width: ((_b = t3.current) == null ? void 0 : _b.clientWidth) || 0 }), l3 = e.useCallback((e2) => {
          null !== e2 && (r3(e2), a3({ height: e2.clientHeight, width: e2.clientWidth }));
        }, []);
        return e.useEffect(() => {
          const e2 = () => {
            if (n3) {
              const e3 = n3.clientHeight, t4 = n3.clientWidth;
              e3 === i3.height && t4 === i3.width || a3({ height: e3, width: t4 });
            }
          };
          return window.addEventListener("resize", e2), window.addEventListener("orientationchange", e2), () => {
            window.removeEventListener("resize", e2), window.removeEventListener("orientationchange", e2);
          };
        }, [n3, i3.height, i3.width]), [i3, l3];
      })();
      return u.default.createElement(L, { className: n2, "data-testid": "lightbox-image-stage", ref: w2 }, g2({ canPrev: p2 }), b2 ? u.default.createElement(C, { currentIndex: r2, images: i2, imageStageHeight: y2, imageStageWidth: b2, inline: a2, onClose: l2, onNext: h2, onPrev: v2, renderImageOverlay: c2, singleClickToZoom: f2 }) : a2 ? u.default.createElement(I, { currentIndex: r2, images: i2 }) : null, d2({ canNext: m2 }));
    };
    var L = p.default.div`
    position: relative;
    height: 100%;
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
`;
    function W(e2, t2) {
      var n2 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var r2 = Object.getOwnPropertySymbols(e2);
        t2 && (r2 = r2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), n2.push.apply(n2, r2);
      }
      return n2;
    }
    function X(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var n2 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? W(Object(n2), true).forEach(function(t3) {
          g.default(e2, t3, n2[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(n2)) : W(Object(n2)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(n2, t3));
        });
      }
      return e2;
    }
    var H = (e2) => {
      let { children: t2, className: r2, isOpen: i2, pageTransitionConfig: a2, style: l2 } = e2;
      const o2 = { config: X(X({}, n.config.default), {}, { friction: 32, mass: 1, tension: 320 }), enter: { opacity: 1, transform: "scale(1)" }, from: { opacity: 0, transform: "scale(0.75)" }, leave: { opacity: 0, transform: "scale(0.75)" } }, s2 = n.useTransition(i2, X(X({}, o2), a2));
      return u.default.createElement(u.default.Fragment, null, s2((e3, n2) => n2 && u.default.createElement(Y, { className: "lightbox-container" + (r2 ? ` ${r2}` : ""), "data-testid": "lightbox-container", style: X(X({}, e3), l2) }, t2)));
    };
    var Y = p.default(n.animated.div)`
    display: flex;
    flex-direction: column;
    position: fixed;
    z-index: 400;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
`;
    var R = class extends u.default.Component {
      constructor() {
        super(...arguments), g.default(this, "portalContainer", void 0), g.default(this, "body", void 0), g.default(this, "preventWheel", (e2) => e2.preventDefault());
      }
      componentDidMount() {
        this.body = document.body, this.portalContainer = document.createElement("div"), this.portalContainer.setAttribute("class", "lightbox-portal"), this.body.appendChild(this.portalContainer), this.forceUpdate(), this.portalContainer.addEventListener("wheel", this.preventWheel);
      }
      componentWillUnmount() {
        this.portalContainer.removeEventListener("wheel", this.preventWheel), this.body.removeChild(this.portalContainer);
      }
      render() {
        if (void 0 === this.portalContainer)
          return null;
        const { children: e2 } = this.props;
        return u.default.createElement(u.default.Fragment, null, m.default.createPortal(e2, this.portalContainer));
      }
    };
    module.exports = (t2) => {
      let { className: n2 = "", currentIndex: r2, images: i2 = [], inline: a2 = false, isOpen: l2, onClose: o2, onNext: s2, onPrev: c2, pageTransitionConfig: d2 = null, renderFooter: g2 = () => null, renderHeader: f2 = () => null, renderImageOverlay: p2 = () => null, renderNextButton: m2 = () => null, renderPrevButton: h2 = () => null, singleClickToZoom: v2 = false, style: y2 = {} } = t2;
      e.useEffect(() => {
        const e2 = (e3) => {
          l2 && ["ArrowUp", "ArrowDown", "End", "Home", "PageUp", "PageDown"].includes(e3.key) && e3.preventDefault();
        }, t3 = (e3) => {
          if (l2)
            switch (e3.key) {
              case "ArrowLeft":
                c2();
                break;
              case "ArrowRight":
                s2();
                break;
              case "Escape":
                o2 && o2();
                break;
              default:
                e3.preventDefault();
            }
        };
        return document.addEventListener("keyup", t3), document.addEventListener("keydown", e2), () => {
          document.removeEventListener("keyup", t3), document.removeEventListener("keydown", e2);
        };
      });
      const b2 = u.default.createElement(S, { currentIndex: r2, images: i2, inline: a2, onClose: o2, onNext: s2, onPrev: c2, renderImageOverlay: p2, renderNextButton: m2, renderPrevButton: h2, singleClickToZoom: v2 });
      return a2 ? b2 : u.default.createElement(R, null, u.default.createElement(H, { className: n2, isOpen: l2, pageTransitionConfig: d2, style: y2 }, f2(), b2, g2()));
    };
  }
});
export default require_index_cjs();
//# sourceMappingURL=react-spring-lightbox.js.map
